<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Graphs · Virtual Plant Laboratory</title><meta name="title" content="Graphs · Virtual Plant Laboratory"/><meta property="og:title" content="Graphs · Virtual Plant Laboratory"/><meta property="twitter:title" content="Graphs · Virtual Plant Laboratory"/><meta name="description" content="Documentation for Virtual Plant Laboratory."/><meta property="og:description" content="Documentation for Virtual Plant Laboratory."/><meta property="twitter:description" content="Documentation for Virtual Plant Laboratory."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Virtual Plant Laboratory</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Virtual Plant Laboratory</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/Julia/">Julia basic concepts</a></li><li><a class="tocitem" href="../../manual/Graphs/">Dynamic graph creation and manipulation</a></li><li><a class="tocitem" href="../../manual/Geometry/Primitives/">Geometry primitives</a></li><li><a class="tocitem" href="../../manual/Geometry/Turtle/">Turtle geometry and scenes</a></li><li><a class="tocitem" href="../../manual/Raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../../manual/Visualization/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/intro_tut/">Intro</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Getting started with VPL</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/getting_started/algae/">Algae growth</a></li><li><a class="tocitem" href="../../tutorials/getting_started/snowflakes/">The Koch snowflake</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">From tree to forest</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/from_tree_forest/tree/">Tree</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/forest/">Forest</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/growthforest/">Growth forest</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/raytracedforest/">Ray-traced forest</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">More on rules and queries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/more_rules_queries/context/">Context sensitive rules</a></li><li><a class="tocitem" href="../../tutorials/more_rules_queries/relationalqueries/">Relational queries</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/GridCloner/">Setting up a grid cloner</a></li><li><a class="tocitem" href="../../howto/Message/">Messages in scenes</a></li><li><a class="tocitem" href="../../howto/Materials/">Multiple materials/colors</a></li><li><a class="tocitem" href="../../howto/Traversal/">Advanced traversal</a></li><li><a class="tocitem" href="../../howto/Coordinates/">Absolute coordinates</a></li><li><a class="tocitem" href="../../howto/LightSources/">Creating light sources</a></li><li><a class="tocitem" href="../../howto/Slicer/">Using the slicer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Graphs</a><ul class="internal"><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Private"><span>Private</span></a></li></ul></li><li><a class="tocitem" href="../geometry/">Scenes and 3D meshes</a></li><li><a class="tocitem" href="../turtle/">Turtle geometry</a></li><li><a class="tocitem" href="../raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../viz/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">VPLVerse</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">SkyDomes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/SkyDomes/">SkyDomes package</a></li><li><a class="tocitem" href="../../VPLVerse/SkyDomes/API/">SkyDomes API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Ecophys</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/Ecophys/">Ecophys package</a></li><li><a class="tocitem" href="../../VPLVerse/Ecophys/photosynthesis/">Photosynthesis API</a></li><li><a class="tocitem" href="../../VPLVerse/Ecophys/growth/">Growth API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">PlantSimEngine</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/PlantSimEngine/">PlantSimEngine package</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">PlantBioPhysics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/PlantBioPhysics/">PlantBioPhysics package</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developers/organization/">Internal organization</a></li><li><a class="tocitem" href="../../developers/use&amp;dev_packages/">Package and Environment Management for VPL</a></li><li><a class="tocitem" href="../../developers/style/">Styling protocol</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Graphs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Graphs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/VPLDocs/blob/master/docs/src/api/graphs.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Graphs"><a class="docs-heading-anchor" href="#Graphs">Graphs</a><a id="Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs" title="Permalink"></a></h1><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><p>Includes functions defined by PlantGraphs as well as methods for functions defined by other packages.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.Context" href="#PlantGraphs.Context"><code>PlantGraphs.Context</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Context</code></pre><p>Data structure than links a node to the rest of the graph.</p><p><strong>Fields</strong></p><ul><li><code>graph</code>: Dynamic graph that contains the node.</li><li><code>node</code>: Node inside the graph.</li></ul><p><strong>Details</strong></p><p>A <code>Context</code> object wraps references to a node and its associated graph. The purpose of this structure is to be able to test relationships among nodes within a graph (from with a query or rule), as well as access the data stored in a node (with <code>data()</code>) or the graph (with <code>graph_data()</code>).</p><p>Users do not build <code>Context</code> objects directly but they are provided by VPL as inputs to the user-defined functions inside rules and queries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Types.jl#L90-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.Graph-Tuple{}" href="#PlantGraphs.Graph-Tuple{}"><code>PlantGraphs.Graph</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Graph(;axiom, rules = nothing, data = nothing)</code></pre><p>Create a dynamic graph from an axiom, one or more rules and, optionally, graph-level variables.</p><p><strong>Arguments</strong></p><ul><li><code>axiom</code>: A single object inheriting from <code>Node</code> or a subgraph generated  with the graph construction DSL. It should represent the initial state of the dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>rules</code>:  A single <code>Rule</code> object or a tuple of <code>Rule</code> objects (optional). It should include all graph-rewriting rules of the graph.</li><li><code>data</code>: A single object of any user-defined type (optional). This will be the graph-level variable accessible from any rule or query applied to the graph.</li><li><code>FT</code>: Floating-point precision to be used when generating the 3D geometry associated to a graph.</li></ul><p><strong>Details</strong></p><p>All arguments are assigned by keyword. The axiom and rules are deep-copied when creating the graph but the graph-level variables (if a copy is needed due to mutability, the user needs to care of that).</p><p><strong>Returns</strong></p><p>An object of type <code>Graph</code> representing a dynamic graph. Printing this object results in a human-readable description of the type of data stored in the graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A0 &lt;: Node end;

julia&gt; struct B0 &lt;: Node end;

julia&gt; axiom = A0() + B0();

julia&gt; no_rules_graph = Graph(axiom = axiom);

julia&gt; rule = Rule(A0, rhs = x -&gt; A0() + B0());

julia&gt; rules_graph = Graph(axiom = axiom, rules = rule);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Graph.jl#L7-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.Node" href="#PlantGraphs.Node"><code>PlantGraphs.Node</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Node</code></pre><p>Abstract type from which every node in a graph should inherit. This allows using the graph construction DSL.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct bar &lt;: Node
           x::Int
       end;

julia&gt; b1 = bar(1);

julia&gt; b2 = bar(2);

julia&gt; b1 + b2;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Types.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.Query-Tuple{DataType}" href="#PlantGraphs.Query-Tuple{DataType}"><code>PlantGraphs.Query</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Query(N::DataType; condition = x -&gt; true)</code></pre><p>Create a query that matches nodes of type <code>nodetype</code> and a <code>condition</code>.</p><p><strong>Arguments</strong></p><ul><li><code>N::DataType</code>: Type of node to be matched.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: Function or function-like object that checks if a node should be selected.</li></ul><p><strong>Details</strong></p><p>If the <code>nodetype</code> should refer to a concrete type and match one of the types stored inside the graph. Abstract types or types that are not contained in the graph are allowed but the query will never return anything.</p><p>The <code>condition</code> must be a function or function-like object that takes a <code>Context</code> as input and returns <code>true</code> or <code>false</code>. The default <code>condition</code> always return <code>true</code> such that the query will</p><p><strong>Returns</strong></p><p>It returns an object of type <code>Query</code>. Use <code>apply()</code> to execute the query on a dynamic graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; struct B &lt;: Node end;

julia&gt; axiom = A() + B();

julia&gt; g = Graph(axiom = axiom);

julia&gt; query = Query(A);

julia&gt; apply(g, query);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Query.jl#L7-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.Rule-Tuple{DataType}" href="#PlantGraphs.Rule-Tuple{DataType}"><code>PlantGraphs.Rule</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rule(nodetype; lhs = x -&gt; true, rhs = x -&gt; nothing, captures = false)</code></pre><p>Create a replacement rule for nodes of type <code>nodetype</code>.</p><p><strong>Arguments</strong></p><ul><li><code>nodetype</code>: Type of node to be matched.</li></ul><p><strong>Keywords</strong></p><ul><li><code>lhs</code>: Function or function-like object that takes a <code>Context</code> object and returns whether the node should be replaced or not (with <code>true</code> or <code>false</code>).</li><li><code>rhs</code>: Function or function-like object that takes one or more <code>Context</code> objects and returns a replacement graph or <code>nothing</code>. If it takes several inputs, the first one will correspond to the node being replaced.</li><li><code>captures</code>: Either <code>false</code> or <code>true</code> to indicate whether the left-hand side of the rule is capturing nodes in the context of the replacement node to be used for the construction of the replace graph.</li></ul><p><strong>Details</strong></p><p>See VPL documentation for details on rule-based graph rewriting.</p><p><strong>Return</strong></p><p>An object of type <code>Rule</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; struct B &lt;: Node end;

julia&gt; axiom = A() + B();

julia&gt; rule = Rule(A, rhs = x -&gt; A() + B());

julia&gt; rules_graph = Graph(axiom = axiom, rules = rule);

julia&gt; rewrite!(rules_graph);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Rule.jl#L7-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractTrees.children-Tuple{PlantGraphs.Context}" href="#AbstractTrees.children-Tuple{PlantGraphs.Context}"><code>AbstractTrees.children</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">children(c::Context)</code></pre><p>Returns all the children of a node as <code>Context</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Context.jl#L304-L308">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.ancestor-Tuple{PlantGraphs.Context}" href="#PlantGraphs.ancestor-Tuple{PlantGraphs.Context}"><code>PlantGraphs.ancestor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ancestor(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Returns the first ancestor of a node that matches the <code>condition</code>. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input and returns <code>true</code> or <code>false</code>.</li><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when traversing the graph.</li></ul><p><strong>Details</strong></p><p>If <code>has_ancestor()</code> returns <code>false</code> for the same node and <code>condition</code>, <code>ancestor()</code> will return <code>missing</code>, otherwise it returns the <code>Context</code> associated to the matching node</p><p><strong>Returns</strong></p><p>Return a <code>Context</code> object or <code>missing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; function qfun(n)
           na = ancestor(n, condition = x -&gt; (data(x).val == 1))
           if !ismissing(na)
               data(na) isa B1
           else
               false
           end
       end;

julia&gt; Q1 = Query(A1, condition = qfun);

julia&gt; R1 = apply(g, Q1);

julia&gt; Q2 = Query(B1, condition = qfun);

julia&gt; R2 = apply(g, Q2);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Context.jl#L248-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.apply-Union{Tuple{N}, Tuple{Q}, Tuple{PlantGraphs.Graph, PlantGraphs.Query{N, Q}}} where {Q, N}" href="#PlantGraphs.apply-Union{Tuple{N}, Tuple{Q}, Tuple{PlantGraphs.Graph, PlantGraphs.Query{N, Q}}} where {Q, N}"><code>PlantGraphs.apply</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">apply(g::Graph, query::Query)</code></pre><p>Return an array with all the nodes in the graph that match the query supplied by the user.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; struct B &lt;: Node end;

julia&gt; axiom = A() + B();

julia&gt; g = Graph(axiom = axiom);

julia&gt; query = Query(A);

julia&gt; apply(g, query);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Query.jl#L67-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.calculate_resolution-Tuple{}" href="#PlantGraphs.calculate_resolution-Tuple{}"><code>PlantGraphs.calculate_resolution</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_resolution(;width = 1024/300*2.54, height = 768/300*2.54,
                      format = &quot;raster&quot;, dpi = 300)</code></pre><p>Calculate the resolution required to achieve a specific <code>width</code> and <code>height</code> (in cm) of the exported image, with a particular <code>dpi</code> (for raster formats).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Draw.jl#L152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.data-Tuple{PlantGraphs.Context}" href="#PlantGraphs.data-Tuple{PlantGraphs.Context}"><code>PlantGraphs.data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">data(c::Context)</code></pre><p>Returns the data stored in a node. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Context.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.data-Tuple{PlantGraphs.Graph}" href="#PlantGraphs.data-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>data(g::Graph)</p><p>Returns the graph-level variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; axiom = A();

julia&gt; g = Graph(axiom = axiom, data = 2);

julia&gt; data(g);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Graph.jl#L82-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.draw-Tuple{PlantGraphs.Graph}" href="#PlantGraphs.draw-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.draw</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">draw(g::Graph; resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15,
     node_size = 5)</code></pre><p>Visualize a graph as network diagram.</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The graph to be visualized.</li></ul><p><strong>Keywords</strong></p><ul><li><code>resolution = (1920, 1080)</code>: The resolution of the image to be rendered, in pixels (online relevant for native and web backends). Default resolution is HD.</li><li><code>nlabels_textsize = 15</code>: Customize the size of the labels in the diagram.</li><li><code>arrow_size = 15</code>: Customize the size of the arrows representing edges in the diagram.</li><li><code>node_size = 5</code>: Customize the size of the nodes in the diagram.</li></ul><p><strong>Details</strong></p><p>By default, nodes are labelled with the type of data stored and their unique ID. See function <code>node_label()</code> to customize the label for different types of data.</p><p>See <code>save</code> from FileIO to export the network diagram as a raster or vector image (depending on the backend). The function <code>calculate_resolution()</code> can be useful to ensure a particular dpi of the exported image (assuming some physical size).</p><p>The graphics backend will interact with the environment where the Julia code is being executed (i.e., terminal, IDE such as VS Code, interactive notebook such as Jupyter or Pluto). These interactions are all controlled by the graphics package Makie that VPL relies on. Some details on the expected behavior specific to <code>draw()</code> can be found in the general VPL documentation.</p><p><strong>Returns</strong></p><p>This function returns a Makie <code>Figure</code> object, while producing the visualization as a side effect.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; import CairoMakie; # or GLMakie, WGLMakie, etc.

julia&gt; draw(g);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Draw.jl#L96-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.draw-Tuple{PlantGraphs.StaticGraph}" href="#PlantGraphs.draw-Tuple{PlantGraphs.StaticGraph}"><code>PlantGraphs.draw</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">draw(g::StaticGraph; resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15,
     node_size = 5)</code></pre><p>Equivalent to the method <code>draw(g::Graph; kwargs...)</code> but  to visualize static graphs (e.g., the axiom of a graph).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Draw.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.get_descendant" href="#PlantGraphs.get_descendant"><code>PlantGraphs.get_descendant</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_descendant(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Returns the first descendant of a node that matches the <code>condition</code>. Intended to be used within a rule or query.</p><p><code>getdescendant</code> is an alias for <code>get_descendant</code> for compatibility with AbstractTrees.jl</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input and returns <code>true</code> or <code>false</code>.</li><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when traversing the graph.</li></ul><p><strong>Details</strong></p><p>If <code>has_descendant()</code> returns <code>false</code> for the same node and <code>condition</code>, <code>get_descendant()</code> will return <code>missing</code>, otherwise it returns the <code>Context</code> associated to the matching node.</p><p><strong>Return</strong></p><p>Return a <code>Context</code> object or <code>missing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; function qfun(n)
           na = get_descendant(n, condition = x -&gt; (data(x).val == 1))
           if !ismissing(na)
               data(na) isa B1
           else
               false
           end
       end;

julia&gt; Q1 = Query(A1, condition = qfun);

julia&gt; R1 = apply(g, Q1);

julia&gt; Q2 = Query(B1, condition = qfun);

julia&gt; R2 = apply(g, Q2);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Context.jl#L321-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.get_root" href="#PlantGraphs.get_root"><code>PlantGraphs.get_root</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_root(g::Graph)</code></pre><p>Extract the root node of a graph.</p><p>You may also use <code>getroot</code> (for compatibility with AbstractTrees.jl).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/StaticGraph.jl#L102-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.graph_data-Tuple{PlantGraphs.Context}" href="#PlantGraphs.graph_data-Tuple{PlantGraphs.Context}"><code>PlantGraphs.graph_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">graph_data(c::Context)</code></pre><p>Returns the graph-level variables. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Context.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.has_ancestor-Tuple{PlantGraphs.Context}" href="#PlantGraphs.has_ancestor-Tuple{PlantGraphs.Context}"><code>PlantGraphs.has_ancestor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_ancestor(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Check if a node has an ancestor that matches the condition. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input and returns <code>true</code> or <code>false</code>.</li><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when traversing the graph.</li></ul><p><strong>Details</strong></p><p>This function traverses the graph from the node associated to <code>c</code> towards the root of the graph until a node is found for which <code>condition</code> returns <code>true</code>. If no node meets the condition, then it will return <code>false</code>. The defaults values for this function are such that the algorithm always returns <code>true</code> after one step (unless it is applied to the root node) in which case it is equivalent to calling <code>has_parent</code> on the node.</p><p>The number of levels that the algorithm is allowed to traverse is capped by <code>max_level</code> (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).</p><p>The function <code>condition</code> should take an object of type <code>Context</code> as input and return <code>true</code> or <code>false</code>.</p><p><strong>Returns</strong></p><p>Return a tuple with two values a <code>Bool</code> and an <code>Int</code>, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(2) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; function qfun(n)
            has_ancestor(n, condition = x -&gt; data(x).val == 1)[1]
       end;

julia&gt; Q1 = Query(A1, condition = qfun);

julia&gt; R1 = apply(g, Q1);

julia&gt; Q2 = Query(B1, condition = qfun);

julia&gt; R2 = apply(g, Q2);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Context.jl#L55-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.has_children-Tuple{PlantGraphs.Context}" href="#PlantGraphs.has_children-Tuple{PlantGraphs.Context}"><code>PlantGraphs.has_children</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_children(c::Context)</code></pre><p>Check if a node has at least one child and return <code>true</code> or <code>false</code>. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Context.jl#L116-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.has_descendant-Tuple{PlantGraphs.Context}" href="#PlantGraphs.has_descendant-Tuple{PlantGraphs.Context}"><code>PlantGraphs.has_descendant</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_descendant(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Check if a node has a descendant that matches the optional condition. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input and returns <code>true</code> or <code>false</code>.</li><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when traversing the graph.</li></ul><p><strong>Details</strong></p><p>This function traverses the graph from the node associated to <code>c</code> towards the leaves of the graph until a node is found for which <code>condition</code> returns <code>true</code>. If no node meets the condition, then it will return <code>false</code>. The defaults values for this function are such that the algorithm always returns <code>true</code> after one step (unless it is applied to a leaf node) in which case it is equivalent to calling <code>has_children</code> on the node.</p><p>The number of levels that the algorithm is allowed to traverse is capped by <code>max_level</code> (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).</p><p>The function <code>condition</code> should take an object of type <code>Context</code> as input and return <code>true</code> or <code>false</code>.</p><p><strong>Returns</strong></p><p>Return a tuple with two values a <code>Bool</code> and an <code>Int</code>, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(2) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; function qfun(n)
           has_descendant(n, condition = x -&gt; data(x).val == 1)[1]
       end;

julia&gt; Q1 = Query(A1, condition = qfun);

julia&gt; R1 = apply(g, Q1);

julia&gt; Q2 = Query(B1, condition = qfun);

julia&gt; R2 = apply(g, Q2);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Context.jl#L132-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.has_parent-Tuple{PlantGraphs.Context}" href="#PlantGraphs.has_parent-Tuple{PlantGraphs.Context}"><code>PlantGraphs.has_parent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_parent(c::Context)</code></pre><p>Check if a node has a parent and return <code>true</code> or <code>false</code>. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Context.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.is_leaf-Tuple{PlantGraphs.Context}" href="#PlantGraphs.is_leaf-Tuple{PlantGraphs.Context}"><code>PlantGraphs.is_leaf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_leaf(c::Context)</code></pre><p>Check if a node is a leaf in the graph (i.e., has no children) and return <code>true</code> or <code>false</code>. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Context.jl#L124-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.is_root" href="#PlantGraphs.is_root"><code>PlantGraphs.is_root</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_root(c::Context)</code></pre><p>Check if a node is the root of the graph (i.e., has no parent) and return <code>true</code> or <code>false</code>. Intended to be used within a rule or query.</p><p><code>isroot</code> is an alias for <code>is_root</code> for compatibility with AbstractTrees.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Context.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.node_label-Tuple{PlantGraphs.Node, Any}" href="#PlantGraphs.node_label-Tuple{PlantGraphs.Node, Any}"><code>PlantGraphs.node_label</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">node_label(n::Node, id)</code></pre><p>Function to construct a label for a node to be used by <code>draw()</code> when visualizing. The user can specialize this method for user-defined data types to customize the labels. By default, the type of data stored in the node and the unique ID of the node are used as labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Draw.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.rewrite!-Tuple{PlantGraphs.Graph}" href="#PlantGraphs.rewrite!-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.rewrite!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rewrite!(g::Graph)</code></pre><p>Apply the graph-rewriting rules stored in the graph.</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The graph to be rewritten. It will be modified in-place.</li></ul><p><strong>Details</strong></p><p>This function will match the left-hand sides of all the rules in a graph. If any node is matched by more than one rule this will result in an error. The rules are then applied in order to replaced the matched nodes with the result of executing the right hand side of the rules. The rules are applied in the order in which they are stored in the graph but the order in which the nodes are processed is not defined. Since graph rewriting is semantically a parallel process, the rules should not be rely on any particular order for their functioning.</p><p><strong>Returns</strong></p><p>This function returns <code>nothing</code>, but the graph passed as input will be modified by the execution of the rules.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; struct B &lt;: Node end;

julia&gt; axiom = A() + B();

julia&gt; rule = Rule(A, rhs = x -&gt; A() + B());

julia&gt; g = Graph(axiom = axiom, rules = rule);

julia&gt; rewrite!(g);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Rule.jl#L161-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.rules-Tuple{PlantGraphs.Graph}" href="#PlantGraphs.rules-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.rules</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rules(g::Graph)</code></pre><p>Returns a tuple with all the graph-rewriting rules stored in a dynamic graph</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; struct B &lt;: Node end;

julia&gt; axiom = A() + B();

julia&gt; rule = Rule(A, rhs = x -&gt; A() + B());

julia&gt; rules_graph = Graph(axiom = axiom, rules = rule);

julia&gt; rules(rules_graph);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Graph.jl#L60-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.traverse-Tuple{PlantGraphs.Graph}" href="#PlantGraphs.traverse-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.traverse</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">traverse(g::Graph; fun = () -&gt; nothing, order = &quot;any&quot;, ID = root_id(g))</code></pre><p>Iterates over all the nodes in the graph and execute for the function <code>fun</code> on each node</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The graph object that will be traversed.</li></ul><p><strong>Keywords</strong></p><ul><li><code>fun</code>: A function or function-like object defined by the user that will be applied to each node.</li><li><code>order</code>: Order in which the nodes in the graph will be visited. It can be &quot;any&quot; (default), &quot;dfs&quot; (depth-first search) or &quot;bfs&quot; (breadth-first search).</li><li><code>ID</code>: The ID of the node where the traveral should start. By default, traversal starts at the root of the graph.</li></ul><p><strong>Details</strong></p><p>When <code>order = &quot;any</code> traveral happens in the order in which the nodes are stored in the graph. This order is arbitrary (it does not correspond to the order in which nodes are created) but it should be reproducible (i.e., the same code will store the nodes in the same order). For algorithms that require use <code>any = &quot;dfs&quot;</code> or <code>any = &quot;bfs&quot;</code>.</p><p>When <code>order = &quot;dfs&quot;</code> the traveral happens in a depth-first order. That is, all nodes in a branch of the graph are visited until reach a leaf node, then moving to the next branch. Hence, this algorithm should always generate the same result when applied to the same graph (assuming the user-defined function is not stochastic)</p><p>When <code>order = &quot;bfs&quot;</code> the traveral happens in a breadth-first order. That is, all nodes at a given depth of the the graph are visited first, then moving on to the next level. Hence, this algorithm should always generate the same result when applied to the same graph (assuming the user-defined function is not stochastic). For a version of this function that us depth-first order see <code>traverse_dfs</code>.</p><p>This function does not store any results generated by <code>fun</code>. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).</p><p>The function or function-like object provided by the user should take only one argument that corresponds to applying <code>data()</code> to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see <code>Query</code> and general VPL documentation).</p><p><strong>Returns</strong></p><p>This function returns nothing but <code>fun</code> may have side-effects.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; struct Foo
         vals::Vector{Int}
       end;

julia&gt; function (f::Foo)(x)
         push!(f.vals, x.val)
       end;

julia&gt; f = Foo(Int[]);

julia&gt; axiom = A1(2) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; traverse(g, fun = f);

julia&gt; traverse(g, fun = f, order = &quot;dfs&quot;);

julia&gt; traverse(g, fun = f, order = &quot;bfs&quot;);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Algorithms.jl#L7-L79">source</a></section></article><h2 id="Private"><a class="docs-heading-anchor" href="#Private">Private</a><a id="Private-1"></a><a class="docs-heading-anchor-permalink" href="#Private" title="Permalink"></a></h2><p>Private functions, types or constants from <code>PlantGraphs</code>. These are not exported, so you need to prefix the function name with <code>PlantGraphs.</code> to access them. Also bear in mind that these are not part of the public API, so they may change without notice.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{PlantGraphs.Node, PlantGraphs.Node}" href="#Base.:+-Tuple{PlantGraphs.Node, PlantGraphs.Node}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">+(n1::Node, n2::Node)</code></pre><p>Creates a graph with two nodes where <code>n1</code> is the root and <code>n2</code> is the insertion point.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + B1(1);

julia&gt; import CairoMakie; # or GLMakie, WGLMakie, etc.

julia&gt; draw(axiom);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/GraphConstruction.jl#L52-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{PlantGraphs.Node, PlantGraphs.StaticGraph}" href="#Base.:+-Tuple{PlantGraphs.Node, PlantGraphs.StaticGraph}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">+(n::Node, g::StaticGraph)</code></pre><p>Creates a graph as the result of appending the static graph <code>g</code> to the node <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + B1(1);

julia&gt; axiom = A1(2) + axiom;

julia&gt; import CairoMakie; # or GLMakie, WGLMakie, etc.

julia&gt; draw(axiom);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/GraphConstruction.jl#L100-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{PlantGraphs.Node, Tuple}" href="#Base.:+-Tuple{PlantGraphs.Node, Tuple}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">+(g::StaticGraph, T::Tuple)
+(n::Node, T::Tuple)</code></pre><p>Creates a graph as the result of appending a tuple of graphs/nodes <code>T</code> to the insertion point of the graph <code>g</code> or node <code>n</code>. Each graph/node in <code>L</code> becomes a branch.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + (B1(1) + A1(3), B1(4));

julia&gt; import CairoMakie; # or GLMakie, WGLMakie, etc.

julia&gt; draw(axiom);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/GraphConstruction.jl#L163-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.Node}" href="#Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.Node}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">+(g::StaticGraph, n::Node)</code></pre><p>Creates a graph as the result of appending the node <code>n</code> to the insertion point of graph <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + B1(1);

julia&gt; axiom = axiom + A1(2);

julia&gt; import CairoMakie; # or GLMakie, WGLMakie, etc.

julia&gt; draw(axiom);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/GraphConstruction.jl#L78-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.StaticGraph}" href="#Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.StaticGraph}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">+(g1::StaticGraph, g2::StaticGraph)</code></pre><p>Creates a graph as the result of appending <code>g2</code> to the insertion point of <code>g1</code>. The insertion point of the final graph corresponds to the insertion point of <code>g2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom1 = A1(1) + B1(1);

julia&gt; axiom2 = A1(2) + B1(2);

julia&gt; axiom = axiom1 + axiom2;

julia&gt; import CairoMakie; # or GLMakie, WGLMakie, etc.

julia&gt; draw(axiom);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/GraphConstruction.jl#L123-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.parent-Tuple{PlantGraphs.Context}" href="#Base.parent-Tuple{PlantGraphs.Context}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parent(c::Context; nsteps::Int)</code></pre><p>Returns the parent of a node that is <code>nsteps</code> away towards the root of the graph. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>nsteps</code>: Number of steps to traverse the graph towards the root node.</li></ul><p><strong>Details</strong></p><p>If <code>has_parent()</code> returns <code>false</code> for the same node or the algorithm has reached the root node but <code>nsteps</code> have not been reached, then <code>parent()</code> will return <code>missing</code>, otherwise it returns the <code>Context</code> associated to the matching node.</p><p><strong>Return</strong></p><p>Return a <code>Context</code> object or <code>missing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(2) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; function qfun(n)
           np = parent(n, nsteps = 2)
           !ismissing(np) &amp;&amp; data(np).val == 2
       end;

julia&gt; Q1 = Query(A1, condition = qfun);

julia&gt; R1 = apply(g, Q1);

julia&gt; Q2 = Query(B1, condition = qfun);

julia&gt; R2 = apply(g, Q2);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/Context.jl#L197-L240">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.generate_id-Tuple{}" href="#PlantGraphs.generate_id-Tuple{}"><code>PlantGraphs.generate_id</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generate_id()</code></pre><p>Generate a new unique ID for a node in a graph and update the ID counter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/StaticGraph.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.get_id!-Tuple{}" href="#PlantGraphs.get_id!-Tuple{}"><code>PlantGraphs.get_id!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_id!()</code></pre><p>Get the current value of the ID counter for generating unique IDs for nodes in graphs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/StaticGraph.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.reset_id!-Tuple{}" href="#PlantGraphs.reset_id!-Tuple{}"><code>PlantGraphs.reset_id!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reset_id!()</code></pre><p>Reset the ID counter for generating unique IDs for nodes in graphs to zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/StaticGraph.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.set_id!-Tuple{Any}" href="#PlantGraphs.set_id!-Tuple{Any}"><code>PlantGraphs.set_id!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_id!(id)</code></pre><p>Set the ID counter for generating unique IDs for nodes in graphs to any integer value <code>id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.0.3/src/StaticGraph.jl#L38-L43">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../howto/Slicer/">« Using the slicer</a><a class="docs-footer-nextpage" href="../geometry/">Scenes and 3D meshes »</a><div class="flexbox-break"></div></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Wednesday 19 February 2025 13:03">Wednesday 19 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
