<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced traversal · Virtual Plant Laboratory</title><meta name="title" content="Advanced traversal · Virtual Plant Laboratory"/><meta property="og:title" content="Advanced traversal · Virtual Plant Laboratory"/><meta property="twitter:title" content="Advanced traversal · Virtual Plant Laboratory"/><meta name="description" content="Documentation for Virtual Plant Laboratory."/><meta property="og:description" content="Documentation for Virtual Plant Laboratory."/><meta property="twitter:description" content="Documentation for Virtual Plant Laboratory."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Virtual Plant Laboratory</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Virtual Plant Laboratory</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/Julia/">Julia basic concepts</a></li><li><a class="tocitem" href="../../manual/Graphs/">Dynamic graph creation and manipulation</a></li><li><a class="tocitem" href="../../manual/Geometry/Primitives/">Geometry primitives</a></li><li><a class="tocitem" href="../../manual/Geometry/Turtle/">Turtle geometry and scenes</a></li><li><a class="tocitem" href="../../manual/Raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../../manual/Visualization/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/intro_tut/">Intro</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Getting started with VPL</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/getting_started/algae/">Algae growth</a></li><li><a class="tocitem" href="../../tutorials/getting_started/snowflakes/">The Koch snowflake</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">From tree to forest</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/from_tree_forest/tree/">Tree</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/forest/">Forest</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/growthforest/">Growth forest</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/raytracedforest/">Ray-traced forest</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">More on rules and queries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/more_rules_queries/context/">Context sensitive rules</a></li><li><a class="tocitem" href="../../tutorials/more_rules_queries/relationalqueries/">Relational queries</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../GridCloner/">Setting up a grid cloner</a></li><li><a class="tocitem" href="../Message/">Messages in scenes</a></li><li><a class="tocitem" href="../Materials/">Multiple materials/colors</a></li><li class="is-active"><a class="tocitem" href>Advanced traversal</a><ul class="internal"><li><a class="tocitem" href="#Relational-queries"><span>Relational queries</span></a></li><li><a class="tocitem" href="#Annotated-topology"><span>Annotated topology</span></a></li><li><a class="tocitem" href="#Ad-hoc-traversal"><span>Ad-hoc traversal</span></a></li></ul></li><li><a class="tocitem" href="../Coordinates/">Absolute coordinates</a></li><li><a class="tocitem" href="../LightSources/">Creating light sources</a></li><li><a class="tocitem" href="../Slicer/">Using the slicer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/graphs/">Graphs</a></li><li><a class="tocitem" href="../../api/geometry/">Scenes and 3D meshes</a></li><li><a class="tocitem" href="../../api/turtle/">Turtle geometry</a></li><li><a class="tocitem" href="../../api/raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../../api/viz/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">VPLVerse</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">SkyDomes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/SkyDomes/">SkyDomes package</a></li><li><a class="tocitem" href="../../VPLVerse/SkyDomes/API/">SkyDomes API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Ecophys</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/Ecophys/">Ecophys package</a></li><li><a class="tocitem" href="../../VPLVerse/Ecophys/photosynthesis/">Photosynthesis API</a></li><li><a class="tocitem" href="../../VPLVerse/Ecophys/growth/">Growth API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">PlantSimEngine</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/PlantSimEngine/">PlantSimEngine package</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">PlantBioPhysics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/PlantBioPhysics/">PlantBioPhysics package</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developers/organization/">Internal organization</a></li><li><a class="tocitem" href="../../developers/use&amp;dev_packages/">Package and Environment Management for VPL</a></li><li><a class="tocitem" href="../../developers/style/">Styling protocol</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How-to guides</a></li><li class="is-active"><a href>Advanced traversal</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Advanced traversal</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/VPLDocs/blob/master/docs/src/howto/Traversal.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Traversing-a-graph"><a class="docs-heading-anchor" href="#Traversing-a-graph">Traversing a graph</a><a id="Traversing-a-graph-1"></a><a class="docs-heading-anchor-permalink" href="#Traversing-a-graph" title="Permalink"></a></h1><p>Alejandro Morales</p><p>Centre for Crop Systems Analysis - Wageningen University</p><p>In this guide we will see how to address one possible situation where there is need to traverse a graph to accumulate information in a relational manner. The key idea in this example is that a given node of a graph requires accumulated information from all the descendent nodes of a particular type. This pattern shows up in many different contexts such as (i) calculating the probability of bud break as affected by apical dominance (without explict simulation of hormone transport) or (ii) the pipe model (where the cross-sectional area of a stem at a given point is proportional to the leaf area above that point).</p><p>This problem can be solved in a number of ways, which differ in terms of complexity and performance:</p><ol><li>Relational query: For every target node, query the graph for all the descendent nodes of</li></ol><p>a particular type and accumulate the information. This does not require any change to the rewriting rules and allows for complex relationships (see tutorials for examples).</p><ol><li>Annotated topology: Assign each target node and descendents with a level tag such that</li></ol><p>we can reconstruct later all the descendents of a particular node (i.e., all nodes of the same level or higher). This requires a change to the rewriting rules to add the level tag but the traversal is simple as we simply extract all the relevant nodes from the graph and perform the logic outside of the graph by filtering for different tag levels.</p><ol><li>Ad-hoc traversal: Use the <code>traverse_dfs()</code> or <code>traverse_bfs()</code> functions to write an</li></ol><p>ad-hoc traversal algorithm. Since the accumulation must happen in reverse (from the leaf nodes towards the root node), the ad-hoc function needs to be written in a recursive manner, most likely keeping its own stack of nodes. This is the most complex solution but also (potentially) the most efficient one as no nodes need to be extracted and each graph is visited exactly once.</p><p>To illustrate all these approaches, let&#39;s create a simple graph that represents the essence of the problem. We are going to assume to types of nodes (<code>A</code> and <code>B</code>), where the target nodes are of type <code>A</code> and the descendents of interest include both types. The information to be accumulated is a simple integer that we will call <code>state</code>. The result of accumulating the states will be stored in the <code>value</code>. We also add the <code>level</code> tag for second approach. The types are defined in a module as usual:</p><pre><code class="language-julia hljs">using VirtualPlantLab
import GLMakie
module TravTypes
    import PlantGraphs: Node
    export A, B
    @kwdef mutable struct A &lt;: Node
        value::Float64 = 0.0
        state::Float64 = 0.0
        level::Int     = 0
    end
    @kwdef struct B &lt;: Node
        state::Float64 = 0.0
        level::Int     = 0
    end
end

using .TravTypes

# Function that generates the arguments to create a node
fill(level) = (level = level, state = rand())
# Motif of the graph (`;fill(l)...` is equivalent to typing `level = l, state = rand()`)
motif(l) = A(;fill(l)...) + (B(;fill(l)...), B(;fill(l)...) + (B(;fill(l)...), B(;fill(l)...)))
# Create the graph by repeating the motif 10 times
axiom = motif(1)
for i in 2:10
    axiom += motif(i)
end</code></pre><p>We specialize <code>darw()</code> to include the level tag and the state of each node when we draw the graph. Remember that this can be achieved by defining methods for <code>node_label()</code> for each type of node.</p><pre><code class="language-julia hljs">PlantGraphs.node_label(node::A, id) = &quot;A: $(node.level) - $(round(node.value, digits = 2))&quot;
PlantGraphs.node_label(node::B, id) = &quot;B: $(node.level)&quot;
g = Graph(axiom = axiom)
draw(g)</code></pre><h2 id="Relational-queries"><a class="docs-heading-anchor" href="#Relational-queries">Relational queries</a><a id="Relational-queries-1"></a><a class="docs-heading-anchor-permalink" href="#Relational-queries" title="Permalink"></a></h2><p>The first approach is to use relational queries to accumulate the information as a side-effect. Note that we do not actually return the nodes as that is not required, we simple use the query mechanism to access the context of each node so that we can traverse the graph in a relational manner.</p><p>We could also implement this logic inside a rule if the computation performed for each node would affect whether a particular rule needs to be triggered or not (for example, if we were calculating the probability of a lateral bud breaking).</p><p>First, we construct the function that will be used to accumulate the information and modify the node in-place as a side-effect. We then return the nodes.</p><pre><code class="language-julia hljs">function accumulate(node)
    # Extract the first child and put it into a stack
    stack = [children(node)...]
    state = 0.0
    while !isempty(stack)
        # Pop the last child from the stack
        child = pop!(stack)
        # Accumulate the state
        state += data(child).state
        # Add the children of the child to the stack
        if has_children(child)
            for child in children(child)
                push!(stack, child)
            end
        end
    end
    data(node).value = state
    return true
end

# We not construct the query object and apply it
q = Query(A, condition = accumulate)
apply(g, q)
draw(g)</code></pre><h2 id="Annotated-topology"><a class="docs-heading-anchor" href="#Annotated-topology">Annotated topology</a><a id="Annotated-topology-1"></a><a class="docs-heading-anchor-permalink" href="#Annotated-topology" title="Permalink"></a></h2><p>In the second approach, we assign a level tag to each node so that we can reconstruct the descendents of a particular node. We already incorporated this when constructing the axiom, so here we simply extract the nodes and perform the accumulation based on on those level tags. The queries are very simply, as we just extract all nodes of a given type.</p><pre><code class="language-julia hljs">qA = Query(A)
qB = Query(B)
nodesA = apply(g, qA)
nodesB = apply(g, qB)</code></pre><p>Now we construct a table that will store the accumulated information for each level as a dictionary. We know that the total number of levels is equal to the number of <code>A</code> nodes.</p><pre><code class="language-julia hljs">accum = zeros(length(nodesA))</code></pre><p>The logic now is to add the <code>state</code> of each <code>A</code> or <code>B</code> node to all the levels that are equal or lower (we treat the positions in the array <code>accum</code> as the levels). We can then assign these values to the <code>value</code> field of the <code>A</code> nodes. Note how for <code>A</code> nodes we need to avoid adding the <code>state</code> of the node that defines the level (hence the <code>1:level-1</code>) since only descendents should be used.</p><pre><code class="language-julia hljs">for node in nodesB
    level = node.level
    accum[1:level] .+= node.state ## Add node.state to elements 1:level
end
for node in nodesA
    level = node.level
    level &gt; 1 &amp;&amp; (accum[1:level-1] .+= node.state)
end
for node in nodesA
    node.value = accum[node.level]
end
draw(g)</code></pre><h2 id="Ad-hoc-traversal"><a class="docs-heading-anchor" href="#Ad-hoc-traversal">Ad-hoc traversal</a><a id="Ad-hoc-traversal-1"></a><a class="docs-heading-anchor-permalink" href="#Ad-hoc-traversal" title="Permalink"></a></h2><p><em>Work in progress</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Materials/">« Multiple materials/colors</a><a class="docs-footer-nextpage" href="../Coordinates/">Absolute coordinates »</a><div class="flexbox-break"></div></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 17 July 2025 20:51">Thursday 17 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
