<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Forest · Virtual Plant Laboratory</title><meta name="title" content="Forest · Virtual Plant Laboratory"/><meta property="og:title" content="Forest · Virtual Plant Laboratory"/><meta property="twitter:title" content="Forest · Virtual Plant Laboratory"/><meta name="description" content="Documentation for Virtual Plant Laboratory."/><meta property="og:description" content="Documentation for Virtual Plant Laboratory."/><meta property="twitter:description" content="Documentation for Virtual Plant Laboratory."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Virtual Plant Laboratory</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Virtual Plant Laboratory</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/Julia/">Julia basic concepts</a></li><li><a class="tocitem" href="../../../manual/Graphs/">Dynamic graph creation and manipulation</a></li><li><a class="tocitem" href="../../../manual/Geometry/Primitives/">Geometry primitives</a></li><li><a class="tocitem" href="../../../manual/Geometry/Turtle/">Turtle geometry and scenes</a></li><li><a class="tocitem" href="../../../manual/Raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../../../manual/Visualization/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro_tut/">Intro</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Getting started with VPL</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../getting_started/algae/">Algae growth</a></li><li><a class="tocitem" href="../../getting_started/snowflakes/">The Koch snowflake</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">From tree to forest</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tree/">Tree</a></li><li class="is-active"><a class="tocitem" href>Forest</a><ul class="internal"><li><a class="tocitem" href="#Sequential-simulation"><span>Sequential simulation</span></a></li><li><a class="tocitem" href="#Multithreaded-simulation"><span>Multithreaded simulation</span></a></li><li class="toplevel"><a class="tocitem" href="#Customizing-the-scene"><span>Customizing the scene</span></a></li></ul></li><li><a class="tocitem" href="../growthforest/">Growth forest</a></li><li><a class="tocitem" href="../raytracedforest/">Ray-traced forest</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">More on rules and queries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../more_rules_queries/context/">Context sensitive rules</a></li><li><a class="tocitem" href="../../more_rules_queries/relationalqueries/">Relational queries</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../howto/GridCloner/">Setting up a grid cloner</a></li><li><a class="tocitem" href="../../../howto/Message/">Messages in scenes</a></li><li><a class="tocitem" href="../../../howto/Materials/">Multiple materials/colors</a></li><li><a class="tocitem" href="../../../howto/Traversal/">Advanced traversal</a></li><li><a class="tocitem" href="../../../howto/Coordinates/">Absolute coordinates</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/graphs/">Graphs</a></li><li><a class="tocitem" href="../../../api/geometry/">Scenes and 3D meshes</a></li><li><a class="tocitem" href="../../../api/turtle/">Turtle geometry</a></li><li><a class="tocitem" href="../../../api/raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../../../api/viz/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">VPLVerse</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">SkyDomes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../VPLVerse/SkyDomes/">SkyDomes package</a></li><li><a class="tocitem" href="../../../VPLVerse/SkyDomes/API/">SkyDomes API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Ecophys</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../VPLVerse/Ecophys/">Ecophys package</a></li><li><a class="tocitem" href="../../../VPLVerse/Ecophys/photosynthesis/">Photosynthesis API</a></li><li><a class="tocitem" href="../../../VPLVerse/Ecophys/growth/">Growth API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">PlantSimEngine</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../VPLVerse/PlantSimEngine/">PlantSimEngine package</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">PlantBioPhysics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../VPLVerse/PlantBioPhysics/">PlantBioPhysics package</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../developers/organization/">Internal organization</a></li><li><a class="tocitem" href="../../../developers/use&amp;dev_packages/">Package and Environment Management for VPL</a></li><li><a class="tocitem" href="../../../developers/style/">Styling protocol</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li><a class="is-disabled">From tree to forest</a></li><li class="is-active"><a href>Forest</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Forest</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/VPLDocs/blob/master/docs/src/tutorials/from_tree_forest/forest.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Forest"><a class="docs-heading-anchor" href="#Forest">Forest</a><a id="Forest-1"></a><a class="docs-heading-anchor-permalink" href="#Forest" title="Permalink"></a></h1><p>Alejandro Morales &amp; Ana Ernst</p><p>Centre for Crop Systems Analysis - Wageningen University</p><blockquote><h2>TL;DR</h2><p>Similar in functionality to <a href="https://virtualplantlab.com/dev/tutorials/from_tree_forest/tree/">Tree</a> tutorial with separate graphs for each tree</p><ul><li>Modify tree parameters for each tree</li><li>Multithreaded simulation (grow trees in parallel)</li><li>Scene customization (e.g., add soil)</li><li>Export Scenes</li></ul></blockquote><p>In this example we extend the tree example into a forest, where each tree is described by a separate graph object and parameters driving the growth of these trees vary across individuals following a predefined distribution. This tutorial requires using the Distributions.jl package:</p><p>The data types, rendering methods and growth rules are the same as in the binary tree example:</p><pre><code class="language-julia hljs">using VirtualPlantLab
using Distributions, Plots, ColorTypes
import GLMakie
# Data types
module TreeTypes
    import VirtualPlantLab
    # Meristem
    struct Meristem &lt;: VirtualPlantLab.Node end
    # Bud
    struct Bud &lt;: VirtualPlantLab.Node end
    # Node
    struct Node &lt;: VirtualPlantLab.Node end
    # BudNode
    struct BudNode &lt;: VirtualPlantLab.Node end
    # Internode (needs to be mutable to allow for changes over time)
    Base.@kwdef mutable struct Internode &lt;: VirtualPlantLab.Node
        length::Float64 = 0.10 # Internodes start at 10 cm
    end
    # Leaf
    Base.@kwdef struct Leaf &lt;: VirtualPlantLab.Node
        length::Float64 = 0.20 # Leaves are 20 cm long
        width::Float64  = 0.1 # Leaves are 10 cm wide
    end
    # Graph-level variables
    Base.@kwdef struct treeparams
        growth::Float64 = 0.1
        budbreak::Float64 = 0.25
        phyllotaxis::Float64 = 140.0
        leaf_angle::Float64 = 30.0
        branch_angle::Float64 = 45.0
    end
end

import .TreeTypes

# Create geometry + color for the internodes
function VirtualPlantLab.feed!(turtle::Turtle, i::TreeTypes.Internode, data)
    # Rotate turtle around the head to implement elliptical phyllotaxis
    rh!(turtle, data.phyllotaxis)
    HollowCylinder!(turtle, length = i.length, height = i.length/15, width = i.length/15,
                move = true, colors = RGB(0.5,0.4,0.0))
    return nothing
end

# Create geometry + color for the leaves
function VirtualPlantLab.feed!(turtle::Turtle, l::TreeTypes.Leaf, data)
    # Rotate turtle around the arm for insertion angle
    ra!(turtle, -data.leaf_angle)
    # Generate the leaf
    Ellipse!(turtle, length = l.length, width = l.width, move = false,
             colors = RGB(0.2,0.6,0.2))
    # Rotate turtle back to original direction
    ra!(turtle, data.leaf_angle)
    return nothing
end

# Insertion angle for the bud nodes
function VirtualPlantLab.feed!(turtle::Turtle, b::TreeTypes.BudNode, data)
    # Rotate turtle around the arm for insertion angle
    ra!(turtle, -data.branch_angle)
end


# Rules
meristem_rule = Rule(TreeTypes.Meristem, rhs = mer -&gt; TreeTypes.Node() +
                                              (TreeTypes.Bud(), TreeTypes.Leaf()) +
                                         TreeTypes.Internode() + TreeTypes.Meristem())

function prob_break(bud)
    # We move to parent node in the branch where the bud was created
    node =  parent(bud)
    # We count the number of internodes between node and the first Meristem
    # moving down the graph
    check, steps = has_descendant(node, condition = n -&gt; data(n) isa TreeTypes.Meristem)
    steps = Int(ceil(steps/2)) # Because it will count both the nodes and the internodes
    # Compute probability of bud break and determine whether it happens
    if check
        prob =  min(1.0, steps*graph_data(bud).budbreak)
        return rand() &lt; prob
    # If there is no meristem, an error happened since the model does not allow
    # for this
    else
        error(&quot;No meristem found in branch&quot;)
    end
end
branch_rule = Rule(TreeTypes.Bud,
            lhs = prob_break,
            rhs = bud -&gt; TreeTypes.BudNode() + TreeTypes.Internode() + TreeTypes.Meristem())</code></pre><p>The main difference with respect to the tree is that several of the parameters will vary per TreeTypes. Also, the location of the tree and initial orientation of the turtle will also vary. To achieve this we need to:</p><p>(i) Add two additional initial nodes that move the turtle to the starting position of each tree and rotates it.</p><p>(ii) Wrap the axiom, rules and the creation of the graph into a function that takes the required parameters as inputs.</p><pre><code class="language-julia hljs">function create_tree(origin, growth, budbreak, orientation)
    axiom = T(origin) + RH(orientation) + TreeTypes.Internode() + TreeTypes.Meristem()
    tree =  Graph(axiom = axiom, rules = (meristem_rule, branch_rule),
                  data = TreeTypes.treeparams(growth = growth, budbreak = budbreak))
    return tree
end</code></pre><p>The code for elongating the internodes to simulate growth remains the same as for the binary tree example</p><pre><code class="language-julia hljs">getInternode = Query(TreeTypes.Internode)

function elongate!(tree, query)
    for x in apply(tree, query)
        x.length = x.length*(1.0 + data(tree).growth)
    end
end

function growth!(tree, query)
    elongate!(tree, query)
    rewrite!(tree)
end

function simulate(tree, query, nsteps)
    new_tree = deepcopy(tree)
    for i in 1:nsteps
        growth!(new_tree, query)
    end
    return new_tree
end</code></pre><p>Let&#39;s simulate a forest of 10 x 10 trees with a distance between (and within) rows of 2 meters. First we generate the original positions of the trees. For the position we just need to pass a <code>Vec</code> object with the x, y, and z coordinates of the location of each TreeTypes. The code below will generate a matrix with the coordinates:</p><pre><code class="language-julia hljs">origins = [Vec(i,j,0) for i = 1:2.0:20.0, j = 1:2.0:20.0]</code></pre><p>We may assume that the initial orientation is uniformly distributed between 0 and 360 degrees:</p><pre><code class="language-julia hljs">orientations = [rand()*360.0 for i = 1:2.0:20.0, j = 1:2.0:20.0]</code></pre><p>For the <code>growth</code> and <code>budbreak</code> parameters we will assumed that they follow a LogNormal and Beta distribution, respectively. We can generate random values from these distributions using the <code>Distributions</code> package. For the relative growth rate:</p><pre><code class="language-julia hljs">growths = rand(LogNormal(-2, 0.3), 10, 10)
histogram(vec(growths))</code></pre><p>And for the budbreak parameter:</p><pre><code class="language-julia hljs">budbreaks = rand(Beta(2.0, 10), 10, 10)
histogram(vec(budbreaks))</code></pre><p>Now we can create our forest by calling the <code>create_tree</code> function we defined earlier with the correct inputs per tree:</p><pre><code class="language-julia hljs">forest = vec(create_tree.(origins, growths, budbreaks, orientations));
nothing #hide</code></pre><p>By vectorizing <code>create_tree()</code> over the different arrays, we end up with an array of trees. Each tree is a different Graph, with its own nodes, rewriting rules and variables. This avoids having to create a large graphs to include all the plants in a simulation. Below we will run a simulation, first using a sequential approach (i.e. using one core) and then using multiple cores in our computers (please check https://docs.julialang.org/en/v1/manual/multi-threading/ if the different cores are not being used as you may need to change some settings in your computer).</p><h2 id="Sequential-simulation"><a class="docs-heading-anchor" href="#Sequential-simulation">Sequential simulation</a><a id="Sequential-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Sequential-simulation" title="Permalink"></a></h2><p>We can simulate the growth of each tree by applying the method <code>simulate</code> to each tree, creating a new version of the forest (the code below is an array comprehension)</p><pre><code class="language-julia hljs">newforest = [simulate(tree, getInternode, 2) for tree in forest];
nothing #hide</code></pre><p>And we can render the forest with the function <code>render</code> as in the binary tree example but passing the whole forest at once</p><pre><code class="language-julia hljs">render(Scene(newforest))</code></pre><p>If we iterate 4 more iterations we will start seeing the different individuals diverging in size due to the differences in growth rates</p><pre><code class="language-julia hljs">newforest = [simulate(tree, getInternode, 15) for tree in newforest];
render(Scene(newforest))</code></pre><h2 id="Multithreaded-simulation"><a class="docs-heading-anchor" href="#Multithreaded-simulation">Multithreaded simulation</a><a id="Multithreaded-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Multithreaded-simulation" title="Permalink"></a></h2><p>In the previous section, the simulation of growth was done sequentially, one tree after another (since the growth of a tree only depends on its own parameters). However, this can also be executed in multiple threads. In this case we use an explicit loop and execute the iterations of the loop in multiple threads using the macro <code>@threads</code>. Note that the rendering function can also be ran in parallel (i.e. the geometry will be generated separately for each plant and the merge together):</p><pre><code class="language-julia hljs">using Base.Threads
newforest = deepcopy(forest)
@threads for i in 1:length(forest)
    newforest[i] = simulate(forest[i], getInternode, 6)
end
render(Scene(newforest, parallel = true))</code></pre><p>An alternative way to perform the simulation is to have an outer loop for each timestep and an internal loop over the different trees. Although this approach is not required for this simple model, most FSP models will probably need such a scheme as growth of each individual plant will depend on competition for resources with neighbouring plants. In this case, this approach would look as follows:</p><pre><code class="language-julia hljs">newforest = deepcopy(forest)
for step in 1:15
    @threads for i in 1:length(newforest)
        newforest[i] = simulate(newforest[i], getInternode, 1)
    end
end
render(Scene(newforest, parallel = true))</code></pre><h1 id="Customizing-the-scene"><a class="docs-heading-anchor" href="#Customizing-the-scene">Customizing the scene</a><a id="Customizing-the-scene-1"></a><a class="docs-heading-anchor-permalink" href="#Customizing-the-scene" title="Permalink"></a></h1><p>Here we are going to customize the scene of our simulation by adding a horizontal tile represting soil and tweaking the 3D representation. When we want to combine plants generated from graphs with any other geometric element it is best to combine all these geometries in a <code>GLScene</code> object. We can start the scene with the <code>newforest</code> generated in the above:</p><pre><code class="language-julia hljs">scene = Scene(newforest);
nothing #hide</code></pre><p>We can create the soil tile directly, without having to create a graph. The simplest approach is two use a special constructor <code>Rectangle</code> where one species a corner of the rectangle and two vectors defining the two sides of the vectors. Both the sides and the corner need to be specified with <code>Vec</code> just like in the above when we determined the origin of each plant. VPL offers some shortcuts: <code>O()</code> returns the origin (<code>Vec(0.0, 0.0, 0.0)</code>), whereas <code>X</code>, <code>Y</code> and <code>Z</code> returns the corresponding axes and you can scale them by passing the desired length as input. Below, a rectangle is created on the XY plane with the origin as a corner and each side being 11 units long:</p><pre><code class="language-julia hljs">soil = Rectangle(length = 21.0, width = 21.0)
rotatey!(soil, pi/2)
VirtualPlantLab.translate!(soil, Vec(0.0, 10.5, 0.0))</code></pre><p>We can now add the <code>soil</code> to the <code>scene</code> object with the <code>add!</code> function.</p><pre><code class="language-julia hljs">VirtualPlantLab.add!(scene, mesh = soil, colors = RGB(1,1,0))</code></pre><p>We can now render the scene that combines the random forest of binary trees and a yellow soil. Notice that in all previous figures, a coordinate system with grids was being depicted. This is helpful for debugging your code but also to help setup the scene (e.g. if you are not sure how big the soil tile should be). Howver, it may be distracting for the visualization. It turns out that we can turn that off with <code>axes = false</code>:</p><pre><code class="language-julia hljs">render(scene, axes = false)</code></pre><p>We may also want to save a screenshot of the scene. For this, we need to store the output of the <code>render</code> function. We can then resize the window rendering the scene, move around, zoom, etc. When we have a perspective that we like, we can run the <code>save_scene</code> function on the object returned from <code>render</code>. The argument <code>resolution</code> can be adjusted in both <code>render</code> to increase the number of pixels in the final image. A helper function <code>calculate_resolution</code> is provided to compute the resolution from a physical width and height in cm and a dpi (e.g., useful for publications and posters):</p><pre><code class="language-julia hljs">res = calculate_resolution(width = 16.0, height = 16.0, dpi = 1_000)
output = render(scene, axes = false, size = res)
export_scene(scene = output, filename = &quot;nice_trees.png&quot;)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tree/">« Tree</a><a class="docs-footer-nextpage" href="../growthforest/">Growth forest »</a><div class="flexbox-break"></div></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 10 September 2024 14:53">Tuesday 10 September 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
