var documenterSearchIndex = {"docs":
[{"location":"VPLVerse/PlantBioPhysics/#PlantBioPhysics","page":"PlantBioPhysics package","title":"PlantBioPhysics","text":"","category":"section"},{"location":"VPLVerse/PlantBioPhysics/","page":"PlantBioPhysics package","title":"PlantBioPhysics package","text":"The documentation for PlantBioPhysics.jl is hosted in its own website.","category":"page"},{"location":"manual/Geometry/Turtle/#manual_turtle","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"","category":"section"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Alejandro Morales","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"<!– Explain the PlantGeomTurtle package –>","category":"page"},{"location":"manual/Geometry/Turtle/#Meshes","page":"Turtle geometry and scenes","title":"Meshes","text":"","category":"section"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"The geometry in VPL consist of 3D triangular meshes. These meshes are used for 3D visualization and for ray tracing, buy may also be exported to external formats or used in other Julia packages. Most of the time, the geometry is generated from graphs using the concept of turtle geometry. In addition to generating the meshes, it will also be necessary to associated colors (for rendering) and material objects (for ray tracing) for each triangle in the mesh. All these components are then stored in a Scene object.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Meshes are collections of vertices, normal vectors and faces (which specify combinations of vertices that form triangles). They are implemented in the object Mesh. All vectors and points are represented by the type Vec. Any vector may be constructed by calling Vec(x, y, z) with the coordinates of the vector.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Meshes can be imported from external formats using the PlantGeomPrimitives.load_mesh() function and exported using the PlantGeomPrimitives.save_mesh() functions. The file formats supported include STL, OBJ and PLY (see documentation on functions for details).","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Meshes are not meant to be modified directly by the user (unless adhoc geometry is needed). Instead, a series of functions are provided to generate meshes associated to different geometries. These functions are called primitive constructors and can be combined to generate more complex geometries. The primitive constructors maybe used to generate geometry procedurally with a turtle (see below), or to create the mesh directly (e.g., when adding geometry to an existing scene).","category":"page"},{"location":"manual/Geometry/Turtle/#Turtle-geometry","page":"Turtle geometry and scenes","title":"Turtle geometry","text":"","category":"section"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"The idea behind turtle geometry is to generate geometry procedurally by imagining a turtle that moves through the scene and is fed triangular meshes. This allows to generate any geometry by defining a sequence of instructions that the turtle will execute. These instructions are defined locally (e.g., turn right, move forward, etc.) and update the turtle position and orientation, such that a global geometry is generated after the instructions are executed.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"The internal state of the turtle is defined by its position and three axis of rotation:","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Position (pos): The location of the turtle in the scene.\nHeading (head): The direction in which the turtle is heading. Moving forward","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"would mean moving along this direction. A rotation around the head vector is called a roll (imagine a turtle spinning on its head).","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Arm (arm): A direction perpendicular to head but on the same plane. A","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"rotation around the arm vector is called a pitch (imagine a turtle turning up or down).","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Up (up): A direction perpendicular to the plane of the turtle. A rotation","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"around the up vector is called a yaw (imagine a turtle turning left or right).","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"To generate geometry, that matches the morphology of a plant, the turtle in VPL is fed a graph. This means that the first instructions to the turtle will be given by the first node in the graph. The turtle will then traverse the entire graph, resetting its state at each branching point in the graph. The instructions to the turtle are given by methods of the feed!() function, defined for all the possible nodes in graph.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Two types of instructions are available to the turtle: movement operators and primitive constructors. The former are used to change the internal state of the turtle without adding geometry to the scene, while the latter generate a 3D mesh associated to a particular geometry (a special primitive constructor Mesh! accepts any mesh generated by the user). The different movement operators are given below, while the primitive constructors are given here.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"In addition, the turtle will contain a message field that can be assigned any user-defined value. This is useful to pass information to feed!() methods described below (e.g., to control the code executed by those methods). All the methods that create an internal turtle (e.g., Scene or render) will accept an optional message argument that will be passed on to the turtle.","category":"page"},{"location":"manual/Geometry/Turtle/#Movement-operators","page":"Turtle geometry and scenes","title":"Movement operators","text":"","category":"section"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Movement operators as provided as functions that manipulate the state of the turtle in-place (e.g. ra!), as well as nodes that can be used inside a Graph object (e.g., RA). The functional version will be in lowercase, while the node version will be in uppercase. The functional version can be used inside any feed!() method, which reduces the number of nodes that need to be inserted into a graph.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Below are all the movement operators available in VPL (in their node form):","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"PlantGeomTurtle.T: Move the turtle to a new absolute position.\nPlantGeomTurtle.RA: Rotate the turtle around thearm axis.\nPlantGeomTurtle.RH: Rotate the turtle around the head axis.\nPlantGeomTurtle.RU: Rotate the turtle around the up axis.\nPlantGeomTurtle.OR: Orient the turtle in a new direction by explicitly changing","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"the head, arm and up vectors.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"PlantGeomTurtle.F: Move the turtle forward.\nPlantGeomTurtle.SET: Completely change the state of the turtle by setting the","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"pos, head, arm and up vectors.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"PlantGeomTurtle.RV: A special rotation that emulates gravitropism (it rotates","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"the turtle towards the Z axis of the scene).","category":"page"},{"location":"manual/Geometry/Turtle/#Scenes","page":"Turtle geometry and scenes","title":"Scenes","text":"","category":"section"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"A Scene object contains three elements that are connected:","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"A triangular mesh (a Mesh object) that contains all the geometry of the","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"scene.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"The colors associated to each triangle in the mesh (objects that inherit from","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Colorant from the ColorTypes.jl package). This is needed for 3D rendering.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"The Material objects that defined the optical properties of each triangle.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"This is needed for ray tracing of radiation.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Only the first element is required to create a scene. The other two are optional and are only necessary if you want to render the scene or perform ray tracing on the scene.","category":"page"},{"location":"manual/Geometry/Turtle/#Creating-a-scene","page":"Turtle geometry and scenes","title":"Creating a scene","text":"","category":"section"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"The simplest way to create a scene is to use the Scene constructor on a Graph object or a vector of Graph objects. This will create internally a Turtle which then generates the geometry, colors and materials of the scene via the feed!() methods defined by the user. VPL will take care of ensuring that triangles are connected to their corresponding colors and material objects.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"A scene may also be created internally by render() when applied to a Graph object or a vector of Graph objects. However, this scene cannot be retrieved so it is not possible to modify it or reuse it for ray tracing. The ray tracer will not create a scene internally, so for that purpose the user will need to create the scene explicitly.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"It is possible to add elements to an existing scene using the add!() method which allows to add a mesh to the scene (and optionally the corresponding colors and/or materials).","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Multiple scenes can also be merged into a single one by calling Scene() on a vector of Scene objects. This allows for parallel construction of scenes which are then merged together.","category":"page"},{"location":"manual/Geometry/Turtle/#The-feed!()-method","page":"Turtle geometry and scenes","title":"The feed!() method","text":"","category":"section"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"In order to use the turtle to generate a scene from a graph, the user will need to define a feed!() method for each type of node stored in the graph (at least the ones that require geometry). This method will be called by the turtle when it encounters a node of that type. When no method is present, the turtle will simply move to the next node in the graph.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"The feed!() method takes three arguments: the Turtle, the node and the graph- level variables (of the graph the node belongs to). The latter does not have to be used, but it may be useful if information at the plant level is required to generate geometry, colors or material objects (most often the information is stored inside the node itself). It is important that the second argument (the node) is annotated by its type and that the PlantGeomTurtle prefix is used to ensure that a method is created. For example, for a node of type Internode the function should be defined as:","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"function PlantGeomTurtle.feed!(t::Turtle, n::Internode, vars)\n    <code here>\nend","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"Inside the feed!() method, the user can apply any of the movement operators described in the previous section as well as the turtle-specific primitive constructors (see section on Primitives). All these changes will be applied to the turtle's internal state. The feed!() method should not return anything.","category":"page"},{"location":"manual/Geometry/Turtle/","page":"Turtle geometry and scenes","title":"Turtle geometry and scenes","text":"It is also possible to execute different code inside the feed!() method based on the message stored in the turtle. This allows for example to generate different geometries for visualizations and ray tracing, or to use different colors for visualization. Since the message can be any object created by the user, it may also be used to pass information to the feed!() method, though most often the relevant information is stored in the node or graph.","category":"page"},{"location":"api/viz/#D-visualization","page":"3D visualization","title":"3D visualization","text":"","category":"section"},{"location":"api/viz/","page":"3D visualization","title":"3D visualization","text":"CurrentModule = PlantViz","category":"page"},{"location":"api/viz/#Public-API","page":"3D visualization","title":"Public API","text":"","category":"section"},{"location":"api/viz/","page":"3D visualization","title":"3D visualization","text":"Modules = [PlantViz]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/viz/#PlantViz.export_scene-Tuple{}","page":"3D visualization","title":"PlantViz.export_scene","text":"export_scene(;scene, filename, kwargs...)\n\nExport a screenshot of the current visualization (stored as scene as output of a call to render) as a PNG file store in the path given by filename (including .png extension). Keyword arguments will be passed along to the corresponding save method from Makie (see VPL documentation for details).\n\n\n\n\n\n","category":"method"},{"location":"api/viz/#PlantViz.render!-Tuple{PlantGeomPrimitives.Mesh}","page":"3D visualization","title":"PlantViz.render!","text":"render!(m::Mesh; kwargs...)\n\nAdd a mesh to the visualization currently active. This will create a new visualization (see Documentation for details). Keyword arguments are passed to the render!(scene::Scene) method and any unmatched keywords will be passed along to Makie.mesh!().\n\n\n\n\n\n","category":"method"},{"location":"api/viz/#PlantViz.render!-Tuple{PlantRayTracer.GridCloner}","page":"3D visualization","title":"PlantViz.render!","text":"render!(grid::GridCloner; alpha = 0.2)\n\nAdd a mesh representing the bounding boxes of the grid cloner to a 3D scene, where alpha represents the transparency of each box.\n\n\n\n\n\n","category":"method"},{"location":"api/viz/#PlantViz.render!-Union{Tuple{Array{PlantRayTracer.Source{G, A, nw}, 1}}, Tuple{nw}, Tuple{A}, Tuple{G}} where {G<:PlantRayTracer.Directional, A<:PlantRayTracer.FixedSource, nw}","page":"3D visualization","title":"PlantViz.render!","text":"render!(source::Source{G, A, nw}; n = 20, alpha = 0.2, point = false,\n        scale = 0.2)\n\nAdd a mesh representing the light source to a 3D scene (if point = false) or a series of points representing the center of the light sources (if point = true). When point = false, for each type of light source a triangular mesh will be created, where n is the number of triangles (see documentation of geometric primitives for details) and alpha is the transparency to be used for each triangle. When point = true, only the center of the light source is rendered along with the normal vector at that point (representative of the direction at which rays are generated). In the current version, point = true is only possible for directional light sources.\n\n\n\n\n\n","category":"method"},{"location":"api/viz/#PlantViz.render-Tuple{PlantGeomPrimitives.Mesh}","page":"3D visualization","title":"PlantViz.render","text":"render(m::Mesh; kwargs...)\n\nRender a mesh. This will create a new visualization (see Documentation for details). Keyword arguments are passed to the render(scene::Scene) method and any unmatched keywords will be passed along to Makie.mesh().\n\n\n\n\n\n","category":"method"},{"location":"api/viz/#PlantViz.render-Tuple{PlantGeomPrimitives.Scene}","page":"3D visualization","title":"PlantViz.render","text":"render(scene::Scene; normals::Bool = false, wireframe::Bool = false, kwargs...)\n\nRender a Scene object. This will create a new visualization (see Documentation for details). normals = true will draw arrows in the direction of the normal vector for each triangle in the mesh, wireframe = true will draw the edges of each triangle with black lines. Keyword arguments are passed to Makie.mesh().\n\n\n\n\n\n","category":"method"},{"location":"api/viz/#Private","page":"3D visualization","title":"Private","text":"","category":"section"},{"location":"api/viz/","page":"3D visualization","title":"3D visualization","text":"Private functions, types or constants from PlantViz. These are not exported, so you need to prefix the function name with PlantGeomPrimitives. to access them. Also bear in mind that these are not part of the public API, so they may change without notice.","category":"page"},{"location":"api/viz/","page":"3D visualization","title":"3D visualization","text":"Modules = [PlantViz]\nPublic = false\nPrivate = true","category":"page"},{"location":"howto/GridCloner/#How-to-setup-a-grid-cloner","page":"Setting up a grid cloner","title":"How to setup a grid cloner","text":"","category":"section"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"In many FSP models, users want to simulate a large field of plants, but it is not computationally feasible to do so. Instead, a reduced number of representative plants in a plot are simulated. However, this can introduce border effects when simulating plant-environment interactions (for example when computing light interception). The goal of the grid cloner is to reduce this border effect when computing light interception by cloning the entire 3D scene along the different axes by a distance specified by the user (in each direction).","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"The grid cloner is implemented using object instancing from ray tracing. This approach will affect the position of the ray as if it was intersecting a cloned scene adjacent to the original one, thus still reusing the original mesh. For example, if the scene is replicated along the x-axis at a distance of 1, the ray will be translated a distance of -1 along the x-axis to check for intersections with that clone. Thus, no extra memory is required to store the clones.","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"Conceptually, this grid cloner is similar to using periodic boundaries on the sides of the bounding box of the scene. The main differences are that (i) the grid cloner only allows a finite number of clones (periodic boundaries could be, in theory, infinite) and (ii) the bounding boxes of clones may overlap. The latter feature accounts for the fact that the root and shoot systems of plants may overlap in the field.","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"In the most common scenario, the user is simulating a field of plants with a regular spacing between plants (e.g., defined by distance between rows and within rows). In this case, the recommended way to create the grid cloner is as follows:","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"The clones should be created at multiples of these distances.\nThe rows should be aligned with the x- or y-axis.\nSoil and sensor tiles should not extend more than half the distance between or within rows along each axis.","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"In this canonical setup, the clones will overlap if the shoot or root systems of the border plants extend beyond the midpoint between or within rows, but the soil/sensor tiles will not overlap. The latter is important as otherwise calculations of light interception by such tiles will be incorrect.","category":"page"},{"location":"howto/GridCloner/#Example","page":"Setting up a grid cloner","title":"Example","text":"","category":"section"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"Load the dependencies","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"using VirtualPlantLab\nimport ColorTypes: RGB\nimport GLMakie","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"A plant will be represented by a simple cylinder located at different points in a grid. We create the grid given the recommendations in the above. Using this template ensures that the scene has the proper dimensions while still scaling with the number of plants and rows:","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"dx = 2.0\ndy = 0.5\nnrows = 10\nnplants = 10\norigins = [Vec(i,j,0) for i = dx/2:dx:(nrows - 0.5)dx, j = dy/2:dy:(nplants - 0.5)dy];","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"We create a simple plant placeholder defined by a stem and a single long leaf:","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"struct Plant <: Node end\nfunction VirtualPlantLab.feed!(turtle::Turtle, plant::Plant, data)\n    HollowCylinder!(turtle, move = true, color = RGB(0.63, 0.63, 0.63), length = 2.0,\n                    width = 0.25, height = 0.25)\n    rh!(turtle, rand()*360.0)\n    ra!(turtle, rand()*90.0)\n    Rectangle!(turtle, color = RGB(0.0, 1.0, 0.0), length = 3.0, width = 0.2)\n    return nothing\nend\naxiom(origin) = T(origin) + Plant()\nplants = [Graph(axiom = axiom(origin)) for origin in origins];","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"We will also add several soil tiles to the scene. Each tile will correspond to a single plant and thus represent the spacing allocated to each plant given the planting pattern. We will not use a graph for these tiles but rather create them manually using available primitives and transformations (note how we shift the tile along the x axis to center it on the plant!):","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"function create_tile(p, dx, dy)\n    tile = Rectangle(length = dx, width = dy)\n    rotatey!(tile, pi/2)\n    VirtualPlantLab.translate!(tile, p .+ Vec(-dx/2, 0.0, 0.0))\n    return tile\nend\ntiles = vec([create_tile(origin, dx, dy) for origin in origins]);","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"Now we can combine the plants and tiles into a single scene. We randomize the color of each tile to help identify them in the visualization:","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"plant_scene = Scene(vec(plants));\nsoil_scene = Scene()\nfor tile in tiles\n    add!(soil_scene, mesh = tile, color = RGB(rand(), rand(), rand()))\nend\nscene = Scene([plant_scene, soil_scene]);\nrender(scene)","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"We can also visualize the bounding boxes of a scene (and any clone). If we just want the box for the original scene, we can create a grid with no clones. The build the acceleration object (which includes the grid cloner) and add it to the 3D rendering:","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"rt_settings = RTSettings(nx = 0, ny = 0)\nacc_one = accelerate(scene, settings = rt_settings);\nrender(scene)\nrender!(acc_one.grid)","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"We can see that bounding box extends to the tips of the leaves, as they grow beyond the soil area allocated to the plant. If we now create multiple clones of this scene, we should displace them by a distance of 10dx along the x-axis and 10dy along the y-axis. This will ensure that the soil tiles of clones do not overlap but the plants will. In other words, we emulate additional rows and plants within rows while respecting the same spacing between them:","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"rt_settings = RTSettings(nx = 1, ny = 1, dx = 10dx, dy = 10dy)\nacc = accelerate(scene, settings = rt_settings);","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"We can now add all the bounding boxes of the clones to the scene:","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"render(scene)\nrender!(acc.grid)","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"We can see that the bounding boxes of the clones overlap, as expected. Currently there is no way in VPL to visualize the actual clones (since that additional geometry is never actually generated, see details about instancing above). We can do this manually by manually changing the meshes of the scene using the method VirtualPlantLab.translate!. We add the bounding box of the original scene too:","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"scenes = Scene[]\nfor i in -10:10\n    for j in -10:10\n        new_scene = deepcopy(scene)\n        VirtualPlantLab.translate!(new_scene.mesh, Vec(i*10dx, j*10dy, 0.0))\n        push!(scenes, new_scene)\n    end\nend\nrender(Scene(scenes), axes = false)\nrender!(acc_one.grid, alpha = 0.8)","category":"page"},{"location":"howto/GridCloner/","page":"Setting up a grid cloner","title":"Setting up a grid cloner","text":"Because of the random color scheme, we can visually check that the soil tiles do not overlap and that the distance within and between rows is respected across clones. Effectively, this is a visualization of what the ray tracer \"sees\" in the simulations. Effectively, each plant in the original scene is cloned multiple times and the absorbed power from all these clones is aggregated. However, the light sources are not being duplicated, those are still defined by the original scene (which is located in the center of the grid).","category":"page"},{"location":"tutorials/relationalqueries/#Relational-queries","page":"Relational queries","title":"Relational queries","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"Alejandro Morales","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"In this example we illustrate how to test relationships among nodes inside queries. Relational queries allow to establish relationships between nodes in the graph, which generally requires a intimiate knowledge of the graph. For this reason, relational queries are inheretly complex as graphs can become complex and there may be solutions that do not require relational queries in many instances. Nevertheless, they are integral part of VPL and can sometimes be useful. As they can be hard to grasp, this tutorial will illustrate with a relatively simple graph a series of relational queries with increasing complexity with the aim that users will get a better understanding of relational queries. For this purpose, an abstract graph with several branching levels will be used, so that we can focus on the relations among the nodes without being distracted by case-specific details.","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"The graph will be composed of two types of nodes: the inner nodes (A and C) and the leaf nodes (B). Each leaf node will be identified uniquely with an index and the objective is to write queries that can identify a specific subset of the leaf nodes, without using the data stored in the nodes themselves. That is, the queries should select the right nodes based on their relationships to the rest of nodes in the graph. Note that C nodes contain a single value that may be positive or negative, whereas A nodes contain no data.","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"As usual, we start with defining the types of nodes in the graph","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"using VirtualPlantLab\nimport GLMakie\n\nmodule Queries\n    using VirtualPlantLab\n    struct A <: Node end\n\n    struct C <: Node\n        val::Float64\n    end\n\n    struct B <: Node\n        ID::Int\n    end\nend\nimport .Queries as Q","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"We generate the graph directly, rather than with rewriting rules. The graph has a motif that is repeated three times (with a small variation), so we can create the graph in a piecewise manner. Note how we can use the function sum to add nodes to the graph (i.e. sum(A() for i in 1:3) is equivalent to A() + A() + A())","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"motif(n, i = 0) = Q.A() + (Q.C(45.0) + Q.A() + (Q.C(45.0) +  Q.A() + Q.B(i + 1),\n                                           Q.C(-45.0) + Q.A() + Q.B(i + 2),\n                                                       Q.A() + Q.B(i + 3)),\n                         Q.C(- 45.0) + sum(Q.A() for i in 1:n) + Q.B(i + 4))\naxiom =  motif(3, 0) + motif(2, 4) + motif(1, 8) + Q.A() + Q.A() + Q.B(13)\ngraph = Graph(axiom = axiom);\ndraw(graph)","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"By default, VPL will use as node label the type of node and the internal ID generated by VPL itself. This ID is useful if we want to extract a particular node from the graph, but it is not controlled by the user. However, the user can specialized the function node_label() to specify exactly how to label the nodes of a particular type. In this case, we want to just print A or C for nodes of type A and C, whereas for nodes of type B we want to use the ID field that was stored inside the node during the graph generation.","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"VirtualPlantLab.node_label(n::Q.B, id) = \"B-$(n.ID)\"\nVirtualPlantLab.node_label(n::Q.A, id) = \"A\"\nVirtualPlantLab.node_label(n::Q.C, id) = \"C\"\ndraw(graph)","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"To clarify, the id argument of the function node_label() refers to the internal id generated by VPL (used by the default method for node_label(), whereas the the first argument is the data stored inside a node (in the case of B nodes, there is a field called ID that will not be modified by VPL as that is user-provided data).","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"The goal of this exercise is then to write queries that retrieve specific B nodes  without using the data stored in the node in the query. That is, we have to identify nodes based on their relationships to other nodes.","category":"page"},{"location":"tutorials/relationalqueries/#All-nodes-of-type-B","page":"Relational queries","title":"All nodes of type B","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"First, we create the query object. In this case, there is no special condition as we want to retrieve all the nodes of type B","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"Q1 = Query(Q.B)","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"Applying the query to the graph returns an array with all the B nodes","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"A1 = apply(graph, Q1)","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"For the remainder of this tutorial, the code will be hidden by default to allow users to try on their own.","category":"page"},{"location":"tutorials/relationalqueries/#Node-containing-value-13","page":"Relational queries","title":"Node containing value 13","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"Since the B node 13 is the leaf node of the main branch of the graph (e.g. this could be the apical meristem of the main stem of a plant), there are no rotations between the root node of the graph and this node. Therefore, the only condition require to single out this node is that it has no ancestor node of type C.","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"Checking whether a node has an ancestor that meets a certain condition can be achieved with the function hasAncestor(). Similarly to the condition of the Query object, the hasAncestor() function also has a condition, in this case applied to the parent node of the node being tested, and moving upwards in the graph recursively (until reaching the root node). Note that, in order to access the object stored inside the node, we need to use the data() function, and then we can test if that object is of type C. The B node 13 is the only node for which hasAncestor() should return false:","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"function Q2_fun(n)\n    check, steps = has_ancestor(n, condition = x -> data(x) isa Q.C)\n    !check\nend","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"As before, we just need to apply the Query object to the graph:","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"Q2 = Query(Q.B, condition = Q2_fun)\nA2 = apply(graph, Q2)","category":"page"},{"location":"tutorials/relationalqueries/#Nodes-containing-values-1,-2-and-3","page":"Relational queries","title":"Nodes containing values 1, 2 and 3","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"These three nodes belong to one of the branch motifs repeated through the graph. Thus, we need to identify the specific motif they belong to and chose all the B nodes inside that motif. The motif is defined by an A node that has a C child with a negative val and parent node C with positive val. This A node should then be 2 nodes away from the root node to separate it from upper repetitions of the motif. Therefore, we need to test for two conditions, first find those nodes inside a branch motif, then retrieve the root of the branch motif (i.e., the A node described in the above) and then check the distance of that node from the root:","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"function branch_motif(p)\n    data(p) isa Q.A &&\n    has_descendant(p, condition = x -> data(x) isa Q.C && data(x).val < 0.0)[1] &&\n    has_ancestor(p, condition = x -> data(x) isa Q.C && data(x).val > 0.0)[1]\nend\n\nfunction Q3_fun(n, nsteps)\n    # Condition 1\n    check, steps = has_ancestor(n, condition = branch_motif)\n    !check && return false\n    # Condition 2\n    p = parent(n, nsteps = steps)\n    check, steps = has_ancestor(p, condition = is_root)\n    steps != nsteps && return false\n    return true\nend","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"And applying the query to the object results in the required nodes:","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"Q3 = Query(Q.B, condition = n -> Q3_fun(n, 2))\nA3 = apply(graph, Q3)","category":"page"},{"location":"tutorials/relationalqueries/#Node-containing-value-4","page":"Relational queries","title":"Node containing value 4","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"The node B with value 4 can be singled-out because there is no branching point between the root node and this node. This means that no ancestor node should have more than one children node except the root node. Remember that hasAncestor() returns two values, but we are only interested in the first value. You do not need to assign the returned object from a Julia function, you can just index directly the element to be selected from the returned tuple:","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"function Q4_fun(n)\n    !has_ancestor(n, condition = x -> is_root(x) && length(children(x)) > 1)[1]\nend","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"And applying the query to the object results in the required node:","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"Q4 = Query(Q.B, condition = Q4_fun)\nA4 = apply(graph, Q4)","category":"page"},{"location":"tutorials/relationalqueries/#Node-containing-value-3","page":"Relational queries","title":"Node containing value 3","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"This node is the only B node that is four steps from the root node, which we can retrieve from the second argument returned by hasAncestor():","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"function Q5_fun(n)\n    check, steps = has_ancestor(n, condition = is_root)\n    steps == 4\nend\n\nQ5 = Query(Q.B, condition = Q5_fun)\nA5 = apply(graph, Q5)","category":"page"},{"location":"tutorials/relationalqueries/#Node-containing-value-7","page":"Relational queries","title":"Node containing value 7","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"Node B 7 belongs to the second lateral branch motif and the second parent node is of type A. Note that we can reuse the Q3_fun from before in the condition required for this node:","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"function Q6_fun(n, nA)\n    check = Q3_fun(n, nA)\n    !check && return false\n    p2 = parent(n, nsteps = 2)\n    data(p2) isa Q.A\nend\n\nQ6 = Query(Q.B, condition = n -> Q6_fun(n, 3))\nA6 = apply(graph, Q6)","category":"page"},{"location":"tutorials/relationalqueries/#Nodes-containing-values-11-and-13","page":"Relational queries","title":"Nodes containing values 11 and 13","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"The B nodes 11 and 13 actually have different relationships to the rest of the graph, so we just need to define two different condition functions and combine them. The condition for the B node 11 is similar to the B node 7, whereas the condition for node 13 was already constructed before, so we just need to combined them with an OR operator:","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"Q7 = Query(Q.B, condition = n -> Q6_fun(n, 4) || Q2_fun(n))\nA7 = apply(graph, Q7)","category":"page"},{"location":"tutorials/relationalqueries/#Nodes-containing-values-1,-5-and-9","page":"Relational queries","title":"Nodes containing values 1, 5 and 9","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"These nodes play the same role in the three lateral branch motifs. They are the only B nodes preceded by the sequence A C+ A. We just need to check the sequence og types of objects for the the first three parents of each B node:","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"function Q8_fun(n)\n    p1 = parent(n)\n    p2 = parent(n, nsteps = 2)\n    p3 = parent(n, nsteps = 3)\n    data(p1) isa Q.A && data(p2) isa Q.C && data(p2).val > 0.0 && data(p3) isa Q.A\nend\n\nQ8 = Query(Q.B, condition = Q8_fun)\nA8 = apply(graph, Q8)","category":"page"},{"location":"tutorials/relationalqueries/#Nodes-contaning-values-2,-6-and-10","page":"Relational queries","title":"Nodes contaning values 2, 6 and 10","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"This exercise is similar to the previous one, but the C node has a negative val. The problem is that node 12 would also match the pattern A C- A. We can differentiate between this node and the rest by checking for a fourth ancestor node of class C:","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"function Q9_fun(n)\n    p1 = parent(n)\n    p2 = parent(n, nsteps = 2)\n    p3 = parent(n, nsteps = 3)\n    p4 = parent(n, nsteps = 4)\n    data(p1) isa Q.A && data(p2) isa Q.C && data(p2).val < 0.0 &&\n       data(p3) isa Q.A && data(p4) isa Q.C\nend\n\nQ9 = Query(Q.B, condition = Q9_fun)\nA9 = apply(graph, Q9)","category":"page"},{"location":"tutorials/relationalqueries/#Nodes-containg-values-6,-7-and-8","page":"Relational queries","title":"Nodes containg values 6, 7 and 8","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"We already came up with a condition to extract node 7. We can also modify the previous condition so that it only node 6.  Node 8 can be identified by checking for the third parent node being of type C and being 5 nodes from the root of the graph.","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"As always, we can reusing previous conditions since they are just regular Julia functions:","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"function Q10_fun(n)\n    Q6_fun(n, 3) && return true ## Check node 7\n    Q9_fun(n) && has_ancestor(n, condition = is_root)[2] == 6 && return true ## Check node 6\n    has_ancestor(n, condition = is_root)[2] == 5 && data(parent(n, nsteps = 3)) isa Q.C && return true ## Check node 8 (and not 4!)\nend\n\nQ10 = Query(Q.B, condition = Q10_fun)\nA10 = apply(graph, Q10)","category":"page"},{"location":"tutorials/relationalqueries/#Nodes-containig-values-3,-7,-11-and-12","page":"Relational queries","title":"Nodes containig values 3, 7, 11 and 12","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"We already have conditions to select nodes 3, 7 and 11 so we just need a new condition for node 12 (similar to the condition for 8).","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"function Q11_fun(n)\n    Q5_fun(n) && return true ## 3\n    Q6_fun(n, 3) && return true ## 7\n    Q6_fun(n, 4) && return true ## 11\n    has_ancestor(n, condition = is_root)[2] == 5 && data(parent(n, nsteps = 2)) isa Q.C &&\n        data(parent(n, nsteps = 4)) isa Q.A && return true ## 12\nend\n\nQ11 = Query(Q.B, condition = Q11_fun)\nA11 = apply(graph, Q11)","category":"page"},{"location":"tutorials/relationalqueries/#Nodes-containing-values-7-and-12","page":"Relational queries","title":"Nodes containing values 7 and 12","text":"","category":"section"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"We just need to combine the conditions for the nodes 7 and 12","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"function Q12_fun(n)\n    Q6_fun(n, 3) && return true # 7\n    has_ancestor(n, condition = is_root)[2] == 5 && data(parent(n, nsteps = 2)) isa Q.C &&\n        data(parent(n, nsteps = 4)) isa Q.A && return true ## 12\nend\n\nQ12 = Query(Q.B, condition = Q12_fun)\nA12 = apply(graph, Q12)","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"","category":"page"},{"location":"tutorials/relationalqueries/","page":"Relational queries","title":"Relational queries","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/raytracer/#Raytracer","page":"Ray tracing","title":"Raytracer","text":"","category":"section"},{"location":"api/raytracer/","page":"Ray tracing","title":"Ray tracing","text":"CurrentModule = PlantRayTracer","category":"page"},{"location":"api/raytracer/#Public-API","page":"Ray tracing","title":"Public API","text":"","category":"section"},{"location":"api/raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Modules = [PlantRayTracer]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/raytracer/#PlantRayTracer.AreaSource-Tuple{PlantGeomPrimitives.Mesh}","page":"Ray tracing","title":"PlantRayTracer.AreaSource","text":"AreaSource(mesh)\n\nCreate an area irradiance source geometry given a triangular mesh.\n\nExamples\n\njulia> using PlantGeomPrimitives\n\njulia> e = Ellipse();\n\njulia> source_geom = AreaSource(e);\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.AvgSplit","page":"Ray tracing","title":"PlantRayTracer.AvgSplit","text":"AvgSplit(minN, maxL)\n\nRule to be used in RayTracer when acceleration = BVH. It will divide each node along the longest axis through the mean coordinate value. The rule is parameterized by the minimum number of triangles in a leaf node (minN) and the maximum depth of the tree (maxL).\n\nExamples\n\njulia> rule = AvgSplit(1,5);\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.BVH","page":"Ray tracing","title":"PlantRayTracer.BVH","text":"BVH(gbox, nodes, tris, ids)\n\nConstruct a Bounding Volume Hierarchy around the triangular meshes to accelerate the ray tracer. This should be assigned to the argument acceleration in the RayTracer function, in combination with a corresponding rule.\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.Black","page":"Ray tracing","title":"PlantRayTracer.Black","text":"Black(nw::Int)\n\nCreate a black material object to store power for nw wavelengths. See VPL documentation for details.\n\nExamples\n\njulia> b = Black(1);\n\njulia> b = Black(3);\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.FixedSource","page":"Ray tracing","title":"PlantRayTracer.FixedSource","text":"FixedSource(dir)\nFixedSource(θ, Φ)\n\nCreate a fixed irradiance source by given a vector with the direction of the rays (dir) or zenith (θ) and azimuth (Φ) angles.\n\nExamples\n\njulia> source_dir = FixedSource(0.0, 0.0);\n\njulia> import PlantGeomPrimitives as PG\n\njulia> source_dir = FixedSource(PG.Vec(0.0, 0.0, -1.0));\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.Lambertian-Tuple{}","page":"Ray tracing","title":"PlantRayTracer.Lambertian","text":"Lambertian(;τ = 0.0, ρ = 0.0)\n\nCreate a Lambertian material object from the values of transmittance (τ) and reflectance (ρ). When more than one wavelength is being simulated, a tuple of values should be passed for each optical property (as in τ = (0.1,0.2)).\n\nExamples\n\njulia> l = Lambertian(τ = 0.1, ρ = 0.2);\n\njulia> l = Lambertian(τ = (0.1, 0.45), ρ = (0.2, 0.45));\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.LambertianSource","page":"Ray tracing","title":"PlantRayTracer.LambertianSource","text":"LambertianSource(x, y, z)\nLambertianSource(axes)\n\nCreate a Lambertian irradiance source angle by given a local coordinate system as three separate Vec objects representing the axes (x, y, z) or as tuple containing the three axes. Rays will be generated towards the hemisphere defined by the z direction. See VPL documentation for details on irradiance sources.\n\nExamples\n\njulia> import PlantGeomPrimitives as PG\n\njulia> source_dir = LambertianSource(PG.X(), PG.Y(), PG.Z());\n\njulia> source_dir = LambertianSource((PG.X(), PG.Y(), PG.Z()));\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.LineSource","page":"Ray tracing","title":"PlantRayTracer.LineSource","text":"LineSource(p, line)\n\nCreate a line irradiance source geometry given an origin (p) and a segment (line) both specified as vector of Cartesian coordinates (Vec(x, y, z)). This will create a line source between the points p and p .+ line.\n\nExamples\n\njulia> import PlantGeomPrimitives as PG\n\njulia> source_geom = LineSource(PG.Vec(1.0, 1.0, 1.0), PG.Y());\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.Naive","page":"Ray tracing","title":"PlantRayTracer.Naive","text":"Naive(tris::Vector{Triangle{FT}}, ids::Vector{Int}, rule) where {FT}\n\nWrap the scene into a global bounding box (no acceleration), given the triangles in a scene, the ids linking each triangle to the corresponding material objects. The argument rule is left for compatibility with BVH, it does not do anything.\n\nExamples\n\njulia> using PlantGeomPrimitives\n\njulia> tris = PlantRayTracer.Triangle(Ellipse());\n\njulia> ids  = repeat([1], length(tris));\n\njulia> Naive(tris, ids);\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.Naive-2","page":"Ray tracing","title":"PlantRayTracer.Naive","text":"Naive\n\nAllow to run the ray tracer without an acceleration structure. This should be assigned to the argument acceleration in the RayTracer function.\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.Phong-Tuple{}","page":"Ray tracing","title":"PlantRayTracer.Phong","text":"Phong(;τ = 0.0, ρd = 0.0, ρsmax = 0.0, n = 2)\n\nCreate a Phong material object from the values of transmittance (τ) diffuse reflectance (ρd), maximum Phong specular reflectance (ρsmax) and n is the specular exponent that controls the \"Phong reflectance lobe\". When more than one wavelength is being simulated, a tuple of values should be passed for each optical property (as in τ = (0.1, 0.3)).\n\nExamples\n\njulia> p = Phong(τ = 0.1, ρd = 0.2, ρsmax = 0.5);\n\njulia> p = Phong(τ = (0.1, 0.45), ρd = (0.2, 0.45), ρsmax = (0.5, 0.5));\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.PointSource","page":"Ray tracing","title":"PlantRayTracer.PointSource","text":"PointSource(vec)\n\nCreate a point irradiance source geometry at given 3D location vec, defined as vector of Cartesian coordinates (Vec(x, y, z)).\n\nExamples\n\njulia> import PlantGeomPrimitives as PG\n\njulia> source_geom = PointSource(PG.Vec(1.0, 1.0, 1.0));\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.RTSettings","page":"Ray tracing","title":"PlantRayTracer.RTSettings","text":"RTSettings(;parallel = false, pkill = 0.2, maxiter = 2, sampler = Random.Xoshiro(123456789),\n            nx = 3, ny = 3, nz = 0, dx = 0.0, dy = 0.0, dz = 0.0)\n\nSettings for the ray tracer: parallel indicates if the raytracer will run on a single core or make use of multiple cores in the machine based on Julia's multithreading support. pkill is the probably that a ray is terminated by the Russian roulette after it has been scattered a maxiter number of times. sampler is the pseudo-random number generator to be used by the ray tracer. nx and ny are the number of times the scene will be clone by the grid cloner in each direction along the x and y axis (e.g., setting nx = 1 and ny = 1 will generate a grid of 3 x 3 clones of the original scene), whereas dx and dy will be distance at which each new clone will be generated (along the axis). nz is the number of times the scene will be cloned in the vertical direction. Unlike horizontal cloning, the vertical cloning is always done in the positive direction of z axis and the number of clones will be exactly nz. See VPL documentation for more details on the ray  tracer.\n\nExamples\n\njulia> RTSettings(parallel = true, maxiter = 3);\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.RayTracer","page":"Ray tracing","title":"PlantRayTracer.RayTracer","text":"RayTracer(scene, materials, sources, settings)\n\nCreate a ray tracer object from an acceleration structure built around a 3D mesh, a grid cloner structure around the acceleration structure (scene), a vector of materials associated to the mesh (materials), a vector of sources of irradiance (sources) and settings. (as generated by RTSettings()). See VPL documentation for more details on the ray tracer.\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.RayTracer-Tuple{PlantGeomPrimitives.Scene, Any}","page":"Ray tracing","title":"PlantRayTracer.RayTracer","text":"RayTracer(scene, sources; settings = RTSettings(), acceleration = Naive, rule = nothing)\n\nCreate a RayTracer object from a scene (as generated by Scene), a tuple of sources (objects that inherit from Source), or a single source, settings and acceleration function (choose from Naive or  BVH). The argument rule is only required for the accelerator BVH and it must be an object of type SAH or AvgSplit (it is ignored for the Naive accelerator).\n\nExamples\n\njulia> using PlantGeomPrimitives;\n\njulia> sc = Scene(mesh = Ellipse());\n\njulia> source = DirectionalSource(sc, θ = 0.0, Φ = 0.0, radiosity = 1.0, nrays = 1_000);\n\njulia> rt = RayTracer(sc, source);\n\njulia> sources = (DirectionalSource(sc, θ = 0.0, Φ = 0.0, radiosity = 1.0, nrays = 1_000),\n                  DirectionalSource(sc, θ = 45.0, Φ = 0.0, radiosity = 1.0, nrays = 1_000));\n\njulia> rt = RayTracer(sc, sources);\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.SAH","page":"Ray tracing","title":"PlantRayTracer.SAH","text":"SAH{K}(minN, maxL)\n\nRule to be used in RayTracer when acceleration = BVH. It will divide each node at the axis and location using the Surface Area Heuristics. To speed up the construction, only K cuts will be tested per axis. These cuts will correspond to the quantiles along each axis. The rule is parameterized by the minimum number of triangles in a leaf node (minN) and the maximum depth of the tree (maxL).\n\nExamples\n\njulia> rule = SAH{3}(1,5);\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.Sensor","page":"Ray tracing","title":"PlantRayTracer.Sensor","text":"Sensor(nw::Int)\n\nCreate a sensor material object to store power for nw wavelengths. A sensor material will let rays pass through without altering the direction or irradiance. They will also not count for the total number of ray iterations.\n\nExamples\n\njulia> s = Sensor(1);\n\njulia> s = Sensor(3);\n\n\n\n\n\n","category":"type"},{"location":"api/raytracer/#PlantRayTracer.Source-Tuple{Any, Any, Number, Integer}","page":"Ray tracing","title":"PlantRayTracer.Source","text":"Source(geom, angle, power::Number, nrays)\nSource(geom, angle, power::Tuple, nrays)\n\nCreate an irradiance source given a source geometry, a source angle, the power per ray and the total number of rays to be generated from this source. When simulating more than one wavelength simultaneously, a tuple of power values should be given, of the same length as in the materials used in the scene. See VPL documentation for details on source geometries and source angles.\n\nExamples\n\njulia> import PlantGeomPrimitives as PG\n\njulia> source_geom = PointSource(PG.O());\n\njulia> source_dir = FixedSource(0.0, 0.0);\n\njulia> Source(source_geom, source_dir, 1.0, 1_000);\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.DirectionalSource-Tuple{PlantRayTracer.AABB}","page":"Ray tracing","title":"PlantRayTracer.DirectionalSource","text":"DirectionalSource(box::AABB; θ, Φ, radiosity, nrays)\nDirectionalSource(scene::Scene; θ, Φ, radiosity, nrays)\n\nCreate a Directional source (including geometry and angle components) by providing an axis-aligned bounding box (box) or an Scene object (scene) as well as the zenith (θ) and azimuth (Φ) angles, the radiosity of the source projected on the horizontal plane and the number of rays to be generated. Directional sources may generate incorrect results in the absence of a grid cloner that extendes the scenes. This is because the rays are generated from the upper face of the scene's bounding box. See VPL documentation for details on light sources.\n\nExamples\n\njulia> using PlantGeomPrimitives;\n\njulia> sc = Scene(mesh = Ellipse());\n\njulia> source = DirectionalSource(sc, θ = 0.0, Φ = 0.0, radiosity = 1.0, nrays = 1_000);\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.accelerate-Tuple{PlantGeomPrimitives.Scene}","page":"Ray tracing","title":"PlantRayTracer.accelerate","text":"accelerate(scene::Scene; settings = RTSettings(), acceleration = Naive, rule = nothing)\n\nCreate an AccScene object from a scene, settings and acceleration function (choose from Naive or  BVH). The argument rule is only required for the accelerator BVH and it must be an object of type SAH or AvgSplit (it is ignored for the Naive accelerator). The AccScene object contains the acceleration structure and the grid cloner structure built on top of the original 3D meshes in scene. See VPL documentation for details.\n\nExamples\n\njulia> using PlantGeomPrimitives;\n\njulia> sc = Scene(mesh = Ellipse());\n\njulia> acc = accelerate(sc);\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.get_nw-Tuple{PlantRayTracer.RayTracer}","page":"Ray tracing","title":"PlantRayTracer.get_nw","text":"get_nw(rt::RayTracer)\n\nRetrieve the number of wavelengths being simulated by the ray tracer. See VPL documentation for more details on the ray tracer.\n\nExamples\n\njulia> using PlantGeomPrimitives;\n\njulia> sc = Scene(mesh = Ellipse());\n\njulia> source = DirectionalSource(sc, θ = 0.0, Φ = 0.0, radiosity = 1.0, nrays = 1_000);\n\njulia> rt = RayTracer(sc, source);\n\njulia> get_nw(rt)\n1\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.get_nw-Union{Tuple{PlantRayTracer.Source{G, A, nw}}, Tuple{nw}, Tuple{A}, Tuple{G}} where {G, A, nw}","page":"Ray tracing","title":"PlantRayTracer.get_nw","text":"get_nw(s::Source)\n\nRetrieve the number of wavelengths that rays from a source will contain.\n\nExamples\n\njulia> using PlantGeomPrimitives;\n\njulia> sc = Scene(mesh = Ellipse());\n\njulia> source = DirectionalSource(sc, θ = 0.0, Φ = 0.0, radiosity = 1.0, nrays = 1_000);\n\njulia> get_nw(source);\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.power-Tuple{PlantGeomPrimitives.Material}","page":"Ray tracing","title":"PlantRayTracer.power","text":"power(material::Material)\n\nExtract the power stored inside a material.\n\nExamples\n\njulia> l = Lambertian(τ = 0.1, ρ = 0.2);\n\njulia> power(l);\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.reset!-Tuple{PlantGeomPrimitives.Material}","page":"Ray tracing","title":"PlantRayTracer.reset!","text":"reset!(material::Material)\n\nReset the power stored inside a material back to zero\n\nExamples\n\njulia> l = Lambertian(τ = 0.1, ρ = 0.2);\n\njulia> l.power[1] = 10.0;\n\njulia> reset!(l);\n\njulia> l;\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.rho-Tuple","page":"Ray tracing","title":"PlantRayTracer.rho","text":"rho(vals...)\n\nGenerate values of reflectivity to be used in material object. vals... is a list of one or more comma-separated values, corresponding to the different wavelengths/wavebands to be simulated in a ray tracer.\n\nExamples\n\njulia> rho(1.0, 0.0, 2.0);\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.tau-Tuple","page":"Ray tracing","title":"PlantRayTracer.tau","text":"tau(vals...)\n\nGenerate values of transmisivity to be used in material object. vals... is a list of one or more comma-separated values, corresponding to the different wavelengths/wavebands to be simulated in a ray tracer.\n\nExamples\n\njulia> tau(1.0, 0.0, 2.0);\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.trace!-Tuple{PlantRayTracer.RayTracer}","page":"Ray tracing","title":"PlantRayTracer.trace!","text":"trace!(rt)\n\nRun the ray tracing simulations. This function will overwrite the power component of any material object that is included in the scene. It returns the total number of rays being traced (primary and secondary). See VPL documentation for more details on the ray tracer.\n\nExamples\n\njulia> using PlantGeomPrimitives;\n\njulia> sc = Scene(mesh = Ellipse());\n\njulia> source = DirectionalSource(sc, θ = 0.0, Φ = 0.0, radiosity = 1.0, nrays = 1_000);\n\njulia> rt = RayTracer(sc, source);\n\njulia> trace!(rt);\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#Private","page":"Ray tracing","title":"Private","text":"","category":"section"},{"location":"api/raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Private functions, types or constants from PlantRayTracer. These are not exported, so you need to prefix the function name with PlantGeomPrimitives. to access them. Also bear in mind that these are not part of the public API, so they may change without notice.","category":"page"},{"location":"api/raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Modules = [PlantRayTracer]\nPublic = false\nPrivate = true","category":"page"},{"location":"api/raytracer/#PlantRayTracer.Triangle-Tuple{PlantGeomPrimitives.Mesh}","page":"Ray tracing","title":"PlantRayTracer.Triangle","text":"Triangle(mesh::Mesh)\n\nCreate a vector of ray tracing Triangle objects from a Mesh object.\n\nExamples\n\njulia> using PlantGeomPrimitives;\n\njulia> e = Ellipse();\n\njulia> t = PlantRayTracer.Triangle(e);\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.Triangle-Tuple{PlantGeomPrimitives.Scene}","page":"Ray tracing","title":"PlantRayTracer.Triangle","text":"Triangle(scene::Scene)\n\nCreate a vector of ray tracing Triangle objects from a Scene object.\n\nExamples\n\njulia> using PlantGeomPrimitives;\n\njulia> sc = Scene(mesh = Ellipse());\n\njulia> t = PlantRayTracer.Triangle(sc);\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.Triangle-Tuple{StaticArraysCore.SVector{3}, StaticArraysCore.SVector{3}, StaticArraysCore.SVector{3}}","page":"Ray tracing","title":"PlantRayTracer.Triangle","text":"Triangle(p1::Vec, p2::Vec, p3::Vec)\n\nCreate a ray tracing Triangle object given the three vertices p1, p2 and p3.\n\nExamples\n\njulia> using PlantGeomPrimitives\n\njulia> t = PlantRayTracer.Triangle(Vec(1.0, 0.0, 1.0), Vec(0.0, 1.0, .0), Vec(1.0, 1.0, 1.0));\n\n\n\n\n\n","category":"method"},{"location":"api/raytracer/#PlantRayTracer.Triangle-Tuple{}","page":"Ray tracing","title":"PlantRayTracer.Triangle","text":"Triangle()\n\nCreate a ray tracing Triangle object with default vertices (unit vectors in each axis).\n\nExamples\n\njulia> t = PlantRayTracer.Triangle();\n\n\n\n\n\n","category":"method"},{"location":"manual/Geometry/Primitives/#manual_primitives","page":"Geometry primitives","title":"Geometry primitives","text":"","category":"section"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"Alejandro Morales","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"using VIrtualPlantLab\nimport ColorTypes: RGBA # for the color of each mesh\nimport GLMakie # For 3D rendering (native OpenGL backend)","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"VPL offers several functions to created 3D meshes that correspond to common geometric shapes (i.e., primitives). They are meant to represent simple geometry elements or to build more complex geometries through the use of turtle-based procedural geometry. For that reason, there are two versions of each primitive constructor: one that constructs the mesh directly (with a standard location and orientation) and one that feeds the mesh to a turtle. The former is meant to be used when manually adding geometries to am existing scene (e.g., soil, structural elements) whereas the latter is mean to be used within the feed methods associated to nodes in a graph. Additional functions are able to translate and rotate these meshes to the desired location and orientation (see API of the Geometry module for details).","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"Below, the functions for direct construction of the meshes are listed. The turtle-based constructor have the same argument plus the turtle arugment itself as well as optional arguments for color and optical materias (see API of the Geometry module for more details).","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"Each primitive is visualized using the render function form VPL. These 3D visualizations keep the axes to help understand what the standard location and orientation are (use axes = false to turn off). They also set normals = true and wireframe = true to highlight how the mesh is partitioned into triangles and the normal vectors of each triangle (this is important for the ray tracer and when exporting meshes out of VPL). All meshes are rendered in green assuming 50% transparency (color = RGBA(0,1,0,0.5)). Note that one must use transparency = true to ensure that the transparency is enabled when rendering the mesh.","category":"page"},{"location":"manual/Geometry/Primitives/#Triangle","page":"Geometry primitives","title":"Triangle","text":"","category":"section"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = Triangle(length = 1.0, width = 1.0)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"manual/Geometry/Primitives/#Rectangle","page":"Geometry primitives","title":"Rectangle","text":"","category":"section"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = Rectangle(length = 1.0, width = 1.0)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"manual/Geometry/Primitives/#Trapezoid","page":"Geometry primitives","title":"Trapezoid","text":"","category":"section"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = Trapezoid(length = 1.0, width = 1.0, ratio = 0.5)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"manual/Geometry/Primitives/#Ellipse","page":"Geometry primitives","title":"Ellipse","text":"","category":"section"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = Ellipse(length = 1.0, width = 1.0, n = 30)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"manual/Geometry/Primitives/#Axis-aligned-bounding-box","page":"Geometry primitives","title":"Axis-aligned bounding box","text":"","category":"section"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = BBox(Vec(0.0, 0.0, 0.0), Vec(1.0, 1.0, 1.0))\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"manual/Geometry/Primitives/#Cube","page":"Geometry primitives","title":"Cube","text":"","category":"section"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"Solid version","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = SolidCube(length = 1.0, width = 1.0, height = 1.0)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"Hollow version","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = HollowCube(length = 1.0, width = 1.0, height = 1.0)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"manual/Geometry/Primitives/#Cylinder","page":"Geometry primitives","title":"Cylinder","text":"","category":"section"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"Solid version","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = SolidCylinder(length = 1.0, width = 1.0, height = 1.0, n = 80)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"Hollow version","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = HollowCylinder(length = 1.0, width = 1.0, height = 1.0, n = 40)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"manual/Geometry/Primitives/#Frustum","page":"Geometry primitives","title":"Frustum","text":"","category":"section"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"Solid version","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = SolidFrustum(length = 1.0, width = 1.0, height = 1.0, ratio = 0.5, n = 80)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"Hollow version","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = HollowFrustum(length = 1.0, width = 1.0, height = 1.0, ratio = 0.5, n = 40)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"manual/Geometry/Primitives/#Cone","page":"Geometry primitives","title":"Cone","text":"","category":"section"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"Solid version","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = SolidCone(length = 1.0, width = 1.0, height = 1.0, n = 40)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"Hollow version","category":"page"},{"location":"manual/Geometry/Primitives/","page":"Geometry primitives","title":"Geometry primitives","text":"p = HollowCone(length = 1.0, width = 1.0, height = 1.0, n = 20)\nrender(p, wireframe = true, normals = true, color = RGBA(0,1,0,0.5), transparency = true)","category":"page"},{"location":"VPLVerse/SkyDomes/API/#Sky-models","page":"SkyDomes API","title":"Sky models","text":"","category":"section"},{"location":"VPLVerse/SkyDomes/API/","page":"SkyDomes API","title":"SkyDomes API","text":"CurrentModule = SkyDomes","category":"page"},{"location":"VPLVerse/SkyDomes/API/#Index","page":"SkyDomes API","title":"Index","text":"","category":"section"},{"location":"VPLVerse/SkyDomes/API/","page":"SkyDomes API","title":"SkyDomes API","text":"Modules = [SkyDomes]\nPublic = true\nPrivate = true","category":"page"},{"location":"VPLVerse/SkyDomes/API/#Public-API","page":"SkyDomes API","title":"Public API","text":"","category":"section"},{"location":"VPLVerse/SkyDomes/API/","page":"SkyDomes API","title":"SkyDomes API","text":"Modules = [SkyDomes]\nPublic = true\nPrivate = false","category":"page"},{"location":"VPLVerse/SkyDomes/API/#SkyDomes.CIE-Tuple{}","page":"SkyDomes API","title":"SkyDomes.CIE","text":"CIE(;type = 1, θₛ = 0.0, Φₛ = 0.0, rtol = sqrt(eps(Float64)), atol = 0.0,\n\nmaxevals = typemax(Int))\n\nCreate a standard CIE model of sky diffuse radiance on the horizontal plane as described by Darula and Kittler (2002). The argument type can have values from 1 to 15 representing the 15 standard CIE models. θₛ and Φₛ are the zenith and azimuth angles of the solar disc. rtol and atol and maxevals are the relative tolerance, absolute tolerance and maximum number of function evaluation of the numerical integration algorithm. See package documentation for details.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/SkyDomes/API/#SkyDomes.StandardSky","page":"SkyDomes API","title":"SkyDomes.StandardSky","text":"StandardSky()\n\nStandard model of overcast sky diffuse radiation Moon & Spencer (1942). See package documentation for details.\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/SkyDomes/API/#SkyDomes.UniformSky","page":"SkyDomes API","title":"SkyDomes.UniformSky","text":"UniformSky()\n\nModel of uniform sky diffuse radiation. See package documentation for details.\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/SkyDomes/API/#SkyDomes.clear_sky-Tuple{}","page":"SkyDomes API","title":"SkyDomes.clear_sky","text":"clear_sky(;lat, DOY, t, altitude = 0.0, TL = 4.0)\n\nCalculate global, direct and diffuse solar radiation on the horizontal plane using the clear sky model by Ineichen and Perez (2002).\n\nArguments\n\nlat: latitude in radians\nDOY: day of year\nf: fraction of the day (0 = sunrise, 1 = sunset)\naltitude: altitude above sea level in meters (default 0.0)\nTL: Linke turbidity coefficient (default 4.0)\n\nReturns\n\nA named tuple with fields:\n\nIg: global solar radiation on the horizontal plane in W/m^2\nIdir: direct solar radiation on the horizontal plane in W/m^2\nIdif: diffuse solar radiation on the horizontal plane in W/m^2\ntheta: solar zenith angle in radians\n\nReferences\n\nIneichen P., Perez R., A new airmass independent formulation for the Linke turbidity coefficient, Solar Energy, Vol 73(3), pp.151–157, 2002.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/SkyDomes/API/#SkyDomes.equal_angle_intervals-Tuple{Any, Any}","page":"SkyDomes API","title":"SkyDomes.equal_angle_intervals","text":"equal_angle_intervals(ntheta, nphi)\n\nDiscretize the sky into ntheta zenith rings of nphi sectors each assuming the same angle intervals for each sector (Δθ = π/2/ntheta and ΔΦ = 2π/nphi). Returns an object of type SkySectors. See package documentation for details.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/SkyDomes/API/#SkyDomes.equal_solid_angles-Tuple{Any, Any}","page":"SkyDomes API","title":"SkyDomes.equal_solid_angles","text":"equal_solid_angles (ntheta, nphi)\n\nDiscretize the sky into ntheta zenith rings and a number of sectors per ring that is proportional to sin(θ). The total number of sectors will be ntheta*nphi. Returns an object of type SkySectors. See package documentation for details.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/SkyDomes/API/#SkyDomes.radiosity-Union{Tuple{nw}, Tuple{SkyDomes.StandardSky, SkyDomes.SkySectors}, Tuple{SkyDomes.StandardSky, SkyDomes.SkySectors, StaticArraysCore.SVector{nw, Float64}}} where nw","page":"SkyDomes API","title":"SkyDomes.radiosity","text":"radiosity(m::StandardSky, sky::SkySectors, Idif::SVector{nw, Float64})\n\nCalculate the radiosity of each section of sky on the horizontal plane given diffuse irradiance on the horizontal plane (Idif with nw wavebands) assuming a Standard Sky model and for nw wavebands. See package documentation for details.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/SkyDomes/API/#SkyDomes.radiosity-Union{Tuple{nw}, Tuple{SkyDomes.UniformSky, SkyDomes.SkySectors}, Tuple{SkyDomes.UniformSky, SkyDomes.SkySectors, StaticArraysCore.SVector{nw, Float64}}} where nw","page":"SkyDomes API","title":"SkyDomes.radiosity","text":"radiosity(m::UniformSky, sky::SkySectors, Idif::SVector{nw, Float64}) where nw\n\nCalculate the radiosity of each section of sky on the horizontal plane given diffuse irradiance on the horizontal plane (Idif with nw wavebands) assuming a Uniform Sky model. See package documentation for details.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/SkyDomes/API/#SkyDomes.sky-Tuple{Any}","page":"SkyDomes API","title":"SkyDomes.sky","text":"sky(scene; Idir = 0.77, nrays_dir = 100_000, theta_dir = 0.0, phi_dir = 0.0,\n           Idif = 0.23, nrays_dif = 1_000_000, sky_model = StandardSky,\n           dome_method = equal_solid_angles, ntheta = 9, nphi = 12,\n           kwargs...)\n\nCreate a vector of directional radiation sources representing diffuse and direct solar radiation for a given scene.\n\nArguments\n\nscene: A Scene object generated by VPL.\nIdir: The direct solar radiation measured on the horizontal plane (a single value or tuple).\nnrays_dir: The number of rays to be generated for direct solar radiation.\ntheta_dir: The zenith angle of the sun position (radians).\nphi_dir: The azimuthal angle of the sun position (radians).\nIdif: The diffuse solar radiation measured on the horizontal plane (a single value or tuple).\nnrays_dif: The total number of rays to be generated diffuse solar radiation.\nsky_model: The angular distribution of diffuse irradiance (StandardSky, UniformSky or CIE).\ndome_method: The method to discretize hemisphere into patches for diffuse solar radiation (equal_solid_angles or equal_angle_intervals).\nntheta: The number of divisions along the zenith angle for dome_method.\nnphi: The number of divisions along the azimuthal angle for dome_method.\nkwargs...: Additional arguments to be used when dome_method = CIE\n\nReturns\n\nA vector of directional sources that can be used for ray tracing calculations in VPL. ```\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/SkyDomes/API/#SkyDomes.waveband_conversion-Tuple{}","page":"SkyDomes API","title":"SkyDomes.waveband_conversion","text":"waveband_conversion(;Itype = :direct, waveband = :PAR, mode = :power)\n\nReturns the conversion coefficient from solar radiation (W/m2) to a give waveband in either power (W/m2) or photon flux (umol/m2/s). The coefficients are based on the Bird spectral model for a clear sky using June 21th in The Netherlands (latitude 52° N).\n\nArguments\n\nItype: The type of solar radiation, either :direct or :diffuse.\nwaveband: The waveband of interest, one of :PAR, :UV, :blue, :red, :green, or :NIR.\nmode: The physical units of the target, either :power (W/m^2) or :flux (umol/m^2/s).\n\nExamples\n\nwaveband_conversion(Itype = :diffuse, waveband = :UV, mode = :flux)\nwaveband_conversion(waveband = :NIR)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/SkyDomes/API/#Private","page":"SkyDomes API","title":"Private","text":"","category":"section"},{"location":"VPLVerse/SkyDomes/API/","page":"SkyDomes API","title":"SkyDomes API","text":"Private functions, types or constants from SkyDomes. These are not exported, so you need to prefix the function name with PlantGeomPrimitives. to access them. Also bear in mind that these are not part of the public API, so they may change without notice.","category":"page"},{"location":"VPLVerse/SkyDomes/API/","page":"SkyDomes API","title":"SkyDomes API","text":"Modules = [SkyDomes]\nPublic = false\nPrivate = true","category":"page"},{"location":"VPLVerse/SkyDomes/#sky","page":"SkyDomes package","title":"SkyDomes","text":"","category":"section"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"Alejandro Morales","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"The package SkyDomes provides a function to calculate the solar radiation on a horizontal surface (for clear skies) as a function of latitude, day of year and time of the day and for different wavebands. In addition, it can generate light sources as required by the Virtual Plant Lab to simulate the light distribution in a 3D scene.","category":"page"},{"location":"VPLVerse/SkyDomes/#Installation","page":"SkyDomes package","title":"Installation","text":"","category":"section"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"To install SkyDomes.jl, you can use the following command:","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"] add SkyDomes","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"Or, if you prefer the development version:","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"import Pkg\nPkg.add(url = \"https://github.com/VirtualPlantLab/SkyDomes.jl.git\", rev = \"master\")","category":"page"},{"location":"VPLVerse/SkyDomes/#Usage","page":"SkyDomes package","title":"Usage","text":"","category":"section"},{"location":"VPLVerse/SkyDomes/#Solar-radiation","page":"SkyDomes package","title":"Solar radiation","text":"","category":"section"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"Use the clear_sky function to calculate the solar radiation on a horizontal plane as a function of day of year, latitude (in radians) and the relative solar time of the day (f = 0 is sunrise, f = 1 is sunset). The function returns the total solar radiation in W/m² as well as direct and diffuse components. For example:","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"using Sky\nlat = 52.0*π/180.0 # latitude in radians\nDOY = 182\nf = 0.5 # solar noon\nIg, Idir, Idif = clear_sky(lat = lat, DOY = DOY, f = f) # W/m2","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"The values Ig, Idir and Idif are the total, direct and diffuse solar radiation in W/m². The function waveband_conversion can be used to convert these values to specfic wavebands (UV, PAR, NIR, blue, green or red) as well as converting from W/m² to umol/m²/s, assuming particular spectra for direct and diffuse solar radiation. For example:","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"f_PAR_dir = waveband_conversion(Itype = :direct, waveband = :PAR, mode = :flux)\nIdir_PAR = f_PAR_dir*Idir # PAR in umol/m²/s\nf_PAR_dif = waveband_conversion(Itype = :diffuse, waveband = :PAR, mode = :flux)\nIdif_PAR = f_PAR_dif*Idif # PAR in umol/m²/s","category":"page"},{"location":"VPLVerse/SkyDomes/#Light-sources-for-ray-tracing","page":"SkyDomes package","title":"Light sources for ray tracing","text":"","category":"section"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"Once the direct and diffuse solar radiation in the relevant wavebands and units have been calculated, the function sky can be used to generate the light sources required by VPL to simulate the light distribution in a 3D scene. For example, a simple horizontal tile (representing soil) in VPL may be created as follows:","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"using VPL\nr = Rectangle(length = 2.0, width = 1.0)\nrotatey!(r, -π/2) # To put it in the XY plane\ntranslate!(r, Vec(0.0, 0.5, 0.0))\nrender(r)","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"A 3D scene requires adding optical properties (e.g., a black material property) and linking these to the mesh (for complicated scenes see VPL documentation for examples):","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"materials = [Black()]\nids = [1,1]\nscene = RTScene(mesh = r, ids = ids, materials = materials)","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"If we want to compute the amount of solar radiation absorbed by this tile, we need to create a series of light sources. The function sky can be used for that purpose:","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"sources = sky(scene,\n             Idir = Idir_PAR, # Direct solar radiation from above\n             nrays_dir = 1_000_000, # Number of rays for direct solar radiation\n             Idif = Idif_PAR, # Diffuse solar radiation from above\n             nrays_dif = 10_000_000, # Total number of rays for diffuse solar radiation\n             sky_model = StandardSky, # Angular distribution of solar radiation\n             dome_method = equal_solid_angles, # Discretization of the sky dome\n             ntheta = 9, # Number of discretization steps in the zenith angle\n             nphi = 12) # Number of discretization steps in the azimuth angle","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"The function takes the scene as input to ensure that light sources scale with the scene. Direct solar radiation is represented by a single directiona light source that will emmit a number of rays given by nrays_dir. Diffuse solar radiation is represented by a hemispherical dome of directional light sources that will emmit a total of nrays_dif rays. The angular distribution of the diffuse solar radiation and the discretization of the sky dome can be modified via dome_method, sky_model, ntheta and nphi. See API documentation and VPL documentation for details.","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"Once the light sources are created, a ray tracing object can be generated combining all the elements above:","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"settings = RTSettings(parallel = true)\nrtobj = RayTracer(scene, sources, settings = settings);","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"And the ray tracing can be performed by calling the trace! function:","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"trace!(rtobj);","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"As expected, the amount of solar radiation absorbed by the tile equals the total in the scene (Ig):","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"materials[1].power[1]/area(r) ≈ Idir_PAR + Idif_PAR","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"See VPL documentation for more details and tutorials on ray tracing simulations","category":"page"},{"location":"VPLVerse/SkyDomes/#Roadmap-for-future-dfevelopment","page":"SkyDomes package","title":"Roadmap for future dfevelopment","text":"","category":"section"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"The package is still under development. The following features are planned:","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"Calculate fraction of direct and diffuse radiation from measurements of actual","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"solar radiation.","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"Calculate the solar radiation on a tilted surface.\nAllow for a different orientation of the 3D scene from VPL.\nMore advanced algorithms for solar radiation and spectrum (e.g., SOLPOS, Bird).","category":"page"},{"location":"VPLVerse/SkyDomes/","page":"SkyDomes package","title":"SkyDomes package","text":"See Issues for additional features to be implemented.","category":"page"},{"location":"tutorials/snowflakes/#The-Koch-snowflake","page":"The Koch snowflake","title":"The Koch snowflake","text":"","category":"section"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"Alejandro Morales","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"In this example, we create a Koch snowflake, which is one of the earliest fractals to be described. The Koch snowflake is a closed curve composed on multiple of segments of different lengths. Starting with an equilateral triangle, each segment in the snowflake is replaced by four segments of smaller length arrange in a specific manner. Graphically, the first four iterations of the Koch snowflake construction process result in the following figures (the green segments are shown as guides but they are not part of the snowflake):","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"(Image: First four iterations fo Koch snowflake fractal)","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"In order to implement the construction process of a Koch snowflake in VPL we need to understand how a 3D structure can be generated from a graph of nodes. VPL uses a procedural approach to generate of structure based on the concept of turtle graphics.","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"The idea behind this approach is to imagine a turtle located in space with a particular position and orientation. The turtle then starts consuming the different nodes in the graph (following its topological structure) and generates 3D structures as defined by the user for each type of node. The consumption of a node may also include instructions to move and/or rotate the turtle, which allows to alter the relative position of the different 3D structures described by a graph.","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"The construction process of the Koch snowflake in VPL could then be represented by the following axiom and rewriting rule:","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"axiom: E(L) + RU(120) + E(L) + RU(120) + E(L) rule:  E(L) → E(L/3) + RU(-60) + E(L/3) + RU(120) + E(L/3) + RU(-60) + E(L/3)","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"Where E represent and edge of a given length (given in parenthesis) and RU represents a rotation of the turtle around the upward axis, with angle of rotation given in parenthesis in hexadecimal degrees. The rule can be visualized as follows:","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"(Image: Koch construction rule)","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"Note that VPL already provides several classes for common turtle movements and rotations, so our implementation of the Koch snowflake only needs to define a class to implement the edges of the snowflake. This can be achieved as follows:","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"using VirtualPlantLab\nimport GLMakie ## Import rather than \"using\" to avoid masking Scene\nusing ColorTypes ## To define colors for the rendering\nmodule sn\n    import VirtualPlantLab\n    struct E <: VirtualPlantLab.Node\n        length::Float64\n    end\nend\nimport .sn","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"Note that nodes of type E need to keep track of the length as illustrated in the above. The axiom is straightforward:","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"const L = 1.0\naxiom = sn.E(L) + VirtualPlantLab.RU(120.0) + sn.E(L) + VirtualPlantLab.RU(120.0) + sn.E(L)","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"The rule is also straightforward to implement as all the nodes of type E will be replaced in each iteration. However, we need to ensure that the length of the new edges is a calculated from the length of the edge being replaced. In order to extract the data stored in the node being replaced we can simply use the function data. In this case, the replacement function is defined and then added to the rule. This can make the code more readable but helps debugging and testing the replacement function.","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"function Kochsnowflake(x)\n    L = data(x).length\n    sn.E(L/3) + RU(-60.0) + sn.E(L/3) + RU(120.0) + sn.E(L/3) + RU(-60.0) + sn.E(L/3)\nend\nrule = Rule(sn.E, rhs = Kochsnowflake)","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"The model is then created by constructing the graph","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"Koch = Graph(axiom = axiom, rules = Tuple(rule))","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"In order to be able to generate a 3D structure we need to define a method for the function VirtualPlantLab.feed! (notice the need to prefix it with VirtualPlantLab. as we are going to define a method for this function). The method needs to two take two arguments, the first one is always an object of type Turtle and the second is an object of the type for which the method is defined (in this case, E).","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"The body of the method should generate the 3D structures using the geometry primitives provided by VPL and feed them to the turtle that is being passed to the method as first argument. In this case, we are going to represent the edges of the Koch snowflakes with cylinders, which can be generated with the HollowCylinder! function from VirtualPlantLab. Note that the feed! should return nothing, the turtle will be modified in place (hence the use of ! at the end of the function as customary in the VPL community).","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"In order to render the geometry, we need assign a color (i.e., any type of color support by the package ColorTypes.jl). In this case, we just feed a basic RGB color defined by the proportion of red, green and blue. To make the figures more appealing, we can assign random values to each channel of the color to generate random colors.","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"function VirtualPlantLab.feed!(turtle::Turtle, e::sn.E, vars)\n    HollowCylinder!(turtle, length = e.length, width = e.length/10,\n                    height = e.length/10, move = true,\n                    color = RGB(rand(), rand(), rand()))\n    return nothing\nend","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"Note that the argument move = true indicates that the turtle should move forward as the cylinder is generated a distance equal to the length of the cylinder. Also, the feed! method has a third argument called vars. This gives acess to the shared variables stored within the graph (such that they can be accessed by any node). In this case, we are not using this argument.","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"After defining the method, we can now call the function render on the graph to generate a 3D interactive image of the Koch snowflake in the current state","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"sc = Scene(Koch)\nrender(sc, axes = false)","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"This renders the initial triangle of the construction procedure of the Koch snowflake. Let's execute the rules once to verify that we get the 2nd iteration (check the figure at the beginning of this document):","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"rewrite!(Koch)\nrender(Scene(Koch), axes = false)","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"And two more times","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"for i in 1:3\n    rewrite!(Koch)\nend\nrender(Scene(Koch), axes = false)","category":"page"},{"location":"tutorials/snowflakes/#Other-snowflake-fractals","page":"The Koch snowflake","title":"Other snowflake fractals","text":"","category":"section"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"To demonstrate the power of this approach, let's create an alternative snowflake. We will simply invert the rotations of the turtle in the rewriting rule","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"function Kochsnowflake2(x)\n   L = data(x).length\n   sn.E(L/3) + RU(60.0) + sn.E(L/3) + RU(-120.0) + sn.E(L/3) + RU(60.0) + sn.E(L/3)\nend\nrule2 = Rule(sn.E, rhs = Kochsnowflake2)\nKoch2 = Graph(axiom = axiom, rules = Tuple(rule2))","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"The axiom is the same, but now the edges added by the rule will generate the edges towards the inside of the initial triangle. Let's execute the first three iterations and render the results","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"# First iteration\nrewrite!(Koch2)\nrender(Scene(Koch2), axes = false)\n# Second iteration\nrewrite!(Koch2)\nrender(Scene(Koch2), axes = false)\n# Third iteration\nrewrite!(Koch2)\nrender(Scene(Koch2), axes = false)","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"This is know as Koch antisnowflake. We could also easily generate a Cesàro fractal by also changing the axiom:","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"axiomCesaro = sn.E(L) + RU(90.0) + sn.E(L) + RU(90.0) + sn.E(L) + RU(90.0) + sn.E(L)\nCesaro = Graph(axiom = axiomCesaro, rules = (rule2,))\nrender(Scene(Cesaro), axes = false)","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"And, as before, let's go through the first three iterations","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"# First iteration\nrewrite!(Cesaro)\nrender(Scene(Cesaro), axes = false)\n# Second iteration\nrewrite!(Cesaro)\nrender(Scene(Cesaro), axes = false)\n# Third iteration\nrewrite!(Cesaro)\nrender(Scene(Cesaro), axes = false)","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"","category":"page"},{"location":"tutorials/snowflakes/","page":"The Koch snowflake","title":"The Koch snowflake","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/Visualization/#manual_3d_visualization","page":"3D visualization","title":"3D visualization","text":"","category":"section"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"Alejandro Morales","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"manual/Visualization/#Introduction","page":"3D visualization","title":"Introduction","text":"","category":"section"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"VPL has two forms of visualization that are specific to a model: (i) a network representation of the graph via draw() and (ii) a 3D rendering of a graph or scene via render(). Both forms of visualization rely on the Makie visualization ecosystem built into Julia. Makie allows for different backends that are relevant in different context of code execution. The backends are automatically chosen based on which Makie backend the user exports. For example if the user runs the following:","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"import GLMakie","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"then the native OpenGL backend will be used. Another possible backend is WGLMakie which will use WebGL that will render the results in an interactive web environment (this is meant to the used in interactive notebooks or special code editors such as VS Code). Finally, the CairoMakie backend will generate vector graphics that can be exported to pdf or svg files (not interactive). It is also possible to export static versions of any visualization in a wide range of formats (see section on Export visualization).","category":"page"},{"location":"manual/Visualization/#Drawing-graphs","page":"3D visualization","title":"Drawing graphs","text":"","category":"section"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"The function draw() can be applied to a Graph object or any subgraph (e.g., the axiom of graph) to visualize the network structure. This will produce a static 2D representation of the graph. By default, each node will be labelled with the type of object stored in it (e.g., a turtle movement object or an user-defined object) and the internal ID that the object has in the graph.","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"For example, a simple graph would be as follows:","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"module L\n    using VirtualPlantLab\n\n    struct N <: Node end\nend\nimport .L\nusing VirtualPlantLab\nimport GLMakie\naxiom = L.N() + (L.N(), L.N()) + L.N() + (L.N(), L.N())\ndraw(axiom)\ngraph = Graph(axiom = axiom)\ndraw(graph)","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"See section on Graphs) and how to access nodes directly from their internal ID for more details.","category":"page"},{"location":"manual/Visualization/#D-visualization","page":"3D visualization","title":"3D visualization","text":"","category":"section"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"A Scene can be rendered in 3D using the function render(). To facilitate usage, the function render() can be applied to a Graph object or an array of Graph objects and it will automatically generated the corresponding Scene object internally. It can also be applied to a 3D mesh (e.g., the result of a primitive constructor, see section on Primitives).","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"When a mesh is being rendered directly, a default color will be used for the mesh that the user can override (see API documentation for PlantViz.render). Otherwise, render() will use the corresponding colors stored in the scene. It is also possible to add a mesh to an existing 3D visualization by using render!().","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"For debugging purposes, the render() function also allows to visualize the edges of the triangles (wireframe = true) and the normal vectors (normals = true).","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"When render() is applied to a Graph object or array of Graph objects, it will create internally a Turtle object to traverse the graph and generate the Scene object. The feed method takes an optional message argument that the user may use to control the generation of geometry and/or colors. The render function allows to define such message (any user-defined data) which will be passed along to the feed methods.","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"Ultimately, render() will call the Makie function mesh() (or mesh!() for render!()) and the Figure object from Makie. This means that any keyword argument that is accepted by mesh() or mesh!() can be used to render() or render!(). It also means that the use can access and modify the Figure() object being returned. For example, it is possible to change the camera position, lighting, etc. See Makie documentation for details.","category":"page"},{"location":"manual/Visualization/#Visualization-in-context","page":"3D visualization","title":"Visualization in context","text":"","category":"section"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"Depending on the context and backend used, a different form of visualization will be obtained. The different scenarios are described below:","category":"page"},{"location":"manual/Visualization/#Terminal","page":"3D visualization","title":"Terminal","text":"","category":"section"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"This means the code is ran from within the Julia REPL inside a terminal or command prompt (i.e., no IDE or notebook environment):","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"Using the native backend will trigger an external window (entitled Makie) where an interactive OpenGL visualization will be rendered. The interactivity provided allows zooming and moving the camera around the visualization.\nUsing the web backend will open a browser tab (unless there are some OS settings preventing, in which case a local IP address will be printed to the REPL and the user will have to manually input it into the browser) which an intetactive WebGL version will be rendered. The behaviour will be analogous to the natibe backend but note that this backend is still experimental (at the time of writing this documentation) so one should expect the ocasional bug.\nThe vector backend will not display any visual output in this context. One can still export the resulting figure (see section on Export visualization).","category":"page"},{"location":"manual/Visualization/#Live-interactive-notebook","page":"3D visualization","title":"Live interactive notebook","text":"","category":"section"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"This means the code is running withn a Jupyter or Pluto notebook and they an active kernel or Julia session running in the background. Note that a notebook that is stored online will not be live unless it is hosted by a server that can run notebooks such as Binder or Google colab.","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"The native backend will produce an inline visualization (i.e., the visualization output shows below the code cell). This will however create a static image of the 2D or 3D with the initial camera settings (not interactive).\nThe web backend will generate the visualization output below the code cell and it will be interactive as long as the kernel or background Julia session keeps running.\nThe vector backend will display the static output next to the code cell (but only if it is using the svg engine, which is the default).","category":"page"},{"location":"manual/Visualization/#Visual-Studio-Code","page":"3D visualization","title":"Visual Studio Code","text":"","category":"section"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"IDEs that support Julia such as Visual Studio Code will generally have a plot pane where visualization output is stored. This can generally be turn off (in which case the behaviour of the IDE will be the same as running from a terminal). VPL has been tested with Visual Studio Code and the Julia extension and, if the plot pane is active, the behaviour will be equivalent to a live interative notebook:","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"The native backend will trigger an external window rather than in the plot pane.\nThe web backend will generate the visualization output in the plot pane and it will be interactive.\nThe vector backend will generate the static visualization output in the plot pane.","category":"page"},{"location":"manual/Visualization/#Document-generation","page":"3D visualization","title":"Document generation","text":"","category":"section"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"This category includes a file that is processed by Quarto, Documenter, Weave or Literate. In all of these cases the final output will remain static while the visualization output should be generated inline (i.e., next to the code chunk). The following behavior has been observed with Quarto (other document generation methods have not been fully tested with VPL but are expected to behave similarly):","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"For the native backend, a static snapshot of the visualization will always be inlined. The result would be as in the inline visualization of interactive notebooks.\nThe web backend will not generate any visualization in the final document as this backend always requires interactivity.\nThe vector backend will display the static ouput as in interactive notebooks.","category":"page"},{"location":"manual/Visualization/#On-a-headless-server","page":"3D visualization","title":"On a headless server","text":"","category":"section"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"It will be possible to use the visualization tools even when running VPL in a headless system (e.g., a high performance computing cluster). The folliowing is based on the documentation on Makie, it has not been tested with VPL:","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"The native backend will require X11 forwarding to render on the local machine or use VirtualGL technology.\nThe web backend will work if a Javascript serve is setup to serve the HTML content from the remote system (see here for details).\nThe vector backend will generate the images correctly but the user will have to export them to pdf or svg files.","category":"page"},{"location":"manual/Visualization/#Exporting-visualization","page":"3D visualization","title":"Exporting visualization","text":"","category":"section"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"It is possible to save any visualization generated by VPL as an external file with the export_graph() and export_scene() functions (for graph and scene visualizations, respectively). The file formats supported are png (when using native and web backends), pdf and svg (when using vector backend). This is possible by assigning the object returned by draw() or render() to a variable and passing that variable to the corresponding export function. This object contains all the information related to the visualization and printing it (i.e., sending it to the Julia REPL) actually causes the visualization to be created. That is, the following code:","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"draw(graph)","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"is equivalent to:","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"f = draw(graph);\nf","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"Remember that ; will prevent printing the output of whatever Julia command was executed. Saving the graph is a matter of passing f to export_graph() and assign it a file name with extension:","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"f = draw(graph);\nexport_graph(f, \"<filename>.<ext>\")","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"If you generate an interactive visualization, you can remove the ; which will trigger the visualization (inlined or in an external screen) while also saving a reference to the figure inside f. The user may then interact with the figure (e.g., zoom in and pan around), which will automatically update f. That is, whatever you see on the screen will be saved to the external file. For example, rhis allows the user to save the same scene from different perspectives in separate files. The vector formats (pdf and svg) are only compatible with the vector backend, which does not offer interactivity. Hence, this functionality is only available for png files that will save the graph or scene generated by the native or web backends.","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"When drawing a graph or rendering a scene it is possible specify the resolution of the generated image as tuple of two numbers such as resolution = (800, 600). In the case of web and native backends, the resolution is the actual pixels being used, whereas for the vector backend it is related to the actual dimensions of the figure in points. When the user sabes a graph or scene into an external file, the resolution may have to be chosen based on the intended physical dimensions of the figure (on screen or printed). For png images, the conversion from pixel resolution to physical dimensions is captured by the dpi (dots per inch) chosen at the moment of printing or displaying. In the case of vector images, as indicated before, the conventions are 1 Makie unit = 0.75 pt and 1 inch = 72 pt (these are conventions borrowed from web development such that svg images can be converted to png with altering the actual size of the image on the website). To help users, VPL offers the function calculate_resolution() which will compute the resolution to be used by draw() or render() in order to guarantee a particular dimension of the final exported output expressed as width and height (in cm). If we want to save the image as a png we have to specify the intended dpi:","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"# Compute pixel resolution to ensure a width of 6 cm, height of 16 cm and a dpi of 300\nres = calculate_resolution(height = 6, width = 16, dpi = 300)\nf = draw(graph, resolution = res);\nusing FileIO # General package for exporting or importing image files\nsave(\"<filename>.png\", f)","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"In the case of vector formats, we only need to specify the width and height as the conversion between physical dimensions and pixel resolution is fixed, but we will need to specify the correct format:","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"# Compute pixel resolution to ensure a width of 6 cm, height of 16 cm and a dpi of 300\nres = calculate_resolution(height = 6, width = 16, format = \"svg\")\nf = draw(graph, resolution = res);\nimport CairoMakie # Needed to save as svg or pdf\nsave(\"<filename>.svg\", f)","category":"page"},{"location":"manual/Visualization/","page":"3D visualization","title":"3D visualization","text":"Regarding dpi, please consider that the dpi is not a property of a png image (some software include a dpi header in the image metadata, but VPL will not). It is still the responsibility of the user to ensure that the image is printed (or inserted in some document) with the correct dimensions. The calculate_resolution() function will simply guarantee that, once the user enforces those dimensions, the image will have the correct dpi.","category":"page"},{"location":"api/turtle/#Turtle-Geometry","page":"Turtle geometry","title":"Turtle Geometry","text":"","category":"section"},{"location":"api/turtle/","page":"Turtle geometry","title":"Turtle geometry","text":"CurrentModule = PlantGeomTurtle","category":"page"},{"location":"api/turtle/#Public-API","page":"Turtle geometry","title":"Public API","text":"","category":"section"},{"location":"api/turtle/","page":"Turtle geometry","title":"Turtle geometry","text":"Modules = [PlantGeomTurtle]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/turtle/#PlantGeomTurtle.F","page":"Turtle geometry","title":"PlantGeomTurtle.F","text":"F(dist)\n\nMoves a turtle forward a given distance.\n\n\n\n\n\n","category":"type"},{"location":"api/turtle/#PlantGeomTurtle.OR","page":"Turtle geometry","title":"PlantGeomTurtle.OR","text":"OR(head::Vec, up::Vec, arm::Vec)\n\nNode that orients a turtle to a new direction by re-defining the local reference system.\n\n\n\n\n\n","category":"type"},{"location":"api/turtle/#PlantGeomTurtle.RA","page":"Turtle geometry","title":"PlantGeomTurtle.RA","text":"RA(angle)\n\nNode that rotates a turtle around arm axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\n\n\n\n\n\n","category":"type"},{"location":"api/turtle/#PlantGeomTurtle.RH","page":"Turtle geometry","title":"PlantGeomTurtle.RH","text":"RH(angle)\n\nNode that rotates a turtle around head axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\n\n\n\n\n\n","category":"type"},{"location":"api/turtle/#PlantGeomTurtle.RU","page":"Turtle geometry","title":"PlantGeomTurtle.RU","text":"RU(angle)\n\nNode that rotates a turtle around up axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\n\n\n\n\n\n","category":"type"},{"location":"api/turtle/#PlantGeomTurtle.RV","page":"Turtle geometry","title":"PlantGeomTurtle.RV","text":"RV(strength)\n\nRotates the turtle towards the Z axis. See documentation for rv! for details.\n\n\n\n\n\n","category":"type"},{"location":"api/turtle/#PlantGeomTurtle.SET","page":"Turtle geometry","title":"PlantGeomTurtle.SET","text":"SET(to, head, up, arm)\n\nNode that sets the position and orientation of a turtle.\n\n\n\n\n\n","category":"type"},{"location":"api/turtle/#PlantGeomTurtle.T","page":"Turtle geometry","title":"PlantGeomTurtle.T","text":"T(to::Vec)\n\nNode that translates a turtle to the new position to (a Vec object).\n\n\n\n\n\n","category":"type"},{"location":"api/turtle/#PlantGeomTurtle.Turtle-Union{Tuple{}, Tuple{Type{FT}}, Tuple{FT}, Tuple{Type{FT}, Any}} where FT","page":"Turtle geometry","title":"PlantGeomTurtle.Turtle","text":"Turtle(Float64, message)\n\nCreate a meshing turtle that can convert a Graph into a 3D mesh using turtle operators, geometry primitives and methods of feed!(). By default, the meshing turtle will generate geometry primitives with double floating precision (Float64) but it is possible to generate a version with lower precision as in Turtle(Float32). The argument message is any user-defined object.\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.Ellipse!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomPrimitives.Ellipse!","text":"Ellipse!(turtle; length = 1.0, width = 1.0, n = 20, move = false,\n         material = nothing, color = nothing)\n\nGenerate an ellipse in front of a turtle and feed it to a turtle.\n\nArguments\n\nturtle: The turtle that we feed the ellipse to.\nlength: Length of the ellipse.\nwidth: Width of the ellipse.\nn: Number of triangles of the mesh approximating the ellipse (an integer).\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA triangle mesh will be generated with n triangles that approximates an ellipse. The ellipse will be generated in front of the turtle, on the plane defined by the arm and head axes of the turtle. The argument length refers to the axis of the ellipse aligned with the head axis of the turtle, whereas width refers to the orthogonal axis.\n\nWhen move = true, the turtle will be moved forward by a distance equal to length.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> Ellipse!(turtle; length = 1.0, width = 0.5, n = 40);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.HollowCone!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomPrimitives.HollowCone!","text":"HollowCone!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 20, move = false,\nmaterial = nothing, color = nothing)\n\nGenerate a hollow cone in front of the turtle and feed it to a turtle.\n\nArguments\n\nturtle: The turtle that we feed the hollow cone to.\nlength: Length of the ellipse at the base of the hollow cone.\nwidth: Width of the ellipse at the base of the hollow cone.\nheight: Height of the hollow cone.\nn: Number of triangles in the mesh.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA mesh will be generated with n triangles that approximate the hollow cone. The cone will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\n\nWhen move = true, the turtle will be moved forward by a distance equal to height.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> Trapezoid!(turtle; length = 1.0, width = 1.0, ratio = 0.5);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.HollowCube!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomPrimitives.HollowCube!","text":"HollowCube!(turtle; length = 1.0, width = 1.0, height = 1.0, move = false,\nmaterial = nothing, color = nothing)\n\nGenerate a hollow cube in front of the turtle and feed it to a turtle.\n\nArguments\n\nturtle: The turtle that we feed the hollow cube to.\nlength: Length of the rectangle at the base of the hollow cube.\nwidth: Width of the rectangle at the base of the hollow cube.\nheight: Height of the hollow cube.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA mesh will be generated of a hollow cube. The cube will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\n\nWhen move = true, the turtle will be moved forward by a distance equal to height.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> HollowCube!(turtle; length = 1.0, width = 1.0, height = 2.0);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.HollowCylinder!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomPrimitives.HollowCylinder!","text":"HollowCylinder!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 40, move = false,\nmaterial = nothing, color = nothing)\n\nGenerate a hollow cylinder in front of the turtle and feed it to a turtle.\n\nArguments\n\nturtle: The turtle that we feed the hollow cylinder to.\nlength: Length of the ellipse at the base of the hollow cylinder.\nwidth: Width of the ellipse at the base of the hollow cylinder.\nheight: Height of the hollow cylinder.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA mesh will be generated with n triangles that approximate the hollow cylinder. The cylinder will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\n\nWhen move = true, the turtle will be moved forward by a distance equal to height.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> HollowCylinder!(turtle; length = 1.0, width = 1.0, height = 2.0, n = 40);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.HollowFrustum!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomPrimitives.HollowFrustum!","text":"HollowFrustum!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 40, move = false,\nmaterial = nothing, color = nothing)\n\nGenerate a hollow frustum in front of the turtle and feed it to a turtle.\n\nArguments\n\nturtle: The turtle that we feed the hollow frustum to.\nlength: Length of the ellipse at the base of the hollow frustum.\nwidth: Width of the ellipse at the base of the hollow frustum.\nheight: Height of the hollow frustum.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA mesh will be generated with n triangles that approximate the hollow frustum. The frustum will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\n\nWhen move = true, the turtle will be moved forward by a distance equal to height.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> HollowFrustum!(turtle; length = 1.0, width = 1.0, height = 2.0, n = 40);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.Rectangle!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomPrimitives.Rectangle!","text":"Rectangle!(turtle; length = 1.0, width = 1.0, move = false,\n           material = nothing, color = nothing)\n\nGenerate a rectangle in front of the turtle and feed it to a turtle.\n\nArguments\n\nturtle: The turtle that we feed the rectangle to.\nlength: Length of the rectangle.\nwidth: Width of the rectangle.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA triangle mesh will be generated representing the rectangle. The rectangle will be generated in front of the turtle, on the plane defined by the arm and head axes of the turtle. The argument length refers to the axis of the rectangle aligned with the head axis of the turtle, whereas width refers to the orthogonal axis.\n\nWhen move = true, the turtle will be moved forward by a distance equal to length.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> Rectangle!(turtle; length = 1.0, width = 0.5);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.SolidCone!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomPrimitives.SolidCone!","text":"SolidCone!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 40, move = false,\nmaterial = nothing, color = nothing)\n\nGenerate a solid frustum in front of the turtle and feed it to a turtle.\n\nArguments\n\nturtle: The turtle that we feed the solid cone to.\nlength: Length of the ellipse at the base of the solid cone.\nwidth: Width of the ellipse at the base of the solid cone.\nheight: Height of the solid cone.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA mesh will be generated with n triangles that approximate the solid cone. The cone will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\n\nWhen move = true, the turtle will be moved forward by a distance equal to height.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> SolidCone!(turtle; length = 1.0, width = 1.0, height = 2.0, n = 40);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.SolidCube!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomPrimitives.SolidCube!","text":"SolidCube!(turtle; length = 1.0, width = 1.0, height = 1.0, move = false,\nmaterial = nothing, color = nothing)\n\nGenerate a solid cube in front of the turtle and feed it to a turtle.\n\nArguments\n\nturtle: The turtle that we feed the solid cube to.\nlength: Length of the rectangle at the base of the solid cube.\nwidth: Width of the rectangle at the base of the solid cube.\nheight: Height of the solid cube.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA mesh will be generated of a solid cube. The cube will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\n\nWhen move = true, the turtle will be moved forward by a distance equal to height.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> SolidCube!(turtle; length = 1.0, width = 1.0, height = 2.0);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.SolidCylinder!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomPrimitives.SolidCylinder!","text":"SolidCylinder!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 80, move = false,\nmaterial = nothing, color = nothing)\n\nGenerate a solid cylinder in front of the turtle and feed it to a turtle.\n\nArguments\n\nturtle: The turtle that we feed the solid cylinder to.\nlength: Length of the ellipse at the base of the solid cylinder.\nwidth: Width of the ellipse at the base of the solid cylinder.\nheight: Height of the solid cylinder.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA mesh will be generated with n triangles that approximate the solid cylinder. The cylinder will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\n\nWhen move = true, the turtle will be moved forward by a distance equal to height.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> SolidCylinder!(turtle; length = 1.0, width = 1.0, height = 2.0, n = 80);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.SolidFrustum!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomPrimitives.SolidFrustum!","text":"SolidFrustum!(turtle; length = 1.0, width = 1.0, height = 1.0, n = 80, move = false,\nmaterial = nothing, color = nothing)\n\nGenerate a solid frustum in front of the turtle and feed it to a turtle.\n\nArguments\n\nturtle: The turtle that we feed the solid frustum to.\nlength: Length of the ellipse at the base of the solid frustum.\nwidth: Width of the ellipse at the base of the solid frustum.\nheight: Height of the solid frustum.\nn: Number of triangles in the mesh (must be even).\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA mesh will be generated with n triangles that approximate the solid frustum. The frustum will be generated in front of the turtle, with the base on the plane defined by the arm and up axes of the turtle, centered at the head axis. The length argument refers to the up axis, whereas width refers to the arm axis and height is associated to the head axis.\n\nWhen move = true, the turtle will be moved forward by a distance equal to height.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> SolidFrustum!(turtle; length = 1.0, width = 1.0, height = 2.0, n = 80);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.Trapezoid!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomPrimitives.Trapezoid!","text":"Trapezoid!(turtle; length = 1.0, width = 1.0, ratio = 1.0, move = false,\nmaterial = nothing, color = nothing)\n\nGenerate a trapezoid in front of the turtle and feed it to a turtle.\n\nArguments\n\nturtle: The turtle that we feed the trapezoid to.\nlength: Length of the trapezoid.\nwidth: Width of the base of the trapezoid.\nratio: Ratio between the width of the top and base of the trapezoid.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA triangle mesh will be generated representing the trapezoid. The trapezoid will be generated in front of the turtle, on the plane defined by the arm and head axes of the turtle. The argument length refers to the axis of the trapezoid aligned with the head axis of the turtle, whereas width refers to the orthogonal axis.\n\nWhen move = true, the turtle will be moved forward by a distance equal to length.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> Trapezoid!(turtle; length = 1.0, width = 1.0, ratio = 0.5);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.Triangle!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomPrimitives.Triangle!","text":"Triangle!(turtle; length = 1.0, width = 1.0, move = false,\n          material = nothing, color = nothing)\n\nGenerate a triangle in front of the turtle and feed it to a turtle.\n\nArguments\n\nturtle: The turtle that we feed the triangle to.\nlength: Length of the triangle.\nwidth: Width of the triangle.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA triangle mesh will be generated representing the triangle. The triangle will be generated in front of the turtle, on the plane defined by the arm and head axes of the turtle. The argument length refers to the axis of the triangle aligned with the head axis of the turtle, whereas width refers to the orthogonal axis.\n\nWhen move = true, the turtle will be moved forward by a distance equal to length.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> Triangle!(turtle; length = 2.0, width = 1.0);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.Mesh!-Union{Tuple{UT}, Tuple{FT}, Tuple{PlantGeomTurtle.Turtle{FT, UT}, PlantGeomPrimitives.Mesh}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomTurtle.Mesh!","text":"Mesh!(turtle, m::Mesh; scale = Vec(1.0, 1.0, 1.0), move = false,\nmaterial = nothing, color = nothing)\n\nFeed a pre-existing mesh to a turtle after scaling.\n\nArguments\n\nturtle: The turtle that we feed the mesh to.\nm: The pre-existing unscaled mesh in standard position and orientation.\nscale: Vector with scaling factors for the x, y and z axes.\nmove: Whether to move the turtle forward or not (true or false).\nmaterial: The material object for the ray tracer (optional).\ncolor: The color of the ellipse for rendering (optional).\n\nDetails\n\nA pre-existing mesh will be scaled (acccording to scale), rotate so that it is oriented in the same direction as the turtle and translated so that the mesh is generated in front of the turtle. A deep copy of the original mesh is made prior to any transformation.\n\nWhen move = true, the turtle will be moved forward by a distance equal to height.\n\nThe material object must inherit from Material (see ray tracing documentation for detail) and the color can be any type that inherits from Colorant (from ColorTypes.jl).\n\nReturn\n\nReturns nothing but modifies the turtle as a side effect.\n\nExamples\n\njulia> import PlantGeomPrimitives as PG\n\njulia> e = PG.Ellipse();\n\njulia> turtle = Turtle();\n\njulia> Mesh!(turtle, e, scale = PG.Vec(2.0, 2.0, 2.0));\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.arm-Tuple{PlantGeomTurtle.Turtle}","page":"Turtle geometry","title":"PlantGeomTurtle.arm","text":"arm(turtle)\n\nExtract the direction vector (a Vec object) of the arm of the turtle.\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.f!-Union{Tuple{UT}, Tuple{FT}, Tuple{PlantGeomTurtle.Turtle{FT, UT}, FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomTurtle.f!","text":"f!(turtle, dist)\n\nMove turtle forward a given distance.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> f!(turtle, 2.0);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.feed!-Tuple{PlantGeomTurtle.Turtle, AbstractArray}","page":"Turtle geometry","title":"PlantGeomTurtle.feed!","text":"feed!(turtle::Turtle, collection::AbstractArray)\nfeed!(turtle::Turtle, collection::Tuple)\n\nFeed a turtle an array or tuple of objects (collection) with existing feed!() methods.\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.feed!-Tuple{PlantGeomTurtle.Turtle, PlantGraphs.Graph}","page":"Turtle geometry","title":"PlantGeomTurtle.feed!","text":"feed!(turtle::Turtle, g::Graph)\n\nProcess a Graph object with a turtle and generate the corresponding 3D mesh from executing the different feed!() methods associated to the nodes in the graph.\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.feed!-Tuple{PlantGeomTurtle.Turtle, PlantGraphs.Node, Any}","page":"Turtle geometry","title":"PlantGeomTurtle.feed!","text":"feed!(turtle::Turtle, node::Node, vars = nothing)\n\nDefault method for feed!() that does not do anything. This allows the user to include nodes in a graph without an associated geometry.\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.feed!-Tuple{PlantGeomTurtle.Turtle}","page":"Turtle geometry","title":"PlantGeomTurtle.feed!","text":"feed!(turtle::Turtle; mesh::Mesh, color::Colorant = nothing, mat::Material = nothing)\n\nGeneral purpose method to feed a mesh to a turtle together with color and material. Note that all primitives provided by VPL are implemented as meshes, but this is a generic method for meshes that are constructed directly by the user or imported from external software.\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.geoms-Tuple{PlantGeomTurtle.Turtle}","page":"Turtle geometry","title":"PlantGeomTurtle.geoms","text":"geoms(turtle)\n\nExtract the 3D mesh generated by the turtle (a Mesh object).\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.head-Tuple{PlantGeomTurtle.Turtle}","page":"Turtle geometry","title":"PlantGeomTurtle.head","text":"head(turtle)\n\nExtract the direction vector (a Vec object) of the head of the turtle.\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.or!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomTurtle.or!","text":"or!(turtle; head = Z(), up = X(), arm = Y())\n\nOrient a turtle to a new direction by re-defining the local reference system. The arguments head, up and arm should be of type Vec.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> using PlantGeomPrimitives\n\njulia> or!(turtle, head = Y(), up = Z(), arm = X());\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.pos-Tuple{PlantGeomTurtle.Turtle}","page":"Turtle geometry","title":"PlantGeomTurtle.pos","text":"pos(turtle)\n\nExtract the current position of the turtle (a Vec object).\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.ra!-Union{Tuple{UT}, Tuple{FT}, Tuple{PlantGeomTurtle.Turtle{FT, UT}, FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomTurtle.ra!","text":"ra!(turtle, angle)\n\nRotates a turtle around arm axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> ra!(turtle, 45.0);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.rh!-Union{Tuple{UT}, Tuple{FT}, Tuple{PlantGeomTurtle.Turtle{FT, UT}, FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomTurtle.rh!","text":"rh!(turtle, angle)\n\nRotate turtle around head axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> rh!(turtle, 45.0);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.ru!-Union{Tuple{UT}, Tuple{FT}, Tuple{PlantGeomTurtle.Turtle{FT, UT}, FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomTurtle.ru!","text":"ru!(turtle, angle)\n\nRotates a turtle around up axis. Angle must be in hexadecimal degrees and the rotation is clockwise.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> ru!(turtle, 45.0);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.rv!-Union{Tuple{UT}, Tuple{FT}, Tuple{PlantGeomTurtle.Turtle{FT, UT}, FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomTurtle.rv!","text":"rv!(turtle, strength)\n\nRotates the turtle towards the Z axis. The angle of rotation is proportional to the cosine of the zenith angle of the turtle (i.e., angle between its head and the vertical axis) with the absolute value of strength being the proportion between the two. strength should vary between -1 and 1. If strength is negative, the turtle rotates downwards (i.e., towards negative values of Z axis), otherwise upwards.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> ra!(turtle, 45.0);\n\njulia> rv!(turtle, 0.5);\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.set!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomTurtle.set!","text":"set!(turtle; to = O(), head = Z(), up = X(), arm = Y())\n\nSet position and orientation of a turtle. The arguments to, head, up and arm should be of type Vec and be passed as keyword arguments.\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> using PlantGeomPrimitives\n\njulia> set!(turtle, to = O(), head = Y(), up = Z(), arm = X());\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.t!-Union{Tuple{PlantGeomTurtle.Turtle{FT, UT}}, Tuple{UT}, Tuple{FT}} where {FT, UT}","page":"Turtle geometry","title":"PlantGeomTurtle.t!","text":"t!(turtle; to = O())\n\nTranslate a turtle to the new position to (a Vec object).\n\nExamples\n\njulia> turtle = Turtle();\n\njulia> using PlantGeomPrimitives\n\njulia> t!(turtle, to = Y(1.0));\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomTurtle.up-Tuple{PlantGeomTurtle.Turtle}","page":"Turtle geometry","title":"PlantGeomTurtle.up","text":"up(turtle)\n\nExtract the direction vector (a Vec object) of the back of the turtle.\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#Private","page":"Turtle geometry","title":"Private","text":"","category":"section"},{"location":"api/turtle/","page":"Turtle geometry","title":"Turtle geometry","text":"Private functions, types or constants from PlantGeomTurtle. These are not exported, so you need to prefix the function name with PlantGeomPrimitives. to access them. Also bear in mind that these are not part of the public API, so they may change without notice.","category":"page"},{"location":"api/turtle/","page":"Turtle geometry","title":"Turtle geometry","text":"Modules = [PlantGeomTurtle]\nPublic = false\nPrivate = true","category":"page"},{"location":"api/turtle/#PlantGeomPrimitives.Scene-Union{Tuple{PlantGraphs.Graph}, Tuple{FT}, Tuple{PlantGraphs.Graph, Type{FT}}} where FT","page":"Turtle geometry","title":"PlantGeomPrimitives.Scene","text":"Scene(graph, Float64)\n\nCreate a 3D scene from a Graph object (g). By default, double floating precision will be used (Float64) but it is possible to generate a version with a different precision by specifying the corresponding type as in Scene(g, Float32). The Scene object contains a mesh of triangles as well as colors and materials associated to each primitive.\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.Scene-Union{Tuple{Vector{<:PlantGraphs.Graph}}, Tuple{FT}, Tuple{Vector{<:PlantGraphs.Graph}, Type{FT}}} where FT","page":"Turtle geometry","title":"PlantGeomPrimitives.Scene","text":"Scene(graphs, Float64; parallel = false, message = nothing)\n\nCreate a 3D scene for rendering from an array of Graph objects (graphs). The graphs may be processed serially (default) or in parallel using multithreading (parallel = true). By default, double floating precision will be used (Float64) but it is possible to generate a version with a different precision by specifying the corresponding type as in Scene(graphs, Float32).\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.colors-Tuple{PlantGeomTurtle.Turtle}","page":"Turtle geometry","title":"PlantGeomPrimitives.colors","text":"colors(turtle)\n\nExtract the color objects associated to each geometry primitive that was fed to the turtle.\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.faces-Tuple{PlantGeomTurtle.Turtle}","page":"Turtle geometry","title":"PlantGeomPrimitives.faces","text":"geoms(turtle)\n\nExtract the faces of the 3D mesh generated by the turtle.\n\n\n\n\n\n","category":"method"},{"location":"api/turtle/#PlantGeomPrimitives.materials-Tuple{PlantGeomTurtle.Turtle}","page":"Turtle geometry","title":"PlantGeomPrimitives.materials","text":"materials(turtle)\n\nExtract the material objects associated to each geometry primitive that was fed to the turtle.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/algae/#Algae-growth","page":"Algae growth","title":"Algae growth","text":"","category":"section"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"Alejandro Morales","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"In this first example, we learn how to create a Graph and update it dynamically with rewriting rules.","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"The model described here is based on the non-branching model of algae growth proposed by Lindermayer as one of the first L-systems.","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"First, we need to load the VPL metapackage, which will automatically load all the packages in the VPL ecosystem.","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"using VirtualPlantLab","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"The rewriting rules of the L-system are as follows:","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"axiom:   A","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"rule 1:  A rightarrow AB","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"rule 2:  B rightarrow A","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"In VPL, this L-system would be implemented as a graph where the nodes can be of type A or B and inherit from the abstract type Node. It is advised to include type definitions in a module to avoid having to restart the Julia session whenever we want to redefine them. Because each module is an independent namespace, we need to import Node from the VPL package inside the module:","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"module algae\n    import VirtualPlantLab: Node\n    struct A <: Node end\n    struct B <: Node end\nend\nimport .algae","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"Note that in this very example we do not need to store any data or state inside the nodes, so types A and B do not require fields.","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"The axiom is simply defined as an instance of type of A:","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"axiom = algae.A()","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"The rewriting rules are implemented in VPL as objects of type Rule. In VPL, a rewriting rule substitutes a node in a graph with a new node or subgraph and is therefore composed of two parts:","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"A condition that is tested against each node in a graph to choose which nodes to rewrite.\nA subgraph that will replace each node selected by the condition above.","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"In VPL, the condition is split into two components:","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"The type of node to be selected (in this example that would be A or B).\nA function that is applied to each node in the graph (of the specified type) to indicate whether the node should be selected or not. This function is optional (the default is to select every node of the specified type).","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"The replacement subgraph is specified by a function that takes as input the node selected and returns a subgraph defined as a combination of node objects. Subgraphs (which can also be used as axioms) are created by linearly combining objects that inherit from Node. The operation + implies a linear relationship between two nodes and [] indicates branching.","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"The implementation of the two rules of algae growth model in VPL is as follows:","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"rule1 = Rule(algae.A, rhs = x -> algae.A() + algae.B())\nrule2 = Rule(algae.B, rhs = x -> algae.A())","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"Note that in each case, the argument rhs is being assigned an anonymous (aka lambda) function. This is a function without a name that is defined directly in the assigment to the argument. That is, the Julia expression x -> A() + B() is equivalent to the following function definition:","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"function rule_1(x)\n    algae.A() + algae.B()\nend","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"For simple rules (especially if the right hand side is just a line of code) it is easier to just define the right hand side of the rule with an anonymous function rather than creating a standalone function with a meaningful name. However, standalone functions are easier to debug as you can call them directly from the REPL.","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"With the axiom and rules we can now create a Graph object that represents the algae organism. The first argument is the axiom and the second is a tuple with all the rewriting rules:","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"organism = Graph(axiom = axiom, rules = (rule1, rule2))","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"If we apply the rewriting rules iteratively, the graph will grow, in this case representing the growth of the algae organism. The rewriting rules are applied on the graph with the function rewrite!():","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"rewrite!(organism)","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"Since there was only one node of type A, the only rule that was applied was rule1, so the graph should now have two nodes of types A and B, respectively. We can confirm this by drawing the graph. We do this with the function draw() which will always generate the same representation of the graph, but different options are available depending on the context where the code is executed. By default, draw() will create a new window where an interactive version of the graph will be drawn and one can zoom and pan with the mouse (in this online document a static version is shown, see Backends for details):","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"import GLMakie\ndraw(organism)","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"Notice that each node in the network representation is labelled with the type of node (A or B in this case) and a number in parenthesis. This number is a unique identifier associated to each node and it is useful for debugging purposes (this will be explained in more advanced examples).","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"Applying multiple iterations of rewriting can be achieved with a simple loop:","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"for i in 1:4\n    rewrite!(organism)\nend","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"And we can verify that the graph grew as expected:","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"draw(organism)","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"The network is rather boring as the system is growing linearly (no branching) but it already illustrates how graphs can grow rapidly in just a few iterations. Remember that the interactive visualization allows adjusting the zoom, which is handy when graphs become large.","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"","category":"page"},{"location":"tutorials/algae/","page":"Algae growth","title":"Algae growth","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/growthforest/#Growth-forest","page":"Growth forest","title":"Growth forest","text":"","category":"section"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"Alejandro Morales","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"In this example we extend the binary forest example to have more complex, time- dependent development and growth based on carbon allocation. For simplicity, the model assumes a constant relative growth rate at the plant level to compute the biomass increment. In the next example this assumption is relaxed by a model of radiation use efficiency. When modelling growth from carbon allocation, the biomass of each organ is then translated in to an area or volume and the dimensions of the organs are updated accordingly (assuming a particular shape).","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"The following packages are needed:","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"using VirtualPlantLab, ColorTypes\nusing Base.Threads: @threads\nusing Plots\nimport Random\nusing FastGaussQuadrature\nusing Distributions\nRandom.seed!(123456789)","category":"page"},{"location":"tutorials/growthforest/#Model-definition","page":"Growth forest","title":"Model definition","text":"","category":"section"},{"location":"tutorials/growthforest/#Node-types","page":"Growth forest","title":"Node types","text":"","category":"section"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"The data types needed to simulate the trees are given in the following module. The differences with respect to the previous example are:","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"- Meristems do not produce phytomers every day\n- A relative sink strength approach is used to allocate biomass to organs\n- The geometry of the organs is updated based on the new biomass\n- Bud break probability is a function of distance to apical meristem","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"# Data types\nmodule TreeTypes\n    using VirtualPlantLab\n    using Distributions\n    # Meristem\n    Base.@kwdef mutable struct Meristem <: VirtualPlantLab.Node\n        age::Int64 = 0   ## Age of the meristem\n    end\n    # Bud\n    struct Bud <: VirtualPlantLab.Node end\n    # Node\n    struct Node <: VirtualPlantLab.Node end\n    # BudNode\n    struct BudNode <: VirtualPlantLab.Node end\n    # Internode (needs to be mutable to allow for changes over time)\n    Base.@kwdef mutable struct Internode <: VirtualPlantLab.Node\n        age::Int64 = 0         ## Age of the internode\n        biomass::Float64 = 0.0 ## Initial biomass\n        length::Float64 = 0.0  ## Internodes\n        width::Float64  = 0.0  ## Internodes\n        sink::Exponential{Float64} = Exponential(5)\n    end\n    # Leaf\n    Base.@kwdef mutable struct Leaf <: VirtualPlantLab.Node\n        age::Int64 = 0         ## Age of the leaf\n        biomass::Float64 = 0.0 ## Initial biomass\n        length::Float64 = 0.0  ## Leaves\n        width::Float64 = 0.0   ## Leaves\n        sink::Beta{Float64} = Beta(2,5)\n    end\n    # Graph-level variables -> mutable because we need to modify them during growth\n    Base.@kwdef mutable struct treeparams\n        # Variables\n        biomass::Float64 = 2e-3 ## Current total biomass (g)\n        # Parameters\n        RGR::Float64 = 1.0   ## Relative growth rate (1/d)\n        IB0::Float64 = 1e-3  ## Initial biomass of an internode (g)\n        SIW::Float64 = 0.1e6 ## Specific internode weight (g/m3)\n        IS::Float64  = 15.0  ## Internode shape parameter (length/width)\n        LB0::Float64 = 1e-3  ## Initial biomass of a leaf\n        SLW::Float64 = 100.0 ## Specific leaf weight (g/m2)\n        LS::Float64  = 3.0   ## Leaf shape parameter (length/width)\n        budbreak::Float64 = 1/0.5 ## Bud break probability coefficient (in 1/m)\n        plastochron::Int64 = 5 ## Number of days between phytomer production\n        leaf_expansion::Float64 = 15.0 ## Number of days that a leaf expands\n        phyllotaxis::Float64 = 140.0\n        leaf_angle::Float64 = 30.0\n        branch_angle::Float64 = 45.0\n    end\nend\n\nimport .TreeTypes","category":"page"},{"location":"tutorials/growthforest/#Geometry","page":"Growth forest","title":"Geometry","text":"","category":"section"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"The methods for creating the geometry and color of the tree are the same as in the previous example.","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"# Create geometry + color for the internodes\nfunction VirtualPlantLab.feed!(turtle::Turtle, i::TreeTypes.Internode, vars)\n    # Rotate turtle around the head to implement elliptical phyllotaxis\n    rh!(turtle, vars.phyllotaxis)\n    HollowCylinder!(turtle, length = i.length, height = i.width, width = i.width,\n                move = true, color = RGB(0.5,0.4,0.0))\n    return nothing\nend\n\n# Create geometry + color for the leaves\nfunction VirtualPlantLab.feed!(turtle::Turtle, l::TreeTypes.Leaf, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.leaf_angle)\n    # Generate the leaf\n    Ellipse!(turtle, length = l.length, width = l.width, move = false,\n             color = RGB(0.2,0.6,0.2))\n    # Rotate turtle back to original direction\n    ra!(turtle, vars.leaf_angle)\n    return nothing\nend\n\n# Insertion angle for the bud nodes\nfunction VirtualPlantLab.feed!(turtle::Turtle, b::TreeTypes.BudNode, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.branch_angle)\nend","category":"page"},{"location":"tutorials/growthforest/#Development","page":"Growth forest","title":"Development","text":"","category":"section"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"The meristem rule is now parameterized by the initial states of the leaves and internodes and will only be triggered every X days where X is the plastochron.","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"# Create right side of the growth rule (parameterized by the initial states\n# of the leaves and internodes)\nfunction create_meristem_rule(vleaf, vint)\n    meristem_rule = Rule(TreeTypes.Meristem,\n                        lhs = mer -> mod(data(mer).age, graph_data(mer).plastochron) == 0,\n                        rhs = mer -> TreeTypes.Node() +\n                                     (TreeTypes.Bud(),\n                                     TreeTypes.Leaf(biomass = vleaf.biomass,\n                                                    length  = vleaf.length,\n                                                    width   = vleaf.width)) +\n                                     TreeTypes.Internode(biomass = vint.biomass,\n                                                         length  = vint.length,\n                                                         width   = vint.width) +\n                                     TreeTypes.Meristem())\nend","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"The bud break probability is now a function of distance to the apical meristem rather than the number of internodes. An adhoc traversal is used to compute this length of the main branch a bud belongs to (ignoring the lateral branches).","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"# Compute the probability that a bud breaks as function of distance to the meristem\nfunction prob_break(bud)\n    # We move to parent node in the branch where the bud was created\n    node =  parent(bud)\n    # Extract the first internode\n    child = filter(x -> data(x) isa TreeTypes.Internode, children(node))[1]\n    data_child = data(child)\n    # We measure the length of the branch until we find the meristem\n    distance = 0.0\n    while !isa(data_child, TreeTypes.Meristem)\n        # If we encounter an internode, store the length and move to the next node\n        if data_child isa TreeTypes.Internode\n            distance += data_child.length\n            child = children(child)[1]\n            data_child = data(child)\n        # If we encounter a node, extract the next internode\n        elseif data_child isa TreeTypes.Node\n                child = filter(x -> data(x) isa TreeTypes.Internode, children(child))[1]\n                data_child = data(child)\n        else\n            error(\"Should be Internode, Node or Meristem\")\n        end\n    end\n    # Compute the probability of bud break as function of distance and\n    # make stochastic decision\n    prob =  min(1.0, distance*graph_data(bud).budbreak)\n    return rand() < prob\nend\n\n# Branch rule parameterized by initial states of internodes\nfunction create_branch_rule(vint)\n    branch_rule = Rule(TreeTypes.Bud,\n            lhs = prob_break,\n            rhs = bud -> TreeTypes.BudNode() +\n                         TreeTypes.Internode(biomass = vint.biomass,\n                                             length  = vint.length,\n                                             width   = vint.width) +\n                         TreeTypes.Meristem())\nend","category":"page"},{"location":"tutorials/growthforest/#Growth","page":"Growth forest","title":"Growth","text":"","category":"section"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"We need some functions to compute the length and width of a leaf or internode from its biomass","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"function leaf_dims(biomass, vars)\n    leaf_biomass = biomass\n    leaf_area    = biomass/vars.SLW\n    leaf_length  = sqrt(leaf_area*4*vars.LS/pi)\n    leaf_width   = leaf_length/vars.LS\n    return leaf_length, leaf_width\nend\n\nfunction int_dims(biomass, vars)\n    int_biomass = biomass\n    int_volume  = biomass/vars.SIW\n    int_length  = cbrt(int_volume*4*vars.IS^2/pi)\n    int_width   = int_length/vars.IS\n    return int_length, int_width\nend","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"Each day, the total biomass of the tree is updated using a simple RGR formula and the increment of biomass is distributed across the organs proportionally to their relative sink strength (of leaves or internodes).","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"The sink strength of leaves is modelled with a beta distribution scaled to the leaf_expansion argument that determines the duration of leaf growth, whereas for the internodes it follows a negative exponential distribution. The pdf function computes the probability density of each distribution which is taken as proportional to the sink strength (the model is actually source-limited since we imposed a particular growth rate).","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"sink_strength(leaf, vars) = leaf.age > vars.leaf_expansion ? 0.0 :\n                            pdf(leaf.sink, leaf.age/vars.leaf_expansion)/100.0\nplot(0:1:50, x -> sink_strength(TreeTypes.Leaf(age = x), TreeTypes.treeparams()),\n     xlabel = \"Age\", ylabel = \"Sink strength\", label = \"Leaf\")\n\nsink_strength(int) = pdf(int.sink, int.age)\nplot!(0:1:50, x -> sink_strength(TreeTypes.Internode(age = x)), label = \"Internode\")","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"Now we need a function that updates the biomass of the tree, allocates it to the different organs and updates the dimensions of said organs. For simplicity, we create the functions leaves() and internodes() that will apply the queries to the tree required to extract said nodes:","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"get_leaves(tree) = apply(tree, Query(TreeTypes.Leaf))\nget_internodes(tree) = apply(tree, Query(TreeTypes.Internode))","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"The age of the different organs is updated every time step:","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"function age!(all_leaves, all_internodes, all_meristems)\n    for leaf in all_leaves\n        leaf.age += 1\n    end\n    for int in all_internodes\n        int.age += 1\n    end\n    for mer in all_meristems\n        mer.age += 1\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"The daily growth is allocated to different organs proportional to their sink strength.","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"function grow!(tree, all_leaves, all_internodes)\n    # Compute total biomass increment\n    tvars = data(tree)\n    ΔB    = tvars.RGR*tvars.biomass\n    tvars.biomass += ΔB\n    # Total sink strength\n    total_sink = 0.0\n    for leaf in all_leaves\n        total_sink += sink_strength(leaf, tvars)\n    end\n    for int in all_internodes\n        total_sink += sink_strength(int)\n    end\n    # Allocate biomass to leaves and internodes\n    for leaf in all_leaves\n        leaf.biomass += ΔB*sink_strength(leaf, tvars)/total_sink\n    end\n    for int in all_internodes\n        int.biomass += ΔB*sink_strength(int)/total_sink\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"Finally, we need to update the dimensions of the organs. The leaf dimensions are","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"function size_leaves!(all_leaves, tvars)\n    for leaf in all_leaves\n        leaf.length, leaf.width = leaf_dims(leaf.biomass, tvars)\n    end\n    return nothing\nend\nfunction size_internodes!(all_internodes, tvars)\n    for int in all_internodes\n        int.length, int.width = int_dims(int.biomass, tvars)\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/growthforest/#Daily-step","page":"Growth forest","title":"Daily step","text":"","category":"section"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"All the growth and developmental functions are combined together into a daily step function that updates the forest by iterating over the different trees in parallel.","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"get_meristems(tree) = apply(tree, Query(TreeTypes.Meristem))\nfunction daily_step!(forest)\n    @threads for tree in forest\n        # Retrieve all the relevant organs\n        all_leaves = get_leaves(tree)\n        all_internodes = get_internodes(tree)\n        all_meristems = get_meristems(tree)\n        # Update the age of the organs\n        age!(all_leaves, all_internodes, all_meristems)\n        # Grow the tree\n        grow!(tree, all_leaves, all_internodes)\n        tvars = data(tree)\n        size_leaves!(all_leaves, tvars)\n        size_internodes!(all_internodes, tvars)\n        # Developmental rules\n        rewrite!(tree)\n    end\nend","category":"page"},{"location":"tutorials/growthforest/#Initialization","page":"Growth forest","title":"Initialization","text":"","category":"section"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"The trees are initialized in a regular grid with random values for the initial orientation and RGR:","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"RGRs = rand(Normal(0.3,0.01), 10, 10)\nhistogram(vec(RGRs))\n\norientations = [rand()*360.0 for i = 1:2.0:20.0, j = 1:2.0:20.0]\nhistogram(vec(orientations))\n\norigins = [Vec(i,j,0) for i = 1:2.0:20.0, j = 1:2.0:20.0];","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"The following initalizes a tree based on the origin, orientation and RGR:","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"function create_tree(origin, orientation, RGR)\n    # Initial state and parameters of the tree\n    vars = TreeTypes.treeparams(RGR = RGR)\n    # Initial states of the leaves\n    leaf_length, leaf_width = leaf_dims(vars.LB0, vars)\n    vleaf = (biomass = vars.LB0, length = leaf_length, width = leaf_width)\n    # Initial states of the internodes\n    int_length, int_width = int_dims(vars.LB0, vars)\n    vint = (biomass = vars.IB0, length = int_length, width = int_width)\n    # Growth rules\n    meristem_rule = create_meristem_rule(vleaf, vint)\n    branch_rule   = create_branch_rule(vint)\n    axiom = T(origin) + RH(orientation) +\n            TreeTypes.Internode(biomass = vint.biomass,\n                             length  = vint.length,\n                             width   = vint.width) +\n            TreeTypes.Meristem()\n    tree = Graph(axiom = axiom, rules = (meristem_rule, branch_rule),\n                 data = vars)\n    return tree\nend","category":"page"},{"location":"tutorials/growthforest/#Visualization","page":"Growth forest","title":"Visualization","text":"","category":"section"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"As in the previous example, it makes sense to visualize the forest with a soil tile beneath it. Unlike in the previous example, we will construct the soil tile using a dedicated graph and generate a Scene object which can later be merged with the rest of scene generated in daily step:","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"Base.@kwdef struct Soil <: VirtualPlantLab.Node\n    length::Float64\n    width::Float64\nend\nfunction VirtualPlantLab.feed!(turtle::Turtle, s::Soil, vars)\n    Rectangle!(turtle, length = s.length, width = s.width, color = RGB(255/255, 236/255, 179/255))\nend\nsoil_graph = RA(-90.0) + T(Vec(0.0, 10.0, 0.0)) + # Moves into position\n             Soil(length = 20.0, width = 20.0) # Draws the soil tile\nsoil = Scene(Graph(axiom = soil_graph));\nrender(soil, axes = false)","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"And the following function renders the entire scene (notice that we need to use display() to force the rendering of the scene when called within a loop or a function):","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"function render_forest(forest, soil)\n    scene = Scene(vec(forest)) # create scene from forest\n    scene = Scene([scene, soil]) # merges the two scenes\n    render(scene)\nend","category":"page"},{"location":"tutorials/growthforest/#Retrieving-canopy-level-data","page":"Growth forest","title":"Retrieving canopy-level data","text":"","category":"section"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"We may want to extract some information at the canopy level such as LAI. This is best achieved with a query:","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"function get_LAI(forest)\n    LAI = 0.0\n    @threads for tree in forest\n        for leaf in get_leaves(tree)\n            LAI += leaf.length*leaf.width*pi/4.0\n        end\n    end\n    return LAI/400.0\nend","category":"page"},{"location":"tutorials/growthforest/#Simulation","page":"Growth forest","title":"Simulation","text":"","category":"section"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"We can now create a forest of trees on a regular grid:","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"forest = create_tree.(origins, orientations, RGRs);\nrender_forest(forest, soil)\nfor i in 1:50\n    daily_step!(forest)\nend\nrender_forest(forest, soil)","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"And compute the leaf area index:","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"get_LAI(forest)","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"","category":"page"},{"location":"tutorials/growthforest/","page":"Growth forest","title":"Growth forest","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/Raytracer/#manual_raytracer","page":"Ray tracing","title":"Ray tracing","text":"","category":"section"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Alejandro Morales","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"manual/Raytracer/#Overview","page":"Ray tracing","title":"Overview","text":"","category":"section"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"VPL offers a built-in ray tracer that can be used to simulate the distribution of irradiance within a 3D scene. It is a Monte Carloy ray tracer written 100% in Julia with the following features:","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Multiple wavelengths.\nMost common types of materials and radiation sources are provided, but additional ones can be added by the user.\nSupport for multi-threaded execution.\nAn Bounding Volume Hierarchy to speed up the computation.\nA grid cloner that duplicates (implicitly) the scene in a grid to approximate large canopies.\nA Russian roulette mechanism to reduce the number of iterations per ray needed while avoiding introducing biases in the computations.","category":"page"},{"location":"manual/Raytracer/#How-ray-tracing-works","page":"Ray tracing","title":"How ray tracing works","text":"","category":"section"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Rays are generated from the radiation soures. A ray is defined by an origin, a direction and a ray payload that contains the radiant power per wavelength (this would usually be W or umol/s, but the ray tracer is agnostic with respect to units). Ray tracing is a recursive process in which a ray is traced through the scene (by testing whether the ray intersects different parts of the scenes and triangles in it) until it either hits a triangle in a mesh or leaves the scene through its boundaries.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"When a ray hits a triangle inside a mesh, the ray is modified according to the Material object associated to that triangle (see below). In most cases this would result in a new ray being generated (either as reflected or transmitted radiation) which is then traced. Also, in most cases, a fraction of the radiant power carried by the ray will be transferred to the Material object.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"The recursive nature of the ray tracer allows simulating scattering within the scene and, if multiple wavelengths are used and optical properties vary per wavelength, also changes in the spectral composition of the radiation (e.g., red/far red). As the rays are scattered, their radiant power decreases such that at some point it is not worth tracing them any further. The user can control the maximum number of iterations per ray after which termination may be considered (this is maxiter in PlantRayTracer.RTSettings).","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"If maxiter = 1, the ray tracer will effectively behave as a ray caster, meaning than only primary rays are traced (e.g., for a field crop, this means that only direct and diffuse radiation will be simulated, not the scattered component).","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Once maxiter is reached though, the ray is not guaranteed to be terminated. The reason is that terminating all rays will introduce a bias in the results (i.e., total radiation in the scene will be underestimated), especially when a large number of raus is simulated. To avoid this, VPL implements a Russian roulette mechanism that will terminate a ray with a probability (pkill) and increase the payload of the rays that survive. This introduces variance","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"The ray tracer supports the construction of a bounding volume hierarchy (BVH) that can be used to speed up the computations (by minimizing the number of ray triangle intersections), especially for scenes with a  large number of triangles. The BVH is constructed automatically (see below) but the user can specific some settings to control its construction. It is also possible to turn off this structure altogether, in which case all rays will be tested against all triangles.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"In order to simulate large canopies, VPL implements a grid cloner that will duplicated (with minimum memory and computational overhead) the scene in a grid along the different axes. This is particularly useful for reducing edge effects without having to simulate a large number of plants (see below for details).","category":"page"},{"location":"manual/Raytracer/#Usage","page":"Ray tracing","title":"Usage","text":"","category":"section"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"To use ray tracing the user will need to define a Scene object (see PlantGeomPrimitives.Scene) and the radiation sources (see below) which are then combined with RayTracer(). This results in a Raytracer object that contains all the necessary information to perform the ray tracing. To actually execute the ray tracing the user will need to call trace!() on this object.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Executing the ray tracer will return the total number of rays that were tracer (including secondary rays) but the most important change is that radiant power stored in the Material objects in the scene will be updated automatically. This means that the user will need to store the Material objects in a data structure that is accesible (e.g., within a node in a graph).","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Most of the settings for the ray tracer are defined in the RTSettings object which is passed to RayTracer() when creating the ray tracer. These settings include maxiter and pkill for the Russian roulette, the settings for the grid cloner and whether the tracing should be run in parallel or not.","category":"page"},{"location":"manual/Raytracer/#Radiation-sources","page":"Ray tracing","title":"Radiation sources","text":"","category":"section"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"VPL define radiation sources as a combination of of a geometry component and an angle component. The geometry component determines where are the rays being generated, whereas the angle component determines the direction of the rays. Each radiation source is thus constructed by specifying the geometry and the angle, plus the number of rays and radiant power per wavelength to be stored in the ray. See documentation on PlantRayTracer.Source for more details.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"The followig geometry components are available in VPL:","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"PointSource: All rays are generated from a single point in space.\nLineSource: All rays are generated from a line in space.\nAreaSource: All rays are generated from the surface of a user-defined mesh.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"The following angle components are available in VPL:","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"FixedSource: All rays have the same direction.\nLambertianSource: The direction of the rays follows Lambert's cosine law.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"This means that the irradiance is the same when viewed from any angle.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"A special type of radiation source is the DirectionalSource which is used to simulate solar radiation. Rays from this source are generated from the upper face of the scene bounding box and their direction is defined in polar coordinates (i.e., by a zenith and azimuth angle). Because of the way directional sources are implemented it is recommended that a grid cloner is used (this is the default) as otherwise there will parts of the scene that will recieve no rays. See documentation on PlantRayTracer.DirectionalSource for more details.","category":"page"},{"location":"manual/Raytracer/#Materials","page":"Ray tracing","title":"Materials","text":"","category":"section"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Several types of materials are available for ray tracing, which all inherit from the Material abstract type. The materials play two roles: (i) they define the optical properties of the surface (i.e., reflectance and transmittance) for the different wavelengths being simulated, and (ii) store the radiant power absorbed by the surface. If the radiant power of a surface is needed, it is important that the material object is stored in a data structure that the user can have access to (e.g., within a node in a graph) as the raytracer will simply modify in-place (without creating a copy) the material object when a ray is absorbed. The radiant power in a material can be retrieved by applying power() to the object.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Materials are added to the scene at ther same time as the geometry either via feed() or add!(). It is possible to add one material per mesh (in which case all triangles within that mesh will share the same material object) or one material per triangle. In either case, VPL will take care of creating the corresponding association between the material and the triangles.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"VPL will not check that the number of wavelengths in the material matches the equivalent number in the radiation source or that the same ordering is used. This is entirely up to the user.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"The following material types are available in VPL:","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Black: A material that absorbs all the rays that hit it (equivalent to no","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"reflectance or transmittance). It is not a realistic material but it is useful for debugging purposes or for special uses of a ray tracer (e.g., to compute ground cover).","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Sensor: A material that registers the rays that hit and their radian power","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"but it does not alter the radiant power or the direction of the rays themselves. This is useful for measuring the distribution of irradiance within canopy without disturbing the system. Note that a Sensor will not add to the scattering counter either so there is no need to modify the settings of the Russian roulette.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Lambertian: A material that describes a perfect diffuser with user-defined","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"reflectance and transmittance per wavelength.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Phong: A modified Phong material that implements the equations by","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Lafortune & Willems (1994). Reflectance is modelled as a combination of a diffuse and a specular component per wavelength.","category":"page"},{"location":"manual/Raytracer/#Acceleration-of-ray-tracing","page":"Ray tracing","title":"Acceleration of ray tracing","text":"","category":"section"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"In order to accelerate the tracing of rays within the 3D scene, a bounding volume hierarchy may be used by setting acceleration = BVH in the call to RayTracer(). This will create a series of nested axis-aligned bounding boxes organized as a binary tree. The purpose of this structure is to reduce the number of triangles that need to be tested against each ray (i.e., if a ray does not intersect a particular box, it will not intersect any of the triangles inside of it). This does add some additional cost due to the need to test the intersection of rays against the bounding boxes, but ideally this is much less than the cost of testing against all the excluded triangles.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"The tree is constructed by recursively splitting each box into two halves and allocating the different triangles in the mesh to the corresponding boxes. Two rules are available for splitting the boxes, which must also be specified in the call to RayTracer():","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"rule = AvgSplit(N, L): It splits each node along the longest axis at the","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"average coordinate of the triangles in the node. The splitting is repeated until the number of triangles in a node is lessor equal than N or the total number of recursive splits (i.e., the depth of the binary tree) reaches L.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"rule = SAH{K}(N, L): It splits each node using the Surface Area Heuristic","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"that defines the expected computation of ray tracing a splitted node versus not doing it. This method computes the cost of splitting each box along each of its three axes at different positions given by the value K. When K = 1 the split occurs at the median of the triangles in the box. For K > 1 the splits occur at different quantiles of the triangles in the box. The splitting is repeated until the number of triangles in a node is lessor equal than N or the total number of recursive splits reaches L or the cost of splitting a node exceeds the cost of not splitting it.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"For debugging purposes (or for very small scenes), the user may also specify acceleration = Naive which will basically not implement any acceleration structured and all rays will be tested against all triangles.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"The acceleration structure is created from a Scene object via the accelerate() function, and allows specifying the acceleration and rule arguments. This will also be responsible of translating the triangular mesh into the data structure used by the ray tracer (triangles in barycentric coordinates) as well as fitting a grid cloner to the scene (see below).","category":"page"},{"location":"manual/Raytracer/#Grid-cloner-for-edge-effects","page":"Ray tracing","title":"Grid cloner for edge effects","text":"","category":"section"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"The grid cloner is used to minimize border effects when tracing rays from the sources towards the scene. The grid cloner is a form of geometric instancing where the same scene is repeated multiple times along the X, Y or Z direction. In practice, to avoid excessive memory usage, the scene is not actually replicated but rather the rays positions are modified to emulate the effect of the scene being repeated.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"In order a grid cloner structure on top of a scene, the user needs to specify the number of duplications to perform in each direction (nx, ny and nz) as well as the offsets between the different copies (dx, dy and dz). The grid cloner is created from a Scene object via the accelerate() function, but the settings to control the grid cloner must be set when creating the RTSettings object.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"By default, the grid cloner is enabled in the X and Y directions by replicating the scene three times in each direction (this means creating a grid of 7 x 7 = 49 copies of the scene including the original). The offsets between the copies are set by default to width of the scene in the X and Y directions such that there is no overlapping. The grid cloner is disabled in the Z direction by default.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"Note that whereas a grid cloner will not increase significantly the memory used by the ray tracer, it will increase ray tracing times as fewer rays will be able to leave the scene. On the other hand, a small (or no) grid cloner will create an edge effect such that only plants in the center of the scene will be able to capture the behaviour within a large canopy.","category":"page"},{"location":"manual/Raytracer/","page":"Ray tracing","title":"Ray tracing","text":"The actual number of copies to use will depend on plant dimension and solar angles, so a general recommendation is not possible. Regarding the offsets, these would be related to the sowing/planting pattern in the case of plant production systems on a regular grid and in many case this would mean that the copies overlap (and this would be correct) so the defaults should be overriden in most cases. Using a grid cloner should not be substitute for using a sufficient number of plants in the scene in order to capture the plant-to-plant variability, but simply to avoid edge effects.","category":"page"},{"location":"manual/Julia/#manual_julia","page":"Julia basic concepts","title":"Julia basic concepts","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Alejandro Morales","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"manual/Julia/#Introduction","page":"Julia basic concepts","title":"Introduction","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"This is not a tutorial or introduction to Julia, but a collection of basic concepts about Julia that are particularly useful to understand VPL.  It is assumed that the reader has some experience with programming in other languages, such as Matlab, R or Python. These concepts should be complemented with general introductory material about Julia, which can be found at the official Julia website.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Julia is a dynamic, interactive programming language, like Matlab, R or Python. Thus, it is very easy to use and learn incrementally. The language is young and well-designed, with an emphasis on numerical/scientific computation, although it is starting to occupy some space in areas such as data science and machine learning. It has a clear syntax and better consistency than some older programming languages.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Unlike Matlab, R or Python, Julia was designed from the beginning to be fast (as fast as statically compiled languages like C, C++ or Fortran). However, achieving this goal does require paying attention to certain aspects of the language, such as type stability and dynamic memory allocation, which are not always obvious to the user coming from other scientific dynamic languages. In the different sections below, a few basic Julia concepts are presented, first by ignoring performance considerations and focusing on syntax, and then by showing how to improve the performance of the code. Some concepts are ignored as they are not deemed relevant for the use of VPL.","category":"page"},{"location":"manual/Julia/#Running-Julia","page":"Julia basic concepts","title":"Running Julia","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"There are different ways of executing Julia code (most popular ones are VS Code and Jupyter notebook):","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Interactive Julia console from terminal/console (REPL)\nPlugins for code editors\nVisual Studio Code (most popular)\nAtom/Juno (less popular now)\nvim, Emacs and others (less popular)\nCode cells inside a Jupyter notebook\nCode cells inside Pluto notebook (a Julia implementation of a reactive notebook)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"The first time in a Julia session that a method is called, it will take extra time as the method will have to be compiled (i.e. Julia uses a Just-in-Time compiler as opposed to an interpreter). Also, the first time you load a package after installation/update it will take extra time to load due to precompilation (this reduces JIT compilation times somewhat). Moreover, code editors and notebooks may need to run additional code to achieve their full functionality, which may add some delays in executing the code.","category":"page"},{"location":"manual/Julia/#Basic-concepts","page":"Julia basic concepts","title":"Basic concepts","text":"","category":"section"},{"location":"manual/Julia/#Functions","page":"Julia basic concepts","title":"Functions","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"A function is defined with the following syntax.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"function foo(x)\n    x^2\nend\nfoo(2.0)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Very short functions can also be defined in one line","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"foo2(x) = x^2","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"foo2(2.0)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Functions can also be defined with the \"to\" syntax. The result can be assigned to any variable.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"foo3 = x -> x^2","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"foo3(2.0)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"A begin - end block can be used to store a sequence of statements in multiple lines and assign them to \"short function or a \"to function.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"foo4 = begin\n    x -> x^2\nend","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"foo4(2.0)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Once created, there is no difference among foo, foo2, foo3 and foo4.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Anonymous functions are useful when passing a function to another function as argument. For example, the function bar below allows applying any function f to an argument x. In this case we could pass any of the variables defined above, or just create an anonymous function in-place.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"function bar(x, f)\n    f(x)\nend\nbar(2.0, x -> x^2)","category":"page"},{"location":"manual/Julia/#Types","page":"Julia basic concepts","title":"Types","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"A Type in Julia is a data structure that can contain one or more fields. Types are used to keep related data together, and to select the right method implementation of a function (see below). It shares some properties of Classes in Object-Oriented Programming, but there are also important differences.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Julia types can be immutable or mutable.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Immutable means that, once created, the fields of an object cannot be changed. They are defined with the following syntax:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"struct Point\n  x\n  y\n  z\nend","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"p = Point(0.0, 0.0, 0.0)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"p.x = 1.0","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Mutable means that the fields of an object can be modified after creation. The definition is similar, just needs to add the keyword mutable","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"mutable struct mPoint\n  x\n  y\n  z\nend","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"mp = mPoint(0.0, 0.0, 0.0)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"mp.x = 1.0\nmp","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"We can always check the type of object with the function typeof","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"typeof(p)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"If you forget the fields of a type, try to use fieldnames in the type (not the object). It will return the name of all the fields it contains (the \":\" in front of each name can be ignored)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"fieldnames(Point)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Note that, for performance reasons, the type of each field should be annotated in the type definition as in:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"struct pPoint\n  x::Float64\n  y::Float64\n  z::Float64\nend\npPoint(1.0, 2.0, 3.0)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Also, note that there are no private fields in a Julia type (like Python, unlike C++ or Java).","category":"page"},{"location":"manual/Julia/#Methods","page":"Julia basic concepts","title":"Methods","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Methods are functions with the same name but specialized for different types.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Methods are automatically created by specifying the type of (some of) the arguments of a function, like in the following example","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"function dist(p1::pPoint, p2::pPoint)\n    dx = p1.x - p2.x\n    dy = p1.y - p2.y\n    dz = p1.z - p2.z\n    sqrt(dx^2 + dy^2 + dz^2)\nend","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"p1 = pPoint(1.0, 0.0, 0.0)\np2 = pPoint(0.0, 1.0, 0.0)\ndist(p1, p2)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Note that this function will not work for mPoints","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"mp1 = mPoint(1.0, 0.0, 0.0)\nmp2 = mPoint(0.0, 1.0, 0.0)\ndist(mp1, mp2)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"So we need to define dist for mPoint as arguments, or use inheritance (see below).","category":"page"},{"location":"manual/Julia/#Abstract-types","page":"Julia basic concepts","title":"Abstract types","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Types cannot inherit from other types.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"However, when multiple types share analogous functionality, it is possible to group them by \"abstract types\" from which they can inherit. Note that abstract types do not contain any fields, so inheritance only works for methods. \"abstract types are defined by how they act\" (C. Rackauckas)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"For example, we may define an abstract type Vec3 as any type for which a distance (dist) can be calculated. The default implementation assumes that the type contains fields x, y and z, though inherited methods can always be overridden.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Inheritance is indicated by the \"<:\" syntax after the name of the type in its declaration.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"# Vec3 contains no data, but dist actually assumes that x, y and z are fields of any type inheriting from Vec3\nabstract type Vec3 end\nfunction dist(p1::Vec3, p2::Vec3)\n    dx = p1.x - p2.x\n    dy = p1.y - p2.y\n    dz = p1.z - p2.z\n    sqrt(dx^2 + dy^2 + dz^2)\nend\n# Like before, but inhering from Vec3\nstruct Point2 <: Vec3\n  x::Float64\n  y::Float64\n  z::Float64\nend\nmutable struct mPoint2 <: Vec3\n  x::Float64\n  y::Float64\n  z::Float64\nend\nstruct Point3 <: Vec3\n  x::Float64\n  y::Float64\nend","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"The method now works with Point2 and mPoint2","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"p1 = Point2(1.0, 0.0, 0.0)\np2 = Point2(0.0, 1.0, 0.0)\ndist(p1, p2)\nmp1 = mPoint2(1.0, 0.0, 0.0)\nmp2 = mPoint2(0.0, 1.0, 0.0)\ndist(mp1, mp2)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"The method will try to run with Point3 but it will raise an error because Point3 does not have the field z.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"p3 = Point3(1.0, 0.0)\ndist(p1, p3)","category":"page"},{"location":"manual/Julia/#Optional-and-keyword-arguments","page":"Julia basic concepts","title":"Optional and keyword arguments","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Functions can have optional arguments (i.e. arguments with default values) as well as keyword arguments, which are like optional arguments but you need to use their name (rather than position) to assign a value.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"An example of a function with optional arguments:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"opfoo(a, b::Int = 0) = a + b\nopfoo(1)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"opfoo(1,1)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"An example of a function with keyword arguments","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"kwfoo(a; b::Int = 0) = a + b\nkwfoo(1)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"kwfoo(1, b = 1)","category":"page"},{"location":"manual/Julia/#Modules","page":"Julia basic concepts","title":"Modules","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Within a Julia session you cannot redefine Types. Also, if you assign different data to the same name, it will simply overwrite the previous data (note: these statements are simplifications of what it actually happens, but it suffices for now).","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"To avoid name clashes, Julia allows collecting functions, methods, types and abstract types into Modules. Every Julia package includes at least one module.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"A module allows exporting a subset of the the names defined inside of it:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"module Mod\n\nexport fooz\n\nfooz(x) = abs(x)\n\nstruct bar\n   data\nend\n\nend","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"In order to use a module the using command must be used (the . is required and indicates that the module was defined in the current scoppe, as modules can be nested).","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"using .Mod","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Exportednames can be used directly","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"fooz(-1)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Unexported names can still be retrieved, but must be qualified by the module name.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"b = Mod.fooz(-1.0)","category":"page"},{"location":"manual/Julia/#Adding-methods-to-existing-functions","page":"Julia basic concepts","title":"Adding methods to existing functions","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"If a function is defined inside a module (e.g., a Julia package) we can add methods to that function by accessing it through the module name. Let's define a function abs_dist that calculates the Manhattan (as opposed to Euclidean) distance between two points. We will put it inside a module called Funs to emulate a Julia package.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"module Funs\n  export manhattan\n  function manhattan(p1, p2)\n      dx = p1.x - p2.x\n      dy = p1.y - p2.y\n      dz = p1.z - p2.z\n      abs(dx + dy + dz)\n  end\nend\nusing .Funs\nmanhattan(p1, p2)\nmanhattan(p1, p3)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"We see that we have the same error as before when using p3. Let's add methods for when one the first or second argument is a Point3 that ignores the z:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Funs.manhattan(p1::Point3, p2) = abs(p1.x - p2.x + p1.y - p2.y)\nFuns.manhattan(p1, p2::Point3) = abs(p1.x - p2.x + p1.y - p2.y)\nmanhattan(p1, p3)\nmanhattan(p3, p1)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"You can find all the methods of a function by using methods() on the function name:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"methods(manhattan)","category":"page"},{"location":"manual/Julia/#Macros","page":"Julia basic concepts","title":"Macros","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"A macro is a function or statement that starts with @. The details of macros are not explained here, but it is important to know that they work by modifying the code that you write inside the macro, usually to provided specific features or to achieve higher performance. That is, a macro will take the code that you write and substitute it by some new code that then gets executed.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"An useful macro is @kwdef provided by the module Base, which allows assigning default values to the fields of a type and use the fields as keyword arguments in the constructors. This macro needs to be written before the type definition. For example, a point constructed in this manner would be:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Base.@kwdef struct kwPoint\n    x::Float64 = 0.0\n    y::Float64 = 0.0\n    z::Float64 = 0.0\nend\nkwPoint()\nkwPoint(1,1,1)\nkwPoint(y = 1)","category":"page"},{"location":"manual/Julia/#Dot-notation","page":"Julia basic concepts","title":"Dot notation","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Dot notation is a very useful feature of Julia that allows you to apply a function to each element of a vector. For example, if you want to calculate the square of each element of a vector you can do:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"x = [1,2,3]\ny = x.^2","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"The dot notation can be used with any function, not just mathematical functions. For example, if you want to calculate the absolute value of each element of a vector you can do:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"abs.(y)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"If the operation is more complex, the '.' should be used in all the steps or, alternatively, use the macro @. that does the same:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"abs.(y) .+ x.^3\n@. abs(y) + x^3","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"The dot notation can also be used with functions that take more than one argument, but make sure that all the arguments have the same length","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"min.(x, y)\nmax.(x, y)","category":"page"},{"location":"manual/Julia/#Improving-performance","page":"Julia basic concepts","title":"Improving performance","text":"","category":"section"},{"location":"manual/Julia/#Type-instability","page":"Julia basic concepts","title":"Type instability","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"As indicated above, annotating the fields of a data type (struct or mutable struct) is required for achieve good performance. However, neither arguments of functions nor variables created through assignment require type annotation. This is because Julia uses type inference (i.e. it tries to infer the type of data to be stored in each newly created varaible) and compiles the code to machine level based on this inference. This leads to the concept of type instability: if the type of data stored in a variable changes over time, the compiler will need to accomodate for this, which results (for technical reasons beyond the scope of this document) in a loss of performance.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Here is a classic example of type instability. The following function will add up the squares of all the values in a vector:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"function add_squares(x)\n  out = 0\n  for i in eachindex(x)\n    out += x[i]^2\n  end\n  return out\nend","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"It looks innocent enough. The issue here is that out is initialized as an integer (0), but then it is assigned the result of sqrt(x), which may be a real value (e.g. 1.0), which would have to be stored as a floating point number. Because out has different types at different points in the code, the resulting code will be slower than it could be, but still correct (this is why Julia is useful for rapid code development compared to static languages like C++ or Java).","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"add_squares(collect(1:1000)) # type stable\nadd_squares(collect(1:1000.0)) # not type stable","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"How do we measure performance then? The @time macro is useful for this if dealing with a slow function. Otherwise it is better to use @btime from the BenchmarkTools package (see documentation of the package to understand why we use $).","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"using BenchmarkTools\nv1 = collect(1:1000)\nv2 = collect(1:1000.0)\n@btime add_squares($v1)\n@btime add_squares($v2)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"The second code is 12 times slower than the first one. We can detect type instability by using the @code_warntype macro. This macro will print a internal representation of the code before it is compiled. The details are complex, but you just need to look for things in red (which indicate type instability).","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"@code_warntype add_squares(v1)\n@code_warntype add_squares(v2)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"How do we fix this? We could write different methods for different types of x, but this is not very practical. Instead, we can use the zero() function combined with eltype() to initialize out with the correct type.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"function add_squares(x)\n  out = zero(eltype(x)) # Initialize out with the correct type with value of zero\n  for i in eachindex(x)\n    out += x[i]^2\n  end\n  return out\nend","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"You could also initialize out to the first element of x and iterate over the rest of the elements, but this may not always possible (e.g. if x is empty or has one value only), so the logic will get more complex.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Now the code is type stable:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"@code_warntype add_squares(v1)\n@code_warntype add_squares(v2)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"And the performance is more similar:","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"@btime add_squares($v1)\n@btime add_squares($v2)","category":"page"},{"location":"manual/Julia/#Performance-annotations","page":"Julia basic concepts","title":"Performance annotations","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Sometimes code can be annotated to improve performance. For example, the @simd can be used in simple loops to indicate that the loop can be vectorized inside the CPU (it allows to run simple CPU instructions on small sets of data simultaneously). The @inbounds macro can be used to indicate that the code will not access elements outside the bounds of an array.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"function add_squares(x)\n  out = zero(eltype(x)) # Initialize out with the correct type with value of zero\n  @simd for i in eachindex(x)\n    @inbounds out += x[i]^2\n  end\n  return out\nend\n@btime add_squares($v1)\n@btime add_squares($v2)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Now we actually get faster performance for floating point number, which is related to the fact that the CPU can vectorize floating point operations more efficiently than integer operations (at least in this example). You can see the actual assembly code being generated (or an approximation of it) by using the @code_native macro. Any instruction that starts with v is a vectorized instruction. Note that sometimes Julia will automatically vectorize code without the need for the @simd but this is not always the case.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"@code_native add_squares(v2)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Notice how with some simple annotations and reorganizing the code to deal with type instability we were able to get a 30x speedup. Obviously this was a simple function with minimal runtime, so the speedup is not particularly useful, but this type of small functions are often the ones that are called many times in complex computations (e.g., ray tracing), so the speedup can be significant in actual applications. Whether you need to worry about performance depends on where the bottleneck is in your code.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"For more details, see the sections of the manual on profiling and performance tips.","category":"page"},{"location":"manual/Julia/#Global-variables-and-type-instability","page":"Julia basic concepts","title":"Global variables and type instability","text":"","category":"section"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"Global variables are any variable defined in a module outside of a function that is accessed from within a function. Global variables are not recommended in general as they can easily introduce bugs in your code by making the logic of the program much harder to reason about. However, they can also introduce performance issues as any global variable that is not annotated with its type will lead to type instability.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"For example, let's say we modify the add_squares function to use a global variable (a bit odd, but it is just to illustrate the point) to enable differen options in the code.","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"function add_squares(x)\n  out = zero(eltype(x))\n  if criterion > 0\n    @simd for i in eachindex(x)\n      @inbounds out += x[i]^2\n    end\n  else\n    @simd for i in eachindex(x)\n      @inbounds out -= x[i]^2\n    end\n  end\n  return out\nend\ncriterion = 1\n@code_warntype add_squares(v2)\n@btime add_squares(v2)","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"It is not a major hit in performance as criterion is only accessed once, but this can be a problem if the global variable is accessed many times in the code. The short term solution is to annotate the type of the global variable (but really we should be writing code without global variables). This can be frustating as once a global variable is created, you cannot annotate its type (even if it does not change!) without restarting the Julia session (unless it is inside a module).","category":"page"},{"location":"manual/Julia/","page":"Julia basic concepts","title":"Julia basic concepts","text":"function add_squares(x)\n  out = zero(eltype(x))\n  if criterion2 > 0\n    @simd for i in eachindex(x)\n      @inbounds out += x[i]^2\n    end\n  else\n    @simd for i in eachindex(x)\n      @inbounds out -= x[i]^2\n    end\n  end\n  return out\nend\ncriterion2::Int64 = 1\n@code_warntype add_squares(v2)\n@btime add_squares(v2)","category":"page"},{"location":"VPLVerse/Ecophys/photosynthesis/#Photosynthesis","page":"Photosynthesis API","title":"Photosynthesis","text":"","category":"section"},{"location":"VPLVerse/Ecophys/photosynthesis/","page":"Photosynthesis API","title":"Photosynthesis API","text":"CurrentModule = Ecophys.Photosynthesis","category":"page"},{"location":"VPLVerse/Ecophys/photosynthesis/#Public-API","page":"Photosynthesis API","title":"Public API","text":"","category":"section"},{"location":"VPLVerse/Ecophys/photosynthesis/","page":"Photosynthesis API","title":"Photosynthesis API","text":"Modules = [Photosynthesis]\nPublic = true\nPrivate = false","category":"page"},{"location":"VPLVerse/Ecophys/photosynthesis/#Private","page":"Photosynthesis API","title":"Private","text":"","category":"section"},{"location":"VPLVerse/Ecophys/photosynthesis/","page":"Photosynthesis API","title":"Photosynthesis API","text":"Private functions, types or constants from Photosynthesis. These are not exported, so you need to prefix the function name with PlantGeomPrimitives. to access them. Also bear in mind that these are not part of the public API, so they may change without notice.","category":"page"},{"location":"VPLVerse/Ecophys/photosynthesis/","page":"Photosynthesis API","title":"Photosynthesis API","text":"Modules = [Photosynthesis]\nPublic = false\nPrivate = true","category":"page"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.C3","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.C3","text":"C3(Sco25 = 2800.0, E_Sco = -24.46e3, Kmc25 = 270.0, E_Kmc = 80.99e3, \n    Kmo25 = 165.0e3, E_Kmo = 23.72e3, Vcmax25 = 120.0, E_Vcmax = 65.33e3, \n    simpleJ = false, k2ll = 0.35, theta = 0.7, Phi2 = 0.82, sigma2 = 0.5, \n    beta = 0.85, fcyc = 0.1, \n    fpseudo = 0.05, Jmax25 = 230.0, E_Jmax = 30.0e3, D_Jmax = 200.0e3, \n    S_Jmax = 650.0, TPU25 = 12.0, E_TPU = 53.1e3, D_TPU = 20.18e3,\n    S_TPU = 650.0, Rd25 = 1.2, E_Rd = 46.39e3, gm25 = 0.4, E_gm = 49.6e3, \n    D_gm = 437.4e3, S_gm = 1400.0, gso = 0.01, a1 = 0.85, b1 = 0.14e-3)\n\nData structure to store all the parameters for the C3 photosynthesis model.\n\nArguments\n\nSco25: Sc/o parameter at 25 C\nE_Sco: Apparent activation energy of Sc/o (J/mol)\nKmc25: Km for CO2 at 25 C (μmol/mol)\nE_Kmc: Activation energy of Kmc (J/mol)\nKmo25: Km for O2 at 25 C (umol/mol)\nE_Kmo: Activation energy of Kmo (J/mol)\nVcmax25: Maximum rate of carboxylation at 25 C (μmol/m2/s)\nE_Vcmax: Activation energy of Vcmax (J/mol)\ntheta: Curvature parameter\nsimpleJ: Use k2ll rather than calculating from other parameters\nk2ll: Low-light use efficiency for electron transport\nPhi2: Low-light PSII quantum yield\nsigma2: Partitioning of excitation between PSII and PSI\nbeta: Leaf absorptance of PAR\nfcyc:  Fraction of electrons at PSI that follow cyclic transport around PSI\nfpseudo: Fraction of electrons at PSI that are used by alternative electron sinks\nJmax25: Maximum rate of electron transport (μmol/m2/s)\nE_Jmax: Activation energy Jmax (J/mol)\nD_Jmax: Deactivation energy of Jmax (J/mol)\nS_Jmax: Entropy term for Jmax (K)\nTPU25: Maximum rate of triose phosphate utilisation (μmol/m2/s)\nE_TPU: Activation energy TPU (J/mol)\nD_TPU: Deactivation energy of TPU (J/mol)\nS_TPU: Entropy term for TPU (K)\nRd25: Respiration rate at 25 C (μmol/m2/s)\nE_Rd: Activation energy of Rd (J/mol)\ngm25: Maximum rate of CO2 assimilation at 25 C (μmol/m2/s)\nE_gm: Activation energy of gm (J/mol)\nD_gm: Deactivation energy of gm (J/mol)\nS_gm: Entropy term for gm (K)\ngso: Minimum stomatal conductance to fluxes of CO2 in darkness (mol/m2/s/Pa)\na1: Empirical parameter in gs formula\nb1: Empirical parameter in gs formula\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.C3Q","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.C3Q","text":"C3Q(Sco25 = 2800.0, E_Sco = -24.46e3J/mol, Kmc25 = 270.0μmol/mol, E_Kmc = 80.99e3J/mol,\n     Kmo25 = 165.0e3μmol/mol, E_Kmo = 23.72e3J/mol, Vcmax25 = 120.0μmol/m^2/s, E_Vcmax = 65.33e3J/mol,\n     simpleJ = false, k2ll = 0.35, theta = 0.7, Phi2 = 0.82, sigma2 = 0.5, beta = 0.85, fcyc = 0.1, fpseudo = 0.05, \n     Jmax25 = 230.0μmol/m^2/s, E_Jmax = 30.0e3J/mol, D_Jmax = 200.0e3J/mol, S_Jmax = 650.0J/mol/K, \n     TPU25 = 12.0μmol/m^2/s, E_TPU = 53.1e3J/mol, D_TPU = 201.8e3J/mol, S_TPU = 650.0K, \n     Rd25 = 1.2μmol/m^2/s, E_Rd = 46.39e3J/mol, gm25 = 0.4mol/m^2/s, E_gm = 49.6e3J/mol, \n     D_gm = 437.4e3J/mol, S_gm = 1400.0K, gso = 0.01mol/m^2/s, a1 = 0.85, b1 = 0.14e-3/Pa)\n\nData structure to store all the parameters for the C3 photosynthesis model using Quantity objects from Unitful.jl.\n\nArguments\n\nSco25: Sc/o parameter at 25 C\nE_Sco: Apparent activation energy of Sc/o (J/mol)\nKmc25: Km for CO2 at 25 C (μmol/mol)\nE_Kmc: Activation energy of Kmc (J/mol)\nKmo25: Km for O2 at 25 C (umol/mol)\nE_Kmo: Activation energy of Kmo (J/mol)\nVcmax25: Maximum rate of carboxylation at 25 C (μmol/m2/s)\nE_Vcmax: Activation energy of Vcmax (J/mol)\ntheta: Curvature parameter\nsimpleJ: Use k2ll rather than calculating from other parameters\nk2ll: Low-light use efficiency for electron transport\nPhi2: Low-light PSII quantum yield\nsigma2: Partitioning of excitation between PSII and PSI\nbeta: Leaf absorptance of PAR\nfcyc:  Fraction of electrons at PSI that follow cyclic transport around PSI\nfpseudo: Fraction of electrons at PSI that are used by alternative electron sinks\nJmax25: Maximum rate of electron transport (μmol/m2/s)\nE_Jmax: Activation energy Jmax (J/mol)\nD_Jmax: Deactivation energy of Jmax (J/mol)\nS_Jmax: Entropy term for Jmax (J/K/mol)\nTPU25: Maximum rate of triose phosphate utilisation (μmol/m2/s)\nE_TPU: Activation energy TPU (J/mol)\nD_TPU: Deactivation energy of TPU (J/mol)\nS_TPU: Entropy term for TPU (J/K/mol)\nRd25: Respiration rate at 25 C (μmol/m2/s)\nE_Rd: Activation energy of Rd (J/mol)\ngm25: Mesophyll conductance at 25 C (mol/m2/s)\nE_gm: Activation energy of gm (J/mol)\nD_gm: Deactivation energy of gm (J/mol)\nS_gm: Entropy term for gm (J/K/mol)\ngso: Minimum stomatal conductance to fluxes of CO2 in darkness (mol/m2/s)\na1: Empirical parameter in gs formula\nb1: Empirical parameter in gs formula (1/kPa)\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.C4","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.C4","text":"C4(Sco25 = 2590.0, E_Sco = -24.46e3, Kmc25 = 650.0, E_Kmc = 79.43e3, Kmo25 = 450e3, \n   E_Kmo = 36380.0, Vcmax25 = 120.0, E_Vcmax = 65.33, theta = 0.7, Phi2 = 0.83, sigma2 = 0.5, \n   beta = 0.85, fQ = 1.0, fpseudo = 0.1, h = 4.0, Jmax25 = 230.0, E_Jmax = 48e3, D_Jmax = 200e3, \n   S_Jmax = 630.0, x = 0.4, alpha = 0.1, kp25 = 0.7, E_kp = 46.39e3, gbs = 0.003, Rd25 = 1.2, \n   E_Rd = 46.39e3, gso = 0.01, a1 = 0.9, b1 = 0.15e-3)\n\nData structure to store all the parameters for the C3 photosynthesis model.\n\nArguments\n\nSco25: Sc/o parameter at 25 C\nE_Sco: Apparent activation energy of Sc/o (J/mol)\nKmc25: Km for CO2 at 25 C (μmol/mol)\nE_Kmc3: Activation energy of Kmc (J/mol)\nKmo25: Km for O2 at 25 C (umol/mol)\nE_Kmo: Activation energy of Kmo (J/mol)\nVcmax25: Maximum rate of carboxylation at 25 C (μmol/m2/s)\nE_Vcmax: Activation energy of Vcmax (J/mol)\ntheta: Curvature parameter\nPhi2: Low-light PSII quantum yield\nsigma2: Partitioning of excitation between PSII and PSI\nbeta: Leaf absorptance of PAR\nfQ: Fraction of electrons at reduced plastoquinone that follow the Q-cycle\nfpseudo: Fraction of electrons at PSI that follow cyclic transport around PSI\nh: Number of protons required to produce one ATP\nJmax25: Maximum rate of electron transport (μmol/m2/s)\nE_Jmax: Activation energy Jmax (J/mol)\nD_Jmax: Deactivation energy of Jmax (J/mol)\nS_Jmax: Entropy coefficient of Jmax (J/mol/K)\nx: Fraction of electron transport partitioned to mesophyll cells\nalpha: Fraction of O2 evolution occuring in the bundle sheath\nkp25: Initial carboxylation efficiency of the PEP carboxylase (mol/m2/s)\nE_kp: Activation energy of kp (J/mol)\ngbs: Bundle sheath conductance (mol/m^2/s)\nRd25:: Respiration rate at 25 C (μmol/m2/s)\nE_Rd: Activation energy of Rd (J/mol)\ngso: Minimum stomatal conductance to fluxes of CO2 in darkness (mol/m2/s)\na1: Empirical parameter in gs formula\nb1: Empirical parameter in gs formula (1/kPa)\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.C4Q","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.C4Q","text":"C4(Sco25 = 2590.0, E_Sco = -24.46e3J/mol, Kmc25 = 650.0μmol/mol, E_Kmc = 79.43e3J/mol,\n   Kmo25 = 450e3μmol/mol, E_Kmo = 36380.0J/mol, Vcmax25 = 120.0μmol/m^2/s, E_Vcmax = 65.33J/mol,\n   theta = 0.7, Phi2 = 0.83, sigma2 = 0.5, beta = 0.85, fQ = 1.0, fpseudo = 0.1, h = 4.0, \n   Jmax25 = 230.0μmol/m^2/s, E_Jmax = 48e3J/mol, D_Jmax = 200e3J/mol, S_Jmax = 630.0J/mol/K, \n   x = 0.4, alpha = 0.1, kp25 = 0.7mol/m^2/s, E_kp = 46.39e3J/mol, gbs = 0.003mol/m^2/s, \n   Rd25 = 1.2μmol/m^2/s, E_Rd = 46.39e3J/mol, gso = 0.01mol/m^2/s, a1 = 0.9, b1 = 0.15e-3/Pa)\n\nData structure to store all the parameters for the C4 photosynthesis model using Quantity objects from Unitful.jl.\n\nArguments\n\nSco25: Sc/o parameter at 25 C\nE_Sco: Apparent activation energy of Sc/o (J/mol)\nKmc25: Km for CO2 at 25 C (μmol/mol)\nE_Kmc3: Activation energy of Kmc (J/mol)\nKmo25: Km for O2 at 25 C (umol/mol)\nE_Kmo: Activation energy of Kmo (J/mol)\nVcmax25: Maximum rate of carboxylation at 25 C (μmol/m2/s)\nE_Vcmax: Activation energy of Vcmax (J/mol)\ntheta: Curvature parameter\nPhi2: Low-light PSII quantum yield\nsigma2: Partitioning of excitation between PSII and PSI\nbeta: Leaf absorptance of PAR\nfQ: Fraction of electrons at reduced plastoquinone that follow the Q-cycle\nfpseudo: Fraction of electrons at PSI that follow cyclic transport around PSI\nh: Number of protons required to produce one ATP\nJmax25: Maximum rate of electron transport (μmol/m2/s)\nE_Jmax: Activation energy Jmax (J/mol)\nD_Jmax: Deactivation energy of Jmax (J/mol)\nS_Jmax: Entropy coefficient of Jmax (J/mol/K)\nx: Fraction of electron transport partitioned to mesophyll cells\nalpha: Fraction of O2 evolution occuring in the bundle sheath\nkp25: Initial carboxylation efficiency of the PEP carboxylase (mol/m2/s)\nE_kp: Activation energy of kp (J/mol)\ngbs: Bundle sheath conductance (mol/m^2/s)\nRd25:: Respiration rate at 25 C (μmol/m2/s)\nE_Rd: Activation energy of Rd (J/mol)\ngso: Minimum stomatal conductance to fluxes of CO2 in darkness (mol/m2/s)\na1: Empirical parameter in gs formula\nb1: Empirical parameter in gs formula (1/kPa)\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.SimpleOptical","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.SimpleOptical","text":"SimpleOptical(; αPAR = 0.85, αNIR = 0.20, ϵ = 0.95)\n\nSimple optical properties of a leaf.\n\nArguments\n\nαPAR: Absorption coefficient of PAR\nαNIR: Absorption coefficient of NIR\nϵ: Emissivity for thermal radiation\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.gbAngle","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.gbAngle","text":"gbAngle(; d = 0.01, ang = 0.0, ar = 1.0, fangm = 1.381, fangk = 0.034, \nα = 2.738, b0_0 = 0.455, d_b0 = 2.625, b0_n = 0.373, b0_KAR = 28.125,  db_0 = 0.085, \nd_db = 0.437, db_n = 5.175, db_KAR = 0.884,  β_0 = 3.362, d_β = 17.664, β_n = 4.727, \nβ_KAR = 0.677)\n\nModel of boundary layer conductance that accounts for inclination angle and leaf aspect ratio (see documentation for details).\n\nArguments\n\nd: Characteristic leaf length (m)\nang: Leaf inclination angle (°)\nar: Leaf aspect ratio (length/width)\nfangm: Maximum enhancement factor due to inclination angle\nfangk: Exponent in response to inclination angle\nα: Effect on back boundary layer conductance due to leaf inclination angle and aspect ratio\nb0_0: Parameter in the effect of aspect ratio (see documentation)\nd_b0: Parameter in the effect of aspect ratio (see documentation)\nb0_n: Parameter in the effect of aspect ratio (see documentation)\nb0_KAR: Parameter in the effect of aspect ratio (see documentation)\ndb_0: Parameter in the effect of aspect ratio (see documentation)\nd_db: Parameter in the effect of aspect ratio (see documentation)\ndb_n: Parameter in the effect of aspect ratio (see documentation)\ndb_KAR: Parameter in the effect of aspect ratio (see documentation)\nβ_0: Parameter in the effect of aspect ratio (see documentation)\nd_β: Parameter in the effect of aspect ratio (see documentation)\nβ_n: Parameter in the effect of aspect ratio (see documentation)\nβ_KAR: Parameter in the effect of aspect ratio (see documentation)\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.gbAngleQ","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.gbAngleQ","text":"gbAngleQ(; d = 0.01m, ang = 0.0, ar = 1.0, fangm = 1.381, fangk = 0.034, \nα = 2.738, b0_0 = 0.455, d_b0 = 2.625, b0_n = 0.373, b0_KAR = 28.125,  db_0 = 0.085, \nd_db = 0.437, db_n = 5.175, db_KAR = 0.884,  β_0 = 3.362, d_β = 17.664, β_n = 4.727, \nβ_KAR = 0.677)\n\nModel of boundary layer conductance that accounts for inclination angle and leaf aspect ratio (see documentation for details) using Quantity for Unitful.jl.\n\nArguments\n\nd: Characteristic leaf length (m)\nang: Leaf inclination angle (°)\nar: Leaf aspect ratio (length/width)\nfangm: Maximum enhancement factor due to inclination angle\nfangk: Exponent in response to inclination angle\nα: Effect on back boundary layer conductance due to leaf inclination angle and aspect ratio\nb0_0: Parameter in the effect of aspect ratio (see documentation)\nd_b0: Parameter in the effect of aspect ratio (see documentation)\nb0_n: Parameter in the effect of aspect ratio (see documentation)\nb0_KAR: Parameter in the effect of aspect ratio (see documentation)\ndb_0: Parameter in the effect of aspect ratio (see documentation)\nd_db: Parameter in the effect of aspect ratio (see documentation)\ndb_n: Parameter in the effect of aspect ratio (see documentation)\ndb_KAR: Parameter in the effect of aspect ratio (see documentation)\nβ_0: Parameter in the effect of aspect ratio (see documentation)\nd_β: Parameter in the effect of aspect ratio (see documentation)\nβ_n: Parameter in the effect of aspect ratio (see documentation)\nβ_KAR: Parameter in the effect of aspect ratio (see documentation)\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.simplegb","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.simplegb","text":"simplegb(; d = 0.01)\n\nSimple model of boundary layer conductance.\n\nArguments\n\nd: Characteristic leaf length (m)\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.simplegbQ","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.simplegbQ","text":"simplegbQ(; d = 0.01m)\n\nSimple model of boundary layer conductance using Quantity from Unitful.jl.\n\nArguments\n\nd: Characteristic leaf length (m)\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.energybalance-NTuple{12, Any}","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.energybalance","text":"energybalance(pgb, pAgs, pEb, PAR, NIR, ws, RH, Tair, Ca, P, O2)\n\nCalculate the energy balance of a leaf.\n\nArguments\n\npgb: Boundary layer conductance model\npAgs: Photosynthesis and stomatal conductance model\npEb: Optical properties of the leaf\nPAR: Photosynthetically active radiation (umol/m2/s)\nNIR: Near-infrared radiation (W/m2)\nws: Wind speed (m/s)\nRH: Relative humidity\nTair: Air temperature (K)\nCa: Atmospheric CO2 concentration (μmol/mol)\nP: Air pressure (kPa)\nO2: Atmospheric O2 concentration (μmol/mol)\n\nDetails\n\nInputs maybe be either Real or Quantity types (i.e., with physical units).  If Quantity types are used, the output will be a Quantity type.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.gb-Tuple{Ecophys.Photosynthesis.gbType, Vararg{Any, 4}}","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.gb","text":"gb(p::gbType, ws, Tleaf, Tair, P)\n\nCompute boundary layer conductance for heat, water vapor and CO2.\n\nArguments\n\np: Model of boundary layer conductance\nws: Wind speed (m/s)\nTleaf: Leaf temperature (K)\nTair: Air temperature (K)\nP: Air pressure (Pa)\n\nReturns\n\ngbh: Boundary layer conductance for heat (W/m²/K)\ngbw: Boundary layer conductance for water vapor (mol/m²/s)\ngbc: Boundary layer conductance for CO2 (mol/m²/s)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.photosynthesis-Tuple{Ecophys.Photosynthesis.C3}","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.photosynthesis","text":"photosynthesis(par::C3, PAR = 1000.0, RH = 0.75, Tleaf = 298.0, Ca = 400.0, O2 = 210e3, gb = 0.5, net = true)\nphotosynthesis(par::C4, PAR = 1000.0, RH = 0.75, Tleaf = 298.0, Ca = 400.0, O2 = 210e3, gb = 0.5, net = true)\nphotosynthesis(par::C3Q, PAR = 1000.0μmol/m^2/s, RH = 0.75, Tleaf = 298.0K, Ca = 400.0μmol/mol, O2 = 210e3μmol/mol, gb = 0.5mol/m^2/s, net = true)\nphotosynthesis(par::C4Q, PAR = 1000.0μmol/m^2/s, RH = 0.75, Tleaf = 298.0K, Ca = 400.0μmol/mol, O2 = 210e3μmol/mol, gb = 0.5mol/m^2/s, net = true)\n\nCalculate net or gross CO2 assimilation (umol/m2/s) and stomatal condutance to fluxes of CO2 (mol/m2/s) as a function of  photosynthetically active radiation (PAR, umol/m2/s), relative humidity (RH), leaf temperature (Tleaf, K), air CO2 partial pressure (Ca, μmol/mol), oxygen (O2, μmol/mol) and boundary layer  conductance to CO2 (gb, mol/m2/s). Environmental inputs must be scalar. The argument net indicates whether the net or gross CO2 assimilation should be returned.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.solve_energy_balance-Tuple{Union{Ecophys.Photosynthesis.C3Q, Ecophys.Photosynthesis.C4Q}}","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.solve_energy_balance","text":"solve_energy_balance(Ags::Union{C3Q, C4Q}; gb = simplegbQ(), \n                     opt = SimpleOptical(), PAR = 1000.0μmol/m^2/s, \n                     NIR = 250.0W/m^2, ws = 1.0m/s, RH = 0.75, \n                     Tair = 298.0K, Ca = 400.0μmol/mol, P = 101.0kPa, \n                     O2 = 210.0mmol/mol, order = Order2(), xatol = 0.01, \n                     maxfnevals = 100, net = true)\nsolve_energy_balance(Ags::Union{C3, C4}; gb = simplegb(), \n                     opt = SimpleOptical(), PAR = 1000.0, NIR = 250.0, \n                     ws = 1.0, RH = 0.75, Tair = 298.0, Ca = 400.0, \n                     P = 101.0e3, O2 = 210.0e3, order = Order2(), xatol = 0.01, \n                     maxfnevals = 100, net = true)\n\nSolve the leaf energy balance coupled to photosynthesis and transpiration.\n\nArguments\n\nAgs: Photosynthesis and stomatal conductance model\ngb: Boundary layer conductance model\nopt: Optical properties of the leaf\nPAR: Photosynthetically active radiation (umol/m2/s)\nNIR: Near-infrared radiation (W/m2)\nws: Wind speed (m/s)\nRH: Relative humidity\nTair: Air temperature (K)\nCa: Atmospheric CO2 concentration (μmol/mol)\nP: Air pressure (Pa)\nO2: Atmospheric O2 concentration (μmol/mol)\norder: Order of the root solving algorithm that finds leaf temperature         (see Roots.jl package for more information).\nxatol: Absolute tolerance of the root solving algorithm (see Roots.jl package for more information),\nmaxfnevals: Maximum number of function evaluations of the root solving algorithm (see Roots.jl package for more information).\nnet: Whether to return net or gross CO2 assimilation.\n\nDetails\n\nInputs maybe be either Real or Quantity types from Unitful.jl (i.e., with  physical units). If Quantity types are used, the output will be a Quantity  type.\n\nReturns\n\nA named tuple with net CO2 assimilation (An, μmol/m^2/s), gross CO2  assimilation (Ag, μmol/m^2/s), transpiration (Tr, mol/m^2/s) and leaf  temperature (Tleaf, K).\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/Ecophys/photosynthesis/#Ecophys.Photosynthesis.transpiration-Tuple{}","page":"Photosynthesis API","title":"Ecophys.Photosynthesis.transpiration","text":"transpiration(;gsw = 0.1, gbw = 1.0, Tleaf = 300.0, Tair = 298.0, P = 101e3,\n               RH = 0.75)\n\nCompute transpiration rate (mol/m^2/s) from conductance to water vapor and  environmental variables.\n\nArguments\n\ngsw: Stomatal conductance to water vapor (mol/m^2/s)\ngbw: Boundary layer conductance to water vapor (mol/m^2/s)\nTleaf: Leaf temperature (K)\nTair: Air temperature (K)\nP: Air pressure (Pa)\nRH: Relative humidity\n\n\n\n\n\n","category":"method"},{"location":"tutorials/raytracedforest/#Ray-traced-forest","page":"Ray-traced forest","title":"Ray-traced forest","text":"","category":"section"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"Alejandro Morales","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"In this example we extend the forest growth model to include PAR interception a radiation use efficiency to compute the daily growth rate.","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The following packages are needed:","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"using VirtualPlantLab, ColorTypes\nimport GLMakie\nusing Base.Threads: @threads\nusing Plots\nimport Random\nusing FastGaussQuadrature\nusing Distributions\nusing SkyDomes\nRandom.seed!(123456789)","category":"page"},{"location":"tutorials/raytracedforest/#Model-definition","page":"Ray-traced forest","title":"Model definition","text":"","category":"section"},{"location":"tutorials/raytracedforest/#Node-types","page":"Ray-traced forest","title":"Node types","text":"","category":"section"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The data types needed to simulate the trees are given in the following module. The difference with respec to the previous model is that Internodes and Leaves have optical properties needed for ray tracing (they are defined as Lambertian surfaces).","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"# Data types\nmodule TreeTypes\n    using VirtualPlantLab\n    using Distributions\n    # Meristem\n    Base.@kwdef mutable struct Meristem <: VirtualPlantLab.Node\n        age::Int64 = 0   ## Age of the meristem\n    end\n    # Bud\n    struct Bud <: VirtualPlantLab.Node end\n    # Node\n    struct Node <: VirtualPlantLab.Node end\n    # BudNode\n    struct BudNode <: VirtualPlantLab.Node end\n    # Internode (needs to be mutable to allow for changes over time)\n    Base.@kwdef mutable struct Internode <: VirtualPlantLab.Node\n        age::Int64 = 0         ## Age of the internode\n        biomass::Float64 = 0.0 ## Initial biomass\n        length::Float64 = 0.0  ## Internodes\n        width::Float64  = 0.0  ## Internodes\n        sink::Exponential{Float64} = Exponential(5)\n        material::Lambertian{1} = Lambertian(τ = 0.1, ρ = 0.05) ## Leaf material\n    end\n    # Leaf\n    Base.@kwdef mutable struct Leaf <: VirtualPlantLab.Node\n        age::Int64 = 0         ## Age of the leaf\n        biomass::Float64 = 0.0 ## Initial biomass\n        length::Float64 = 0.0  ## Leaves\n        width::Float64 = 0.0   ## Leaves\n        sink::Beta{Float64} = Beta(2,5)\n        material::Lambertian{1} = Lambertian(τ = 0.1, ρ = 0.05) ## Leaf material\n    end\n    # Graph-level variables -> mutable because we need to modify them during growth\n    Base.@kwdef mutable struct treeparams\n        # Variables\n        PAR::Float64 = 0.0   ## Total PAR absorbed by the leaves on the tree (MJ)\n        biomass::Float64 = 2e-3 ## Current total biomass (g)\n        # Parameters\n        RUE::Float64 = 5.0   ## Radiation use efficiency (g/MJ) -> unrealistic to speed up sim\n        IB0::Float64 = 1e-3  ## Initial biomass of an internode (g)\n        SIW::Float64 = 0.1e6 ## Specific internode weight (g/m3)\n        IS::Float64  = 15.0  ## Internode shape parameter (length/width)\n        LB0::Float64 = 1e-3  ## Initial biomass of a leaf\n        SLW::Float64 = 100.0 ## Specific leaf weight (g/m2)\n        LS::Float64  = 3.0   ## Leaf shape parameter (length/width)\n        budbreak::Float64 = 1/0.5 ## Bud break probability coefficient (in 1/m)\n        plastochron::Int64 = 5 ## Number of days between phytomer production\n        leaf_expansion::Float64 = 15.0 ## Number of days that a leaf expands\n        phyllotaxis::Float64 = 140.0\n        leaf_angle::Float64 = 30.0\n        branch_angle::Float64 = 45.0\n    end\nend\n\nimport .TreeTypes","category":"page"},{"location":"tutorials/raytracedforest/#Geometry","page":"Ray-traced forest","title":"Geometry","text":"","category":"section"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The methods for creating the geometry and color of the tree are the same as in the previous example but include the materials for the ray tracer.","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"# Create geometry + color for the internodes\nfunction VirtualPlantLab.feed!(turtle::Turtle, i::TreeTypes.Internode, data)\n    # Rotate turtle around the head to implement elliptical phyllotaxis\n    rh!(turtle, data.phyllotaxis)\n    HollowCylinder!(turtle, length = i.length, height = i.width, width = i.width,\n                move = true, color = RGB(0.5,0.4,0.0), material = i.material)\n    return nothing\nend\n\n# Create geometry + color for the leaves\nfunction VirtualPlantLab.feed!(turtle::Turtle, l::TreeTypes.Leaf, data)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -data.leaf_angle)\n    # Generate the leaf\n    Ellipse!(turtle, length = l.length, width = l.width, move = false,\n             color = RGB(0.2,0.6,0.2), material = l.material)\n    # Rotate turtle back to original direction\n    ra!(turtle, data.leaf_angle)\n    return nothing\nend\n\n# Insertion angle for the bud nodes\nfunction VirtualPlantLab.feed!(turtle::Turtle, b::TreeTypes.BudNode, data)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -data.branch_angle)\nend","category":"page"},{"location":"tutorials/raytracedforest/#Development","page":"Ray-traced forest","title":"Development","text":"","category":"section"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The meristem rule is now parameterized by the initial states of the leaves and internodes and will only be triggered every X days where X is the plastochron.","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"# Create right side of the growth rule (parameterized by the initial states\n# of the leaves and internodes)\nfunction create_meristem_rule(vleaf, vint)\n    meristem_rule = Rule(TreeTypes.Meristem,\n                        lhs = mer -> mod(data(mer).age, graph_data(mer).plastochron) == 0,\n                        rhs = mer -> TreeTypes.Node() +\n                                     (TreeTypes.Bud(),\n                                     TreeTypes.Leaf(biomass = vleaf.biomass,\n                                                    length  = vleaf.length,\n                                                    width   = vleaf.width)) +\n                                     TreeTypes.Internode(biomass = vint.biomass,\n                                                         length  = vint.length,\n                                                         width   = vint.width) +\n                                     TreeTypes.Meristem())\nend","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The bud break probability is now a function of distance to the apical meristem rather than the number of internodes. An adhoc traversal is used to compute this length of the main branch a bud belongs to (ignoring the lateral branches). Compute the probability that a bud breaks as function of distance to the meristem","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function prob_break(bud)\n    # We move to parent node in the branch where the bud was created\n    node =  parent(bud)\n    # Extract the first internode\n    child = filter(x -> data(x) isa TreeTypes.Internode, children(node))[1]\n    data_child = data(child)\n    # We measure the length of the branch until we find the meristem\n    distance = 0.0\n    while !isa(data_child, TreeTypes.Meristem)\n        # If we encounter an internode, store the length and move to the next node\n        if data_child isa TreeTypes.Internode\n            distance += data_child.length\n            child = children(child)[1]\n            data_child = data(child)\n        # If we encounter a node, extract the next internode\n        elseif data_child isa TreeTypes.Node\n                child = filter(x -> data(x) isa TreeTypes.Internode, children(child))[1]\n                data_child = data(child)\n        else\n            error(\"Should be Internode, Node or Meristem\")\n        end\n    end\n    # Compute the probability of bud break as function of distance and\n    # make stochastic decision\n    prob =  min(1.0, distance*graph_data(bud).budbreak)\n    return rand() < prob\nend\n\n# Branch rule parameterized by initial states of internodes\nfunction create_branch_rule(vint)\n    branch_rule = Rule(TreeTypes.Bud,\n            lhs = prob_break,\n            rhs = bud -> TreeTypes.BudNode() +\n                         TreeTypes.Internode(biomass = vint.biomass,\n                                             length  = vint.length,\n                                             width   = vint.width) +\n                         TreeTypes.Meristem())\nend","category":"page"},{"location":"tutorials/raytracedforest/#Light-interception","page":"Ray-traced forest","title":"Light interception","text":"","category":"section"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"As growth is now dependent on intercepted PAR via RUE, we now need to simulate light interception by the trees. We will use a ray-tracing approach to do so. The first step is to create a scene with the trees and the light sources. As for rendering, the scene can be created from the forest object by simply calling Scene(forest) that will generate the 3D meshes and connect them to their optical properties.","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"However, we also want to add the soil surface as this will affect the light distribution within the scene due to reflection from the soil surface. This is similar to the customized scene that we created before for rendering, but now for the light simulation.","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function create_soil()\n    soil = Rectangle(length = 21.0, width = 21.0)\n    rotatey!(soil, π/2) ## To put it in the XY plane\n    VirtualPlantLab.translate!(soil, Vec(0.0, 10.5, 0.0)) ## Corner at (0,0,0)\n    return soil\nend\nfunction create_scene(forest)\n    # These are the trees\n    scene = Scene(vec(forest))\n    # Add a soil surface\n    soil = create_soil()\n    soil_material = Lambertian(τ = 0.0, ρ = 0.21)\n    add!(scene, mesh = soil, material = soil_material)\n    # Return the scene\n    return scene\nend","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"Given the scene, we can create the light sources that can approximate the solar irradiance on a given day, location and time of the day using the functions from the  package (see package documentation for details). Given the latitude, day of year and fraction of the day (f = 0 being sunrise and f = 1 being sunset), the function clear_sky() computes the direct and diffuse solar radiation assuming a clear sky. These values may be converted to different wavebands and units using waveband_conversion(). Finally, the collection of light sources approximating the solar irradiance distribution over the sky hemisphere is constructed with the function sky() (this last step requires the 3D scene as input in order to place the light sources adequately).","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function create_sky(;scene, lat = 52.0*π/180.0, DOY = 182)\n    # Fraction of the day and day length\n    fs = collect(0.1:0.1:0.9)\n    dec = declination(DOY)\n    DL = day_length(lat, dec)*3600\n    # Compute solar irradiance\n    temp = [clear_sky(lat = lat, DOY = DOY, f = f) for f in fs] # W/m2\n    Ig   = getindex.(temp, 1)\n    Idir = getindex.(temp, 2)\n    Idif = getindex.(temp, 3)\n    # Conversion factors to PAR for direct and diffuse irradiance\n    f_dir = waveband_conversion(Itype = :direct,  waveband = :PAR, mode = :power)\n    f_dif = waveband_conversion(Itype = :diffuse, waveband = :PAR, mode = :power)\n    # Actual irradiance per waveband\n    Idir_PAR = f_dir.*Idir\n    Idif_PAR = f_dif.*Idif\n    # Create the dome of diffuse light\n    dome = sky(scene,\n                  Idir = 0.0, ## No direct solar radiation\n                  Idif = sum(Idir_PAR)/10*DL, ## Daily Diffuse solar radiation\n                  nrays_dif = 1_000_000, ## Total number of rays for diffuse solar radiation\n                  sky_model = StandardSky, ## Angular distribution of solar radiation\n                  dome_method = equal_solid_angles, ## Discretization of the sky dome\n                  ntheta = 9, ## Number of discretization steps in the zenith angle\n                  nphi = 12) ## Number of discretization steps in the azimuth angle\n    # Add direct sources for different times of the day\n    for I in Idir_PAR\n        push!(dome, sky(scene, Idir = I/10*DL, nrays_dir = 100_000, Idif = 0.0)[1])\n    end\n    return dome\nend","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The 3D scene and the light sources are then combined into a RayTracer object, together with general settings for the ray tracing simulation chosen via RTSettings(). The most important settings refer to the Russian roulette system and the grid cloner (see section on Ray Tracing for details). The settings for the Russian roulette system include the number of times a ray will be traced deterministically (maxiter) and the probability that a ray that exceeds maxiter is terminated (pkill). The grid cloner is used to approximate an infinite canopy by replicating the scene in the different directions (nx and ny being the number of replicates in each direction along the x and y axes, respectively). It is also possible to turn on parallelization of the ray tracing simulation by setting parallel = true (currently this uses Julia's builtin multithreading capabilities).","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"In addition RTSettings(), an acceleration structure and a splitting rule can be defined when creating the RayTracer object (see ray tracing documentation for details). The acceleration structure allows speeding up the ray tracing by avoiding testing all rays against all objects in the scene.","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function create_raytracer(scene, sources)\n    settings = RTSettings(pkill = 0.9, maxiter = 4, nx = 5, ny = 5, parallel = true)\n    RayTracer(scene, sources, settings = settings, acceleration = BVH,\n                     rule = SAH{3}(5, 10));\nend","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The actual ray tracing simulation is performed by calling the trace!() method on the ray tracing object. This will trace all rays from all light sources and update the radiant power absorbed by the different surfaces in the scene inside the Material objects (see feed!() above):","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function run_raytracer!(forest; DOY = 182)\n    scene   = create_scene(forest)\n    sources = create_sky(scene = scene, DOY = DOY)\n    rtobj   = create_raytracer(scene, sources)\n    trace!(rtobj)\n    return nothing\nend","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The total PAR absorbed for each tree is calculated from the material objects of the different internodes (using power() on the Material object). Note that the power() function returns three different values, one for each waveband, but they are added together as RUE is defined for total PAR.","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"Run the ray tracer, calculate PAR absorbed per tree and add it to the daily total using general weighted quadrature formula","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function calculate_PAR!(forest;  DOY = 182)\n    # Reset PAR absorbed by the tree (at the start of a new day)\n    reset_PAR!(forest)\n    # Run the ray tracer to compute daily PAR absorption\n    run_raytracer!(forest, DOY = DOY)\n    # Add up PAR absorbed by each leaf within each tree\n    @threads for tree in forest\n        for l in get_leaves(tree)\n            data(tree).PAR += power(l.material)[1]\n        end\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"Reset PAR absorbed by the tree (at the start of a new day)","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function reset_PAR!(forest)\n    for tree in forest\n        data(tree).PAR = 0.0\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/raytracedforest/#Growth","page":"Ray-traced forest","title":"Growth","text":"","category":"section"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"We need some functions to compute the length and width of a leaf or internode from its biomass","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function leaf_dims(biomass, vars)\n    leaf_biomass = biomass\n    leaf_area    = biomass/vars.SLW\n    leaf_length  = sqrt(leaf_area*4*vars.LS/pi)\n    leaf_width   = leaf_length/vars.LS\n    return leaf_length, leaf_width\nend\n\nfunction int_dims(biomass, vars)\n    int_biomass = biomass\n    int_volume  = biomass/vars.SIW\n    int_length  = cbrt(int_volume*4*vars.IS^2/pi)\n    int_width   = int_length/vars.IS\n    return int_length, int_width\nend","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"Each day, the total biomass of the tree is updated using a simple RUE formula and the increment of biomass is distributed across the organs proportionally to their relative sink strength (of leaves or internodes).","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The sink strength of leaves is modelled with a beta distribution scaled to the leaf_expansion argument that determines the duration of leaf growth, whereas for the internodes it follows a negative exponential distribution. The pdf function computes the probability density of each distribution which is taken as proportional to the sink strength (the model is actually source-limited since we imposed a particular growth rate).","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"sink_strength(leaf, vars) = leaf.age > vars.leaf_expansion ? 0.0 :\n                            pdf(leaf.sink, leaf.age/vars.leaf_expansion)/100.0\nplot(0:1:50, x -> sink_strength(TreeTypes.Leaf(age = x), TreeTypes.treeparams()),\n     xlabel = \"Age\", ylabel = \"Sink strength\", label = \"Leaf\")\n\nsink_strength(int) = pdf(int.sink, int.age)\nplot!(0:1:50, x -> sink_strength(TreeTypes.Internode(age = x)), label = \"Internode\")","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"Now we need a function that updates the biomass of the tree, allocates it to the different organs and updates the dimensions of said organs. For simplicity, we create the functions leaves() and internodes() that will apply the queries to the tree required to extract said nodes:","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"get_leaves(tree) = apply(tree, Query(TreeTypes.Leaf))\nget_internodes(tree) = apply(tree, Query(TreeTypes.Internode))","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The age of the different organs is updated every time step:","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function age!(all_leaves, all_internodes, all_meristems)\n    for leaf in all_leaves\n        leaf.age += 1\n    end\n    for int in all_internodes\n        int.age += 1\n    end\n    for mer in all_meristems\n        mer.age += 1\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The daily growth is allocated to different organs proportional to their sink strength.","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function grow!(tree, all_leaves, all_internodes)\n    # Compute total biomass increment\n    tdata = data(tree)\n    ΔB    = max(0.5, tdata.RUE*tdata.PAR/1e6) # Trick to emulate reserves in seedling\n    tdata.biomass += ΔB\n    # Total sink strength\n    total_sink = 0.0\n    for leaf in all_leaves\n        total_sink += sink_strength(leaf, tdata)\n    end\n    for int in all_internodes\n        total_sink += sink_strength(int)\n    end\n    # Allocate biomass to leaves and internodes\n    for leaf in all_leaves\n        leaf.biomass += ΔB*sink_strength(leaf, tdata)/total_sink\n    end\n    for int in all_internodes\n        int.biomass += ΔB*sink_strength(int)/total_sink\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"Finally, we need to update the dimensions of the organs. The leaf dimensions are","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function size_leaves!(all_leaves, tvars)\n    for leaf in all_leaves\n        leaf.length, leaf.width = leaf_dims(leaf.biomass, tvars)\n    end\n    return nothing\nend\nfunction size_internodes!(all_internodes, tvars)\n    for int in all_internodes\n        int.length, int.width = int_dims(int.biomass, tvars)\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/raytracedforest/#Daily-step","page":"Ray-traced forest","title":"Daily step","text":"","category":"section"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"All the growth and developmental functions are combined together into a daily step function that updates the forest by iterating over the different trees in parallel.","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"get_meristems(tree) = apply(tree, Query(TreeTypes.Meristem))\nfunction daily_step!(forest, DOY)\n    # Compute PAR absorbed by each tree\n    calculate_PAR!(forest, DOY = DOY)\n    # Grow the trees\n    @threads for tree in forest\n        # Retrieve all the relevant organs\n        all_leaves = get_leaves(tree)\n        all_internodes = get_internodes(tree)\n        all_meristems = get_meristems(tree)\n        # Update the age of the organs\n        age!(all_leaves, all_internodes, all_meristems)\n        # Grow the tree\n        grow!(tree, all_leaves, all_internodes)\n        tdata = data(tree)\n        size_leaves!(all_leaves, tdata)\n        size_internodes!(all_internodes, tdata)\n        # Developmental rules\n        rewrite!(tree)\n    end\nend","category":"page"},{"location":"tutorials/raytracedforest/#Initialization","page":"Ray-traced forest","title":"Initialization","text":"","category":"section"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The trees are initialized on a regular grid with random values for the initial orientation and RUE:","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"RUEs = rand(Normal(1.5,0.2), 10, 10)\nhistogram(vec(RUEs))\n\norientations = [rand()*360.0 for i = 1:2.0:20.0, j = 1:2.0:20.0]\nhistogram(vec(orientations))\n\norigins = [Vec(i,j,0) for i = 1:2.0:20.0, j = 1:2.0:20.0];","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"The following initalizes a tree based on the origin, orientation and RUE:","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function create_tree(origin, orientation, RUE)\n    # Initial state and parameters of the tree\n    data = TreeTypes.treeparams(RUE = RUE)\n    # Initial states of the leaves\n    leaf_length, leaf_width = leaf_dims(data.LB0, data)\n    vleaf = (biomass = data.LB0, length = leaf_length, width = leaf_width)\n    # Initial states of the internodes\n    int_length, int_width = int_dims(data.LB0, data)\n    vint = (biomass = data.IB0, length = int_length, width = int_width)\n    # Growth rules\n    meristem_rule = create_meristem_rule(vleaf, vint)\n    branch_rule   = create_branch_rule(vint)\n    axiom = T(origin) + RH(orientation) +\n            TreeTypes.Internode(biomass = vint.biomass,\n                                length  = vint.length,\n                                width   = vint.width) +\n            TreeTypes.Meristem()\n    tree = Graph(axiom = axiom, rules = (meristem_rule, branch_rule),\n                 data = data)\n    return tree\nend","category":"page"},{"location":"tutorials/raytracedforest/#Visualization","page":"Ray-traced forest","title":"Visualization","text":"","category":"section"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"As in the previous example, it makes sense to visualize the forest with a soil tile beneath it. Unlike in the previous example, we will construct the soil tile using a dedicated graph and generate a Scene object which can later be merged with the rest of scene generated in daily step:","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"Base.@kwdef struct Soil <: VirtualPlantLab.Node\n    length::Float64\n    width::Float64\nend\nfunction VirtualPlantLab.feed!(turtle::Turtle, s::Soil, data)\n    Rectangle!(turtle, length = s.length, width = s.width, color = RGB(255/255, 236/255, 179/255))\nend\nsoil_graph = RA(-90.0) + T(Vec(0.0, 10.0, 0.0)) + ## Moves into position\n             Soil(length = 20.0, width = 20.0) ## Draws the soil tile\nsoil = Scene(Graph(axiom = soil_graph));\nrender(soil, axes = false)","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"And the following function renders the entire scene (notice that we need to use display() to force the rendering of the scene when called within a loop or a function):","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"function render_forest(forest, soil)\n    scene = Scene(vec(forest)) ## create scene from forest\n    scene = Scene([scene, soil]) ## merges the two scenes\n    display(render(scene))\nend","category":"page"},{"location":"tutorials/raytracedforest/#Simulation","page":"Ray-traced forest","title":"Simulation","text":"","category":"section"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"We can now create a forest of trees on a regular grid:","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"forest = create_tree.(origins, orientations, RUEs);\nrender_forest(forest, soil)\nstart = 180\nfor i in 1:20\n    println(\"Day $i\")\n    daily_step!(forest, i + start)\n    if mod(i, 5) == 0\n        render_forest(forest, soil)\n    end\nend","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"","category":"page"},{"location":"tutorials/raytracedforest/","page":"Ray-traced forest","title":"Ray-traced forest","text":"This page was generated using Literate.jl.","category":"page"},{"location":"VPLVerse/Ecophys/#ecophys","page":"Ecophys package","title":"Ecophys","text":"","category":"section"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"Alejandro Morales","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"This package contains modules describing different ecophysiological functions of plants, including processes such as photosynthesis, respiration, transpiration or phenology. They may be used as standalone or as a component of a plant growth model.","category":"page"},{"location":"VPLVerse/Ecophys/#Installation","page":"Ecophys package","title":"Installation","text":"","category":"section"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"To install Ecophys.jl, you can use the following command:","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"] add Ecophys","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"Or, if you prefer the development version:","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"import Pkg\nPkg.add(url = \"https://github.com/VirtualPlantLab/Ecophys.jl.git\", rev = \"master\")","category":"page"},{"location":"VPLVerse/Ecophys/#Photosynthesis","page":"Ecophys package","title":"Photosynthesis","text":"","category":"section"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"The module Photosynthesis contains functions to calculate leaf CO2 assimilation and stomatal conductance for C3 and C4 species, based on the work by Yin & Struik (2009, NJAS). To create a model, use the corresponding function (C3() or C4()) and pass the parameters as keyword arguments (they all have default values that correspond to Tables 2 the original publication):","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"using Ecophys\nc3 = C3(Vcmax25 = 140.0)\nc4 = C4(Vcmax25 = 140.0)","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"To compute CO2 assimilation and stomatal conductance, use the photosynthesis() function, passing the photosynthesis model and the environmental conditions as inputs (with defaults):","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"A_c3, gs_c3  = photosynthesis(c3, PAR = 100.0)\nA_c4, gs_c4  = photosynthesis(c4, PAR = 100.0)","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"It is also possible to work with physical units using the Unitful.jl package. In such case, the functions C3Q() and C4Q should be used to create the model but now the parameters are stored as Quantity objects:","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"using Unitful.DefaultSymbols # import symbols for units\nc3Q = C3Q(Vcmax25 = 140.0μmol/m^2/s)\nc4Q = C4Q(Vcmax25 = 140.0μmol/m^2/s)","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"And the environmental conditions should be passed as Quantity objects (defaults are updated accordingly, see Unitful.jl documentation for details on how to create Quantity objects):","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"A_c3, gs_c3  = photosynthesis(c3Q, PAR = 100.0μmol/m^2/s)\nA_c4, gs_c4  = photosynthesis(c4Q, PAR = 100.0μmol/m^2/s)","category":"page"},{"location":"VPLVerse/Ecophys/#Leaf-Energy-Balance","page":"Ecophys package","title":"Leaf Energy Balance","text":"","category":"section"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"Ecophys may also compute the leaf energy balance to couple photosynthesis, transpiration and leaf temperature. In addition to the models of photosynthesis and stomatal conductance mentioned in the above, additional models of boundary layer conductance and leaf optical properties are required.","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"Currently, only a simple model of optical properties is avaiable that defines the leaf absorptance in PAR and NIR and its emmisivity in the thermal domain. This model is created using the SimpleOptical() function (defaults are provided):","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"using Ecophys\nopt = SimpleOptical(αPAR = 0.80)","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"Two models to compute the boundary layer conductance are available. They differ in the amount of information used regarding the geometry of the leaf. A simple model only accounts for the leaf characteristic length and is the most common approach (as before, a version that supports Quantity objects is also available):","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"gb = simplegb(d = 0.1)\ngbQ = simplegbQ(d = 0.1m)","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"The second model is more complex as it takes into account the aspect ratio (length/width) of the leaf as well as its inclination angle. It will also distinguish between the boundary layer conductance of the front and back side of the leaf. This model relies on unpublished equations fitted to the data reviewed by Schuepp (1993, New Phyto):","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"gbang = gbAngle(d = 0.1, ang = π/4, ar = 0.1)\ngbangQ = gbAngleQ(d = 0.1m, ang = π/4, ar = 0.1)","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"The leaf energy balance is then computed using solve_energy_balance() which will compute the leaf temperature that closes the energy balance as well as the corresponding CO2 assimilationa and transpiration:","category":"page"},{"location":"VPLVerse/Ecophys/","page":"Ecophys package","title":"Ecophys package","text":"Tleaf, A, Tr = solve_energy_balance(c3; gb = gb, opt = opt, PAR = 100.0, ws = 5.0)\nTleafangQ, AangQ, TrangQ = solve_energy_balance(c3Q; gb = gbangQ, opt = opt, PAR = 100.0μmol/m^2/s, ws = 5.0m/s)","category":"page"},{"location":"tutorials/forest/#Forest","page":"Forest","title":"Forest","text":"","category":"section"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"Alejandro Morales","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"In this example we extend the tree example into a forest, where each tree is described by a separate graph object and parameters driving the growth of these trees vary across individuals following a predefined distribution. The data types, rendering methods and growth rules are the same as in the binary tree example:","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"using VirtualPlantLab\nusing Distributions, Plots, ColorTypes\nimport GLMakie\n# Data types\nmodule TreeTypes\n    import VirtualPlantLab\n    # Meristem\n    struct Meristem <: VirtualPlantLab.Node end\n    # Bud\n    struct Bud <: VirtualPlantLab.Node end\n    # Node\n    struct Node <: VirtualPlantLab.Node end\n    # BudNode\n    struct BudNode <: VirtualPlantLab.Node end\n    # Internode (needs to be mutable to allow for changes over time)\n    Base.@kwdef mutable struct Internode <: VirtualPlantLab.Node\n        length::Float64 = 0.10 # Internodes start at 10 cm\n    end\n    # Leaf\n    Base.@kwdef struct Leaf <: VirtualPlantLab.Node\n        length::Float64 = 0.20 # Leaves are 20 cm long\n        width::Float64  = 0.1 # Leaves are 10 cm wide\n    end\n    # Graph-level variables\n    Base.@kwdef struct treeparams\n        growth::Float64 = 0.1\n        budbreak::Float64 = 0.25\n        phyllotaxis::Float64 = 140.0\n        leaf_angle::Float64 = 30.0\n        branch_angle::Float64 = 45.0\n    end\nend\n\nimport .TreeTypes","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"Create geometry + color for the internodes","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"function VirtualPlantLab.feed!(turtle::Turtle, i::TreeTypes.Internode, data)\n    # Rotate turtle around the head to implement elliptical phyllotaxis\n    rh!(turtle, data.phyllotaxis)\n    HollowCylinder!(turtle, length = i.length, height = i.length/15, width = i.length/15,\n                move = true, color = RGB(0.5,0.4,0.0))\n    return nothing\nend","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"Create geometry + color for the leaves","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"function VirtualPlantLab.feed!(turtle::Turtle, l::TreeTypes.Leaf, data)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -data.leaf_angle)\n    # Generate the leaf\n    Ellipse!(turtle, length = l.length, width = l.width, move = false,\n             color = RGB(0.2,0.6,0.2))\n    # Rotate turtle back to original direction\n    ra!(turtle, data.leaf_angle)\n    return nothing\nend","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"Insertion angle for the bud nodes","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"function VirtualPlantLab.feed!(turtle::Turtle, b::TreeTypes.BudNode, data)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -data.branch_angle)\nend","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"Rules","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"meristem_rule = Rule(TreeTypes.Meristem, rhs = mer -> TreeTypes.Node() +\n                                              (TreeTypes.Bud(), TreeTypes.Leaf()) +\n                                         TreeTypes.Internode() + TreeTypes.Meristem())\n\nfunction prob_break(bud)\n    # We move to parent node in the branch where the bud was created\n    node =  parent(bud)\n    # We count the number of internodes between node and the first Meristem\n    # moving down the graph\n    check, steps = has_descendant(node, condition = n -> data(n) isa TreeTypes.Meristem)\n    steps = Int(ceil(steps/2)) # Because it will count both the nodes and the internodes\n    # Compute probability of bud break and determine whether it happens\n    if check\n        prob =  min(1.0, steps*graph_data(bud).budbreak)\n        return rand() < prob\n    # If there is no meristem, an error happened since the model does not allow\n    # for this\n    else\n        error(\"No meristem found in branch\")\n    end\nend\nbranch_rule = Rule(TreeTypes.Bud,\n            lhs = prob_break,\n            rhs = bud -> TreeTypes.BudNode() + TreeTypes.Internode() + TreeTypes.Meristem())","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"The main difference with respect to the tree is that several of the parameters will vary per TreeTypes. Also, the location of the tree and initial orientation of the turtle will also vary. To achieve this we need to:","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"(i) Add two additional initial nodes that move the turtle to the starting position of each tree and rotates it.","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"(ii) Wrap the axiom, rules and the creation of the graph into a function that takes the required parameters as inputs.","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"function create_tree(origin, growth, budbreak, orientation)\n    axiom = T(origin) + RH(orientation) + TreeTypes.Internode() + TreeTypes.Meristem()\n    tree =  Graph(axiom = axiom, rules = (meristem_rule, branch_rule),\n                  data = TreeTypes.treeparams(growth = growth, budbreak = budbreak))\n    return tree\nend","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"The code for elongating the internodes to simulate growth remains the same as for the binary tree example","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"getInternode = Query(TreeTypes.Internode)\n\nfunction elongate!(tree, query)\n    for x in apply(tree, query)\n        x.length = x.length*(1.0 + data(tree).growth)\n    end\nend\n\nfunction growth!(tree, query)\n    elongate!(tree, query)\n    rewrite!(tree)\nend\n\nfunction simulate(tree, query, nsteps)\n    new_tree = deepcopy(tree)\n    for i in 1:nsteps\n        growth!(new_tree, query)\n    end\n    return new_tree\nend","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"Let's simulate a forest of 10 x 10 trees with a distance between (and within) rows of 2 meters. First we generate the original positions of the trees. For the position we just need to pass a Vec object with the x, y, and z coordinates of the location of each TreeTypes. The code below will generate a matrix with the coordinates:","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"origins = [Vec(i,j,0) for i = 1:2.0:20.0, j = 1:2.0:20.0]","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"We may assume that the initial orientation is uniformly distributed between 0 and 360 degrees:","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"orientations = [rand()*360.0 for i = 1:2.0:20.0, j = 1:2.0:20.0]","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"For the growth and budbreak parameters we will assumed that they follow a LogNormal and Beta distribution, respectively. We can generate random values from these distributions using the Distributions package. For the relative growth rate:","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"growths = rand(LogNormal(-2, 0.3), 10, 10)\nhistogram(vec(growths))","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"And for the budbreak parameter:","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"budbreaks = rand(Beta(2.0, 10), 10, 10)\nhistogram(vec(budbreaks))","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"Now we can create our forest by calling the create_tree function we defined earlier with the correct inputs per tree:","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"forest = vec(create_tree.(origins, growths, budbreaks, orientations));","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"By vectorizing create_tree() over the different arrays, we end up with an array of trees. Each tree is a different Graph, with its own nodes, rewriting rules and variables. This avoids having to create a large graphs to include all the plants in a simulation. Below we will run a simulation, first using a sequential approach (i.e. using one core) and then using multiple cores in our computers (please check https://docs.julialang.org/en/v1/manual/multi-threading/ if the different cores are not being used as you may need to change some settings in your computer).","category":"page"},{"location":"tutorials/forest/#Sequential-simulation","page":"Forest","title":"Sequential simulation","text":"","category":"section"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"We can simulate the growth of each tree by applying the method simulate to each tree, creating a new version of the forest (the code below is an array comprehension)","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"newforest = [simulate(tree, getInternode, 2) for tree in forest];","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"And we can render the forest with the function render as in the binary tree example but passing the whole forest at once","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"render(Scene(newforest))","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"If we iterate 4 more iterations we will start seeing the different individuals diverging in size due to the differences in growth rates","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"newforest = [simulate(tree, getInternode, 15) for tree in newforest];\nrender(Scene(newforest))","category":"page"},{"location":"tutorials/forest/#Multithreaded-simulation","page":"Forest","title":"Multithreaded simulation","text":"","category":"section"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"In the previous section, the simulation of growth was done sequentially, one tree after another (since the growth of a tree only depends on its own parameters). However, this can also be executed in multiple threads. In this case we use an explicit loop and execute the iterations of the loop in multiple threads using the macro @threads. Note that the rendering function can also be ran in parallel (i.e. the geometry will be generated separately for each plant and the merge together):","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"using Base.Threads\nnewforest = deepcopy(forest)\n@threads for i in eachindex(forest)\n    newforest[i] = simulate(forest[i], getInternode, 6)\nend\nrender(Scene(newforest), parallel = true)","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"An alternative way to perform the simulation is to have an outer loop for each timestep and an internal loop over the different trees. Although this approach is not required for this simple model, most FSP models will probably need such a scheme as growth of each individual plant will depend on competition for resources with neighbouring plants. In this case, this approach would look as follows:","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"newforest = deepcopy(forest)\nfor step in 1:15\n    @threads for i in eachindex(newforest)\n        newforest[i] = simulate(newforest[i], getInternode, 1)\n    end\nend\nrender(Scene(newforest), parallel = true)","category":"page"},{"location":"tutorials/forest/#Customizing-the-scene","page":"Forest","title":"Customizing the scene","text":"","category":"section"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"Here we are going to customize the scene of our simulation by adding a horizontal tile represting soil and tweaking the 3D representation. When we want to combine plants generated from graphs with any other geometric element it is best to combine all these geometries in a GLScene object. We can start the scene with the newforest generated in the above:","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"scene = Scene(newforest);","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"We can create the soil tile directly, without having to create a graph. The simplest approach is two use a special constructor Rectangle where one species a corner of the rectangle and two vectors defining the two sides of the vectors. Both the sides and the corner need to be specified with Vec just like in the above when we determined the origin of each plant. VPL offers some shortcuts: O() returns the origin (Vec(0.0, 0.0, 0.0)), whereas X, Y and Z returns the corresponding axes and you can scale them by passing the desired length as input. Below, a rectangle is created on the XY plane with the origin as a corner and each side being 11 units long:","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"soil = Rectangle(length = 21.0, width = 21.0)\nrotatey!(soil, pi/2)\nVirtualPlantLab.translate!(soil, Vec(0.0, 10.5, 0.0))","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"We can now add the soil to the scene object with the add! function.","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"VirtualPlantLab.add!(scene, mesh = soil, color = RGB(1,1,0))","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"We can now render the scene that combines the random forest of binary trees and a yellow soil. Notice that in all previous figures, a coordinate system with grids was being depicted. This is helpful for debugging your code but also to help setup the scene (e.g. if you are not sure how big the soil tile should be). Howver, it may be distracting for the visualization. It turns out that we can turn that off with show_axes = false:","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"render(scene, axes = false)","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"We may also want to save a screenshot of the scene. For this, we need to store the output of the render function. We can then resize the window rendering the scene, move around, zoom, etc. When we have a perspective that we like, we can run the save_scene function on the object returned from render. The argument resolution can be adjusted in both render to increase the number of pixels in the final image. A helper function calculate_resolution is provided to compute the resolution from a physical width and height in cm and a dpi (e.g., useful for publications and posters):","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"res = calculate_resolution(width = 16.0, height = 16.0, dpi = 1_000)\noutput = render(scene, axes = false, resolution = res)\nexport_scene(scene = output, filename = \"nice_trees.png\")","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"","category":"page"},{"location":"tutorials/forest/","page":"Forest","title":"Forest","text":"This page was generated using Literate.jl.","category":"page"},{"location":"manual/Graphs/#manual_graph","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"","category":"section"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Alejandro Morales","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"manual/Graphs/#Graphs,-Rules-and-Queries","page":"Dynamic graph creation and manipulation","title":"Graphs, Rules and Queries","text":"","category":"section"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A model in VPL is a (discrete) dynamical model that describes the time evolution of one or more entities (i.e. objects of type graph). Each graph  (usually assumed to be an individual plant) is characterized by a series of nodes (usually organs) that are represented by nodes in a graph. Each node is defined by its own state, including (if applicable) a description of its geometry, color, optical propertes, etc. The dynamic simulation of a graph consists of the creation and destruction of nodes via graph rewriting rules, and changes to the internal state of its nodes with the help of queries.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The 3D structure of a graph is generated by processing its nodes using a Turtle procedural geometry approach (i.e. inspired on Logo's turtle graphs as used in L-systems) and following the topology of the graph. This 3D structure may be used for visualization using a 3D renderer or for simulating  spatial processes.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"VPL does not provide a domain-specific language to implement rules and queries. Rather, they are defined by functions which are stored in objects of types Rule and Query, respectively. Similarly, the nodes of a graph can be of any user-defined type, as long as the user defines the necessary methods to support specific functionality (e.g. the feed! method to generate geometry).","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"VPL is designed around data types and methods. Building a model in VPL typically requires:","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Defining types for the different classes of nodes of a graph\nCreating rules and queries based on these types\nCreating graphs by combining rules and the initial states of the graphs\nCreating additional elements in the scene (e.g. soil)","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A simulation in VPL consists of executing rules iteratively and, within each iteration:","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Use queries to select subset of nodes and modify their states.\nModify graph-level variables directly.\nUse algorithms in VPL to simulate interactions among nodes or between nodes and their environment.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"In addition, VPL allows visualizing the results of a simulation by:","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"3D rendering of the generated scenes\nNetwork graph representing the nodes in the graph","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"VPL is designed to facilitate modular model development, such as using different types of graphs in the same simulation, alternative visualizations of the same scene by mapping internal states of nodes to colors, or including multiple ray tracers in the same simulation. Users may also create their own data types that include graphs as fields or to nest graphs within other graphs.","category":"page"},{"location":"manual/Graphs/#Graph","page":"Dynamic graph creation and manipulation","title":"Graph","text":"","category":"section"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A graph is the basic unit of a model in VPL. Three types of data are stored inside a graph:","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Components of the graph.\nGraph rewriting rules.\nAn user-defined object that characterizes the state of a graph besides its nodes (i.e. graph-level variables).","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The nodes of a graph are objects created by the user that inherit from the abstract type Node. This abstract type enables describing the relationship between nodes using a simple algebra for graph construction (see below). A graph always needs to be initialized by at least one node (i.e. analogous to the axiom of L-Systems), as otherwise graph rewriting rules could not be applied.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The creation of a graph is achieved with the constructor graph(axiom, rules[, vars]) where axiom, rules and vars are the axiom, a tuple with the graph rewriting rules and an user-defined object that stores all graph-level variables, respectively. Note that the last argument is optional. The method rewrite!(graph) takes a graph as input and executes the graph rewriting rules, updating the internal state of the graph in-place. Note that this method will not be called implicitly: it is the responsability of the user to decide when to call this method.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The system is designed to allow rewriting of graphs in parallel, including shared memory approaches such as multi-threading with the Threads.@threads macro. This is ensured by deep-copying axiom, rules and vars so that changes in one graph do not affect other graphs that may be built from the same axioms and rules. If the user wants some state to be shared across graphs, they should define a global variable that is modified during execution of rules. If such approach is used, it is the responsibility of the user to ensure that updates to such global variables are properly locked or executed atomatically.","category":"page"},{"location":"manual/Graphs/#Graph-construction-algebra","page":"Dynamic graph creation and manipulation","title":"Graph-construction algebra","text":"","category":"section"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"When initializing a graph and when specifying a graph rewriting rule it is necessary to indicate the topological relationship between the nodes being added to a graph (i.e. effectively we build graphs by appending sub-graphs). In order to facilitate the description of these relationships, a simple algebra is defined for all objects that inherit from Node.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The + operator indicates a linear parent-child dependency between the operands. For example, M() + L() indicates that the object generated by L() is a child of M(). A branching point is introduced by enclosing the children of a node within () and separating the different branches with \",\". For example, (M(1) + (L(2), L(3)) + M(4) + L(5)) creates a tree that starts with M(1), has 3 children (L(2), L(3) and M(4)) and M(4) has a child L(5).","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A graph always keep tracks of two special nodes: the root and the insertion point. The root is the node that has no parent. When you use a graph rewriting rule (see below) to replace a node a with a graph that has a root node b, the result is that node a is replaced by node b and will inherit all the children and parent from node a (plus the children that b already had in the replacement graph).","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"An insertion point is the node of a graph where new nodes will be connected to when using the + operator. Branches do not modify the insertion point of an existing graph, but linear addition of nodes will always update the insertion point to the last node. Thus, these two expressions produce the same tree structure but with different insertion points: M(1) + (L(2), L(3)) + M(4) + L(5) and M(1) + (L(2), L(3), M(4) + L(5)). In the first case, the insertion point becomes the node L(5) but in the second case it remains at M(1). Keeping track of the insertion point of a graph is important when building  a graph in several steps.","category":"page"},{"location":"manual/Graphs/#Rules","page":"Dynamic graph creation and manipulation","title":"Rules","text":"","category":"section"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Rules consist of directives that define the dynamic evolution of the nodes that form a graph, by replacing a subset of the nodes by one or more nodes. Rules are not executed directly by the user. Instead, they are stored in the graph and executed by the method rewrite!. A rule is made of three parts:","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The type of node to be replaced.\nA function to determine whether a candidate node is to be replaced  or not (lhs function)\nA function that generates a node or subgraph to use as replacement (rhs function).","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The first part must always be present, as it represents the minimum information required to match the rule against nodes inside a graph. This type must be the concrete type of the node rather an abstract type or union type from which the node may inherit. The lhs and rhs functions are optional with the following default values if missing:","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"lhs: x -> true\nrhs: x -> nothing","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A rule with a missing lhs will match all the nodes of the specified type. A rule without an rhs will remove any matched node and all of its children (recursively, such that the topological tree is pruned).","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A Context object includes the data stored inside a node plus its relationship with other nodes in the graph, as well as a reference to the graph-level variables. In order to extract the data stored in the node use the function data(). In order to extract the object containing all the graph-level variables, use the method vars. The Context object may also be used to access other nodes by walking through the graph (see below).","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"For rules that do not capture the context of a node, the lhs part is a function that takes an object of type Context and returns true or false, whereas the rhs part is a function that takes a Context object and returns a node or subgraph.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Although rules may also be used to update the internal state of a node (i.e. by creating a new node of the same type but with a different state), this is only required when the node is an immutable type. Otherwise, one can also (and it is recommended to) use a query for better performance (see below).","category":"page"},{"location":"manual/Graphs/#Matching-relationships-among-nodes","page":"Dynamic graph creation and manipulation","title":"Matching relationships among nodes","text":"","category":"section"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Sometimes the lhs function needs to check the relationships between nodes inside a graph (e.g. match all leaves that belong to a particular branch of a graph). In order achieve that, one can use the functions hasParent() and hasChildren() to check for inmediate connections (i.e. effectively to check whether the node is a root or a leaf in the graph) whereas hasAncestor() and hasDescendant() allow traversing the graph and finding any connected node that matches a specific query. If we need to extract the contents of the node, we may use the corresponding functions parent(), children(), ancestor() and descendant(). Note that children() will return all the children nodes as a tuple, but the rest of functions only return one node at a time. All these functions take a Context object as input and return either true or false (for the functions that start with has) or a Context or tuple of Context objects for the functions that extract the actual connected node. These methods may also be used inside the rhs function of rules. However, to avoid code repetition (and for performance reasons), it is recommended to capture the Context objects of connected in the lhs function and pass them to the rhs as described below (see below).","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"<!– TODO: Add a table with the inputs and outputs of each graph-related method –>","category":"page"},{"location":"manual/Graphs/#Capturing-the-context-of-a-node","page":"Dynamic graph creation and manipulation","title":"Capturing the context of a node","text":"","category":"section"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"In some scenarios, knowing the relationship between nodes in the graph is not sufficient, because data stored inside those related nodes is required in the rhs function of a rule. In those cases, an extra argument to the constructor for a Rule is required (captures = true) to indicate that this rule will pass additional data from the lhs to the rhs function. Then, the lhs function should return a tuple, where the first element is still true or false (to indicate whether the rule matches a node) and the second element is a tuple of Context objects associated to the nodes being matched. If no match occurs, it is sufficient to return (false, ()), where () indicates an empty tuple. The rhs function should then be a function that takes as first argument the Context object of the node being replaced, and an additional argument for every Context object being captured on the lhs function and passed to the rhs function.","category":"page"},{"location":"manual/Graphs/#Execution-of-rules","page":"Dynamic graph creation and manipulation","title":"Execution of rules","text":"","category":"section"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Rules are executed in the same order in which they are added to the graph object. Then, the lhs part of each rule is tested against all nodes of the specified type in the same order in which they were added to the graph. Similarly, the rhs part of a rule will be applied to those nodes that matched the lhs part, in the same order as in the matching.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"<!– TODO: Diagram on rule execution –>","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The lhs part of all the rules are executed first and VPL will check that each node is not matched by more than rule. In case there is more than one match, an error will be generated. After all the lhs pars are executed, then the rhs parts are executed on the matched nodes. Although generating an error may seem restrictive, the  reasoning for this approach is as follows:","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"Graph rewriting is, conceptually, a parallel operation, so two rules cannot replace the same node as that would mean the result depends on the order in which the rules are executed.\nNew nodes will be generated by graph rewriting rules that could be matched by the lhs of other graph rewriting rules. To guarantee that all rules rewrite the same graph, all nodes that need to be replaced are identified before any rhs function is executed.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"In essence, you need to program your model such that it does not rely on any specific order of execution of the graph rewriting rules.","category":"page"},{"location":"manual/Graphs/#Query-and-apply","page":"Dynamic graph creation and manipulation","title":"Query and apply","text":"","category":"section"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The apply() function will apply a Query object to a graph and return a list of nodes that match the query. The main differences between rules and queries is that queries do not have an rhs part,they are not stored inside the graph and the user decides when to apply them. Note that that a query does not modify a graph, it simply returns a collection of nodes matched by it. Another difference is that a query always return a reference to the data stored  inside the node, rather than a Context object (so no need to use data()). Note that if a query is used to modify the data stored in a node, then the node needs to be a mutable type.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"For nodes of immutable type, a graph rewriting rule must be used to replace the node. This may seem like a limitation but the fact is that, if one needs to modify the state of an object after it has been created then, by definition, that object should be of mutable type. If immutability is required for some reason, one may keep track of associated variables at the graph level, but such kind of manual book-keeping is not recommended.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"A query is useful when the data stored inside the nodes of a graph need to be modified or when these data are used as input for some function. Unlike in rules, the order in which queries are applied in the code will affect the result of the simulation, especially whether they are applied before or after a call to rewrite!. The reasoning for this is that queries are not altering the structure of a graph (since they do not remove nor create nodes) and multiple queries can (and often do) match the same node. For example, one query will alter an internal variable that is then need as input by another query. Thus, whereas rules implicitly follow a parallel programming paradigm, queries follow a sequential programming paradigm.","category":"page"},{"location":"manual/Graphs/#Direct-access-to-nodes","page":"Dynamic graph creation and manipulation","title":"Direct access to nodes","text":"","category":"section"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"It is possible to access nodes directly by their internal ID. This should be done carefully as the internal ID depends on the internal state of VPL and may not be reproducible across different runs, so only use it for interactive exploration of a model. It is possible to identify the internal ID of a node by using the method draw() with the default node_label method (see section on Visualization).","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The internal ID is generated by a counter inside VPL which can be reset by using VPL.Core.resetID(). Once the ID of a node is known, it is possible to access using bracket notation [] on a Graph object or any subgraph generated with the graph construction algebra.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"module L\n    using VirtualPlantLab\n\n    struct N <: Node\n        val::Int\n    end\nend\nimport .L\nusing VirtualPlantLab\nPlantGraphs.reset_id!()\naxiom = L.N(1) + (L.N(3), L.N(4)) + L.N(2) + (L.N(5), L.N(6))\ndata(axiom[2])","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"The bracket notation will return the Node object that wraps the data stored by the user. Notice how the internal ID does not match the value stored in the node, but rather the order in which the nodes were processed during the construction of the axiom. In this case that order coincides with reading the code left-to-right but that will not always be the case. If we create the Graph object that contains the axiom, we can access the node with the same syntax.","category":"page"},{"location":"manual/Graphs/","page":"Dynamic graph creation and manipulation","title":"Dynamic graph creation and manipulation","text":"graph = Graph(axiom = axiom)\ndata(graph[2])","category":"page"},{"location":"developers/organization/#organization","page":"Internal organization","title":"Organization of VPL","text":"","category":"section"},{"location":"developers/organization/","page":"Internal organization","title":"Internal organization","text":"In terms of implementation, VPL consists of a GitHub organization (VirtualPlantLab) that contains 9 registered Julia packages. The packages are organized in two groups:","category":"page"},{"location":"developers/organization/","page":"Internal organization","title":"Internal organization","text":"The VPL core: These are the basic packages that provide the functionality to build FSP models. The user is normally not intended to use these packages directly but rather through the interface offered by VirtualPlantLab.jl. Developers who want to access the source code (and potentially modify it) should first identify the package that contains the functionality they are interested in.\nThe VPLverse: These are packages that are built on top of the VPL core or standalone packages that provide additional functionality to build FSP models. The user needs to install these packages separately and import them if they wish to use them.","category":"page"},{"location":"developers/organization/#The-VPL-core","page":"Internal organization","title":"The VPL core","text":"","category":"section"},{"location":"developers/organization/","page":"Internal organization","title":"Internal organization","text":"The core of VPL consists of five packages that provide the basic functionality plus the interface meta-package VirtualPlantLab.jl (which simply collects and exports the public API of the core packages). The packages that form the core of VPL are:","category":"page"},{"location":"developers/organization/","page":"Internal organization","title":"Internal organization","text":"PlantGraphs.jl: A dynamic graph rewriting system where user-defined objects are stored in each node and these nodes can be queried and replaced by sub-graphs through dynamic production rules. Everything related to graph rewriting is implemented in this package (e.g., the Node abstract type, as well as Graph, Query and Rule).\nPlantGeomPrimitives.jl: A collection of 3D primitives implemented as triangular meshes stored in a scene for the purpose of visualization and ray tracing. This package defines the Scene data type that is used to store 3D meshes.\nPlantGeomTurtle.jl: An implementation of turtle algorithms that can generate 3D meshes from graphs representing the topology and structure of individual plants. This package defines the feed! function that users work with when generating 3D meshes from their own data types.\nPlantRayTracer.jl: A physics-based forward Monte Carlo ray tracer for the purpose of computing light interception by individual plants under field or controlled growth conditions. The ray tracer is multithreaded and uses bounding volume hierarchies. Everything related to ray tracing (light sources, materials, etc.) is implemented in this package, except the specific functions to emulate sky conditions (see SkyDomes.jl below).\nPlantViz.jl: 3D rendering of scenes based on the different backends of Makie.jl. This package defines the render function.","category":"page"},{"location":"developers/organization/#The-VPLverse","page":"Internal organization","title":"The VPLverse","text":"","category":"section"},{"location":"developers/organization/","page":"Internal organization","title":"Internal organization","text":"VPL contains all the basic functionality to build FSP models but, as indicated earlier, the emphasis is on minimal, simple and transparent interfaces. In order to facilitate the construction of non-trivial FSP models, an ecosystem of packages built around VPL provide additional support to the modeler by offering reusable modules that can be reused in new models.","category":"page"},{"location":"developers/organization/","page":"Internal organization","title":"Internal organization","text":"The packages currently planned for VPLverse are:","category":"page"},{"location":"developers/organization/","page":"Internal organization","title":"Internal organization","text":"Ecophys.jl - Algorithms and data structures to simulate ecophysiological processes including photosynthesis, transpiration, leaf energy balance, phenology or respiration.\nSkyDomes.jl - Algorithms to simulate different sky conditions in terms of the intensity of solar radiation and its spatial and angular distribution.\nPlantSimEngine.jl - A package for the simulation and modeling of plants, soil and atmosphere. It is designed to help researchers and practitioners prototype, implement, test plant/crop models at any scale, without the hassle of computer science technicality behind model coupling, running on several time-steps or objects.\nPlantBioPhysics.jl - A package to deal with biophysical processes of plants such as photosynthesis, conductances for heat, water vapor and CO₂, latent, sensible energy fluxes, net radiation and temperature.","category":"page"},{"location":"tutorials/context/#Context-sensitive-rules","page":"Context sensitive rules","title":"Context sensitive rules","text":"","category":"section"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"Alejandro Morales","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"This examples goes back to a very simple situation: a linear sequence of 3 cells. The point of this example is to introduce relational growth rules and context capturing.","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"A relational rules matches nodes based on properties of neighbouring nodes in the graph. This requires traversing the graph, which can be done with the methods parent and children on the Context object of the current node, which return a list of Context objects for the parent or children nodes.","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"In some cases, it is not only sufficient to query the neighbours of a node but also to use properties of those neighbours in the right hand side component of the rule. This is know as \"capturing the context\" of the node being updated. This can be done by returning the additional nodes from the lhs component (in addition to true or false) and by accepting these additional nodes in the rhs component. In addition, we tell VPL that this rule is capturing the context with captures = true.","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"In the example below, each Cell keeps track of a state variable (which is either 0 or 1). Only the first cell has a state of 1 at the beginning. In the growth rule, we check the father of each Cell. When a Cell does not have a parent, the rule does not match, otherwise, we pass capture the parent node. In the right hand side, we replace the cell with a new cell with the state of the parent node that was captured. Note that that now, the rhs component gets a new argument, which corresponds to the context of the father node captured in the lhs.","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"using VirtualPlantLab\nmodule types\n    using VirtualPlantLab\n    struct Cell <: Node\n        state::Int64\n    end\nend\nimport .types: Cell\nfunction transfer(context)\n    if has_parent(context)\n        return (true, (parent(context), ))\n    else\n        return (false, ())\n    end\nend\nrule = Rule(Cell, lhs = transfer, rhs = (context, father) -> Cell(data(father).state), captures = true)\naxiom = Cell(1) + Cell(0) + Cell(0)\npop = Graph(axiom = axiom, rules = rule)","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"In the original state defined by the axiom, only the first node contains a state of 1. We can retrieve the state of each node with a query. A Query object is a like a Rule but without a right-hand side (i.e., its purpose is to return the nodes that match a particular condition). In this case, we just want to return all the Cell nodes. A Query object is created by passing the type of the node to be queried as an argument to the Query function. Then, to actually execute the query we need to use the apply function on the graph.","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"getCell = Query(Cell)\napply(pop, getCell)","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"If we rewrite the graph one we will see that a second cell now has a state of 1.","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"rewrite!(pop)\napply(pop, getCell)","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"And a second iteration results in all cells have a state of 1","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"rewrite!(pop)\napply(pop, getCell)","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"Note that queries may not return nodes in the same order as they were created because of how they are internally stored (and because queries are meant to return collection of nodes rather than reconstruct the topology of a graph). If we need to process nodes in a particular order, then it is best to use a traversal algorithm on the graph that follows a particular order (for example depth-first traversal with traverse_dfs()). This algorithm requires a function that applies to each node in the graph. In this simple example we can just store the state of each node in a vector (unlike Rules and Queries, this function takes the actual node as argument rather than a Context object, see the documentation for more details):","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"pop  = Graph(axiom = axiom, rules = rule)\nstates = Int64[]\ntraverse_dfs(pop, fun = node -> push!(states, node.state))\nstates","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"Now the states of the nodes are in the same order as they were created:","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"rewrite!(pop)\nstates = Int64[]\ntraverse_dfs(pop, fun = node -> push!(states, node.state))\nstates","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"","category":"page"},{"location":"tutorials/context/","page":"Context sensitive rules","title":"Context sensitive rules","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/geometry/#Scenes-and-3D-meshes","page":"Scenes and 3D meshes","title":"Scenes and 3D meshes","text":"","category":"section"},{"location":"api/geometry/","page":"Scenes and 3D meshes","title":"Scenes and 3D meshes","text":"CurrentModule = PlantGeomPrimitives","category":"page"},{"location":"api/geometry/#Public-API","page":"Scenes and 3D meshes","title":"Public API","text":"","category":"section"},{"location":"api/geometry/","page":"Scenes and 3D meshes","title":"Scenes and 3D meshes","text":"Modules = [PlantGeomPrimitives]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/geometry/#PlantGeomPrimitives.Mesh-Union{Tuple{Any}, Tuple{FT}, Tuple{Any, Any}, Tuple{Any, Any, Type{FT}}} where FT<:AbstractFloat","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Mesh","text":"Mesh(nt, nv = nt*3)\n\nGenerate a triangular dense mesh with enough memory allocated to store nt  triangles and nv vertices. The behaviour is equivalent to generating an empty  mesh but may be computationally more efficient when appending a large number of  primitives. If a lower floating precision is required, this may be specified as an optional third argument as in Mesh(10, 30, Float32).\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.Mesh-Union{Tuple{}, Tuple{Type{FT}}, Tuple{FT}} where FT<:AbstractFloat","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Mesh","text":"Mesh()\n\nGenerate an empty triangular dense mesh that represents a primitive or 3D scene.  By default a Mesh object will only accept coordinates in double floating  precision (Float64) but a lower precision can be generated by specifying the  corresponding data type as in Mesh(Float32).\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.Scene-Tuple{Vector{<:PlantGeomPrimitives.Scene}}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Scene","text":"Scene(scenes)\n\nMerge multiple Scene objects into one.\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.Scene-Tuple{}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Scene","text":"Scene(; mesh = Mesh(Float64), colors = Colorant[], material_ids = Int[], materials = Material[])\n\nCreate a Scene object from a triangular mesh (mesh), a vector of colors (colors, any type that inherits from Colorant from the ColorTypes package), a vector of material IDs (material_ids that link indivudal triangles to material objects) and a vector of materials (materials, any object that inherits from Material). See packages PlantViz and PlantRayTracer for more details on materials and colors.\n\njulia> t = Triangle(length = 2.0, width = 2.0);\n\njulia> s = Scene(mesh = t);\n\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.Vec","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Vec","text":"Vec(x, y, z)\n\n3D vector or point with coordinates x, y and z.\n\njulia> v = Vec(0.0, 0.0, 0.0);\n\njulia> v = Vec(0f0, 0f0, 0f0);\n\n\n\n\n\n","category":"type"},{"location":"api/geometry/#PlantGeomPrimitives.BBox-Union{Tuple{FT}, Tuple{StaticArraysCore.SVector{3, FT}, StaticArraysCore.SVector{3, FT}}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.BBox","text":"BBox(pmin::Vec, pmax::Vec)\n\nBuild an axis-aligned bounding box given the vector of minimum (pmin) and maximum (pmax) coordinates.\n\nExamples\n\njulia> p0 = Vec(0.0, 0.0, 0.0);\n\njulia> p1 = Vec(1.0, 1.0, 1.0);\n\njulia> box = BBox(p0, p1);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.BBox-Union{Tuple{PlantGeomPrimitives.Mesh{VT}}, Tuple{VT}, Tuple{FT}} where {FT, VT<:StaticArraysCore.SVector{3, FT}}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.BBox","text":"BBox(m::Mesh)\n\nBuild a tight axis-aligned bounding box around a Mesh object.\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.Ellipse-Union{Tuple{}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Ellipse","text":"Ellipse(;length = 1.0, width = 1.0, n = 20)\n\nCreate an  ellipse with dimensions given by length and width, discretized into n triangles (must be even) and standard location and orientation.\n\nExamples\n\njulia> Ellipse(;length = 1.0, width = 1.0, n = 20);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.HollowCone-Union{Tuple{}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.HollowCone","text":"HollowCone(;length = 1.0, width = 1.0, height = 1.0, n = 20)\n\nCreate a hollow cone with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\n\nExamples\n\njulia> HollowCone(;length = 1.0, width = 1.0, height = 1.0, n = 20);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.HollowCube-Union{Tuple{}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.HollowCube","text":"HollowCube(;length = 1.0, width = 1.0, height = 1.0)\n\nCreate a hollow cube with dimensions given by length, width and height, standard location and orientation.\n\nExamples\n\njulia> HollowCube(;length = 1.0, width = 1.0, height = 1.0);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.HollowCylinder-Union{Tuple{}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.HollowCylinder","text":"HollowCylinder(;length = 1.0, width = 1.0, height = 1.0, n = 40)\n\nCreate a hollow cylinder with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\n\nExamples\n\njulia> HollowCylinder(;length = 1.0, width = 1.0, height = 1.0, n = 40);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.HollowFrustum-Union{Tuple{}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.HollowFrustum","text":"HollowFrustum(;length = 1.0, width = 1.0, height = 1.0, n = 40)\n\nCreate a hollow frustum with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\n\nExamples\n\njulia> HollowFrustum(;length = 1.0, width = 1.0, height = 1.0, n = 40);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.O-Union{Tuple{}, Tuple{Type{FT}}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.O","text":"O()\n\nReturns the origin of the 3D coordinate system as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in O(Float32).\n\njulia>  O();\n\njulia>  O(Float32);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.Rectangle-Union{Tuple{}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Rectangle","text":"Rectangle(;length = 1.0, width = 1.0)\n\nCreate a rectangle with dimensions given by length and width, standard location and orientation.\n\nExamples\n\njulia> Rectangle(;length = 1.0, width = 1.0);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.SolidCone-Union{Tuple{}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.SolidCone","text":"SolidCone(;length = 1.0, width = 1.0, height = 1.0, n = 40)\n\nCreate a solid cone with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\n\nExamples\n\njulia> SolidCone(;length = 1.0, width = 1.0, height = 1.0, n = 40);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.SolidCube-Union{Tuple{}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.SolidCube","text":"SolidCube(;length = 1.0, width = 1.0, height = 1.0)\n\nCreate a solid cube with dimensions given by length, width and height, standard location and orientation.\n\nExamples\n\njulia> SolidCube(;length = 1.0, width = 1.0, height = 1.0);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.SolidCylinder-Union{Tuple{}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.SolidCylinder","text":"SolidCylinder(;length = 1.0, width = 1.0, height = 1.0, n = 80)\n\nCreate a solid cylinder with dimensions given by length, width and height, discretized into n triangles (must be even) and standard location and orientation.\n\nExamples\n\njulia> SolidCylinder(;length = 1.0, width = 1.0, height = 1.0, n = 80);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.SolidFrustum-Union{Tuple{}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.SolidFrustum","text":"SolidFrustum(;length = 1.0, width = 1.0, height = 1.0, n = 40)\n\nCreate a solid frustum with dimensions given by length, width and height, discretized into n triangles and standard location and orientation.\n\nExamples\n\njulia> SolidFrustum(;length = 1.0, width = 1.0, height = 1.0, n = 40);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.Trapezoid-Union{Tuple{}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Trapezoid","text":"Trapezoid(;length = 1.0, width = 1.0, ratio = 1.0)\n\nCreate a trapezoid with dimensions given by length and the larger width and the ratio between the smaller and larger widths. The trapezoid is generted at the standard location and orientation.\n\nExamples\n\njulia> Trapezoid(;length = 1.0, width = 1.0, ratio = 1.0);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.Triangle-Union{Tuple{}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Triangle","text":"Triangle(;length = 1.0, width = 1.0)\n\nCreate a triangle with dimensions given by length and width, standard location and orientation.\n\nExamples\n\njulia> Triangle(;length = 1.0, width = 1.0);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.X-Tuple{FT} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.X","text":"X(s)\n\nReturns scaled vector in the direction of the X axis with length s as a Vec object using the same floating point precision as s.\n\njulia>  X(1.0);\n\njulia>  X(1f0) ;\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.X-Union{Tuple{}, Tuple{Type{FT}}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.X","text":"X()\n\nReturns an unit vector in the direction of the X axis as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in X(Float32).\n\njulia>  X();\n\njulia>  X(Float32);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.Y-Tuple{FT} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Y","text":"Y(s)\n\nReturns scaled vector in the direction of the Y axis with length s as a Vec object using the same floating point precision as s.\n\njulia>  Y(1.0);\n\njulia>  Y(1f0);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.Y-Union{Tuple{}, Tuple{Type{FT}}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Y","text":"Y()\n\nReturns an unit vector in the direction of the Y axis as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in Y(Float32).\n\njulia>  Y();\n\njulia>  Y(Float32);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.Z-Tuple{FT} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Z","text":"Z(s)\n\nReturns scaled vector in the direction of the Z axis with length s as a Vec object using the same floating point precision as s.\n\njulia>  Z(1.0);\n\njulia>  Z(1f0);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.Z-Union{Tuple{}, Tuple{Type{FT}}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.Z","text":"Z()\n\nReturns an unit vector in the direction of the Z axis as a Vec object. By default, the coordinates will be in double floating precision (Float64) but it is possible to generate a version with lower floating precision as in Z(Float32).\n\njulia>  Z();\n\njulia>  Z(Float32);\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.add!-Tuple{Any}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.add!","text":"add!(scene; mesh, color = nothing, material = nothing)\n\nManually add a 3D mesh to an existing Scene object (scene) with optional colors and materials\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.area-Tuple{PlantGeomPrimitives.Mesh}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.area","text":"area(m::Mesh)\n\nTotal surface area of a mesh (as the sum of areas of individual triangles).\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.areas-Tuple{PlantGeomPrimitives.Mesh}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.areas","text":"areas(m::Mesh)\n\nA vector with the areas of the different triangles that form a mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.colors-Tuple{PlantGeomPrimitives.Scene}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.colors","text":"colors(scene::Scene)\n\nExtract the vector of Colorant objects stored inside a scene (used for rendering)\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.load_mesh-Union{Tuple{Any}, Tuple{FT}, Tuple{Any, Type{FT}}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.load_mesh","text":"load_mesh(filename)\n\nImport a mesh from a file given by filename. Supported formats include stl, ply, obj and msh. By default, this will generate a Mesh object that uses double floating-point precision. However, a lower precision can be specified by passing the relevant data type as in load_mesh(filename, Float32).\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.materials-Tuple{PlantGeomPrimitives.Scene}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.materials","text":"materials(scene::Scene)\n\nExtract the vector of Material objects stored inside a scene (used for ray tracing)\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.mesh-Tuple{PlantGeomPrimitives.Scene}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.mesh","text":"mesh(scene::Scene)\n\nExtract the triangular mesh stored inside a scene (used for ray tracing & rendering)\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.ntriangles-Tuple{PlantGeomPrimitives.Mesh}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.ntriangles","text":"ntriangles(mesh)\n\nExtract the number of triangles in a mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.nvertices-Tuple{PlantGeomPrimitives.Mesh}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.nvertices","text":"nvertices(mesh)\n\nThe number of vertices in a mesh.\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.rotate!-Union{Tuple{PlantGeomPrimitives.Mesh}, Tuple{FT}} where FT","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.rotate!","text":"rotate!(m::Mesh; x::Vec, y::Vec, z::Vec)\n\nRotate a mesh m to a new coordinate system given by x, y and z\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.rotatex!-Tuple{PlantGeomPrimitives.Mesh, Any}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.rotatex!","text":"rotatex!(m::Mesh, θ)\n\nRotate a mesh m around the x axis by θ rad.\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.rotatey!-Tuple{PlantGeomPrimitives.Mesh, Any}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.rotatey!","text":"rotatey!(m::Mesh, θ)\n\nRotate a mesh m around the y axis by θ rad.\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.rotatez!-Tuple{PlantGeomPrimitives.Mesh, Any}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.rotatez!","text":"rotatez!(m::Mesh, θ)\n\nRotate a mesh m around the z axis by θ rad.\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.save_mesh-Tuple{Any}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.save_mesh","text":"save_mesh(mesh; fileformat = STL_BINARY, filename)\n\nSave a mesh into an external file using a variety of formats.\n\nArguments\n\nmesh: Object of type Mesh.\nfileformat: Format to store the mesh. This is a keyword argument.\nfilename: Name of the file in which to store the mesh.\n\nDetails\n\nThe fileformat should take one of the following arguments: STL_BINARY, STL_ASCII, PLY_BINARY, PLY_ASCII or OBJ. Note that these names should not be quoted as strings.\n\nReturn\n\nThis function does not return anything, it is executed for its side effect.\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.scale!-Tuple{PlantGeomPrimitives.Mesh, StaticArraysCore.SVector{3}}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.scale!","text":"scale!(m::Mesh, Vec)\n\nScale a mesh m along the three axes provided by vec\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#PlantGeomPrimitives.translate!-Tuple{PlantGeomPrimitives.Mesh, StaticArraysCore.SVector{3}}","page":"Scenes and 3D meshes","title":"PlantGeomPrimitives.translate!","text":"translate!(m::Mesh, v::Vec)\n\nTranslate the mesh m by vector v\n\n\n\n\n\n","category":"method"},{"location":"api/geometry/#Private","page":"Scenes and 3D meshes","title":"Private","text":"","category":"section"},{"location":"api/geometry/","page":"Scenes and 3D meshes","title":"Scenes and 3D meshes","text":"Private functions, types or constants from PlantGeomPrimitives. These are not exported, so you need to prefix the function name with PlantGeomPrimitives. to access them. Also bear in mind that these are not part of the public API, so they may change without notice.","category":"page"},{"location":"api/geometry/","page":"Scenes and 3D meshes","title":"Scenes and 3D meshes","text":"Modules = [PlantGeomPrimitives]\nPublic = false\nPrivate = true","category":"page"},{"location":"api/graphs/#Graphs","page":"Graphs","title":"Graphs","text":"","category":"section"},{"location":"api/graphs/","page":"Graphs","title":"Graphs","text":"CurrentModule = PlantGraphs","category":"page"},{"location":"api/graphs/#Public-API","page":"Graphs","title":"Public API","text":"","category":"section"},{"location":"api/graphs/","page":"Graphs","title":"Graphs","text":"Includes functions defined by PlantGraphs as well as methods for functions defined by other packages.","category":"page"},{"location":"api/graphs/","page":"Graphs","title":"Graphs","text":"Modules = [PlantGraphs]\nPublic = true\nPrivate = false","category":"page"},{"location":"api/graphs/#PlantGraphs.Graph-Tuple{}","page":"Graphs","title":"PlantGraphs.Graph","text":"Graph(;axiom, rules = nothing, data = nothing)\n\nCreate a dynamic graph from an axiom, one or more rules and, optionally, graph-level variables.\n\nArguments\n\naxiom: A single object inheriting from Node or a subgraph generated  with\n\nthe graph construction DSL. It should represent the initial state of the dynamic graph.\n\nKeywords\n\nrules:  A single Rule object or a tuple of Rule objects (optional). It\n\nshould include all graph-rewriting rules of the graph.\n\ndata: A single object of any user-defined type (optional). This will be the\n\ngraph-level variable accessible from any rule or query applied to the graph.\n\nFT: Floating-point precision to be used when generating the 3D geometry\n\nassociated to a graph.\n\nDetails\n\nAll arguments are assigned by keyword. The axiom and rules are deep-copied when creating the graph but the graph-level variables (if a copy is needed due to mutability, the user needs to care of that).\n\nReturns\n\nAn object of type Graph representing a dynamic graph. Printing this object results in a human-readable description of the type of data stored in the graph.\n\nExamples\n\njulia> let\n           struct A0 <: Node end\n           struct B0 <: Node end\n           axiom = A0() + B0()\n           no_rules_graph = Graph(axiom = axiom)\n           rule = Rule(A0, rhs = x -> A0() + B0())\n           rules_graph = Graph(axiom = axiom, rules = rule)\n       end\nDynamic graph with 2 nodes of types A0,B0 and 1 rewriting rules.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.Node","page":"Graphs","title":"PlantGraphs.Node","text":"Node\n\nAbstract type from which every node in a graph should inherit. This allows using the graph construction DSL.\n\nExample\n\njulia> let\n         struct bar <: Node\n           x::Int\n         end\n         b1 = bar(1)\n         b2 = bar(2)\n         b1 + b2\n       end;\n\n\n\n\n\n","category":"type"},{"location":"api/graphs/#PlantGraphs.Query-Tuple{DataType}","page":"Graphs","title":"PlantGraphs.Query","text":"Query(N::DataType; condition = x -> true)\n\nCreate a query that matches nodes of type nodetype and a condition.\n\nArguments\n\nN::DataType: Type of node to be matched.\n\nKeywords\n\ncondition: Function or function-like object that checks if a node should be\n\nselected.\n\nDetails\n\nIf the nodetype should refer to a concrete type and match one of the types stored inside the graph. Abstract types or types that are not contained in the graph are allowed but the query will never return anything.\n\nThe condition must be a function or function-like object that takes a Context as input and returns true or false. The default condition always return true such that the query will\n\nReturns\n\nIt returns an object of type Query. Use apply() to execute the query on a dynamic graph.\n\nExamples\n\njulia> struct A <: Node end\n\n\njulia> struct B <: Node end\n\n\njulia> axiom = A() + B();\n\njulia> g = Graph(axiom = axiom)\nDynamic graph with 2 nodes of types A,B and 0 rewriting rules.\n\njulia> query = Query(A)\nQuery object for nodes of type A\n\njulia> apply(g, query)\n1-element Vector{A}:\n A()\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.Rule-Tuple{DataType}","page":"Graphs","title":"PlantGraphs.Rule","text":"Rule(nodetype; lhs = x -> true, rhs = x -> nothing, captures = false)\n\nCreate a replacement rule for nodes of type nodetype.\n\nArguments\n\nnodetype: Type of node to be matched.\n\nKeywords\n\nlhs: Function or function-like object that takes a Context object and\n\nreturns whether the node should be replaced or not (with true or false).\n\nrhs: Function or function-like object that takes one or more Context\n\nobjects and returns a replacement graph or nothing. If it takes several inputs, the first one will correspond to the node being replaced.\n\ncaptures: Either false or true to indicate whether the left-hand side\n\nof the rule is capturing nodes in the context of the replacement node to be used for the construction of the replace graph.\n\nDetails\n\nSee VPL documentation for details on rule-based graph rewriting.\n\nReturn\n\nAn object of type Rule.\n\nExamples\n\njulia> let\n           struct A <: Node end\n           struct B <: Node end\n           axiom = A() + B()\n           rule = Rule(A, rhs = x -> A() + B())\n           rules_graph = Graph(axiom = axiom, rules = rule)\n           rewrite!(rules_graph)\n           end\n\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#AbstractTrees.children-Tuple{PlantGraphs.Context}","page":"Graphs","title":"AbstractTrees.children","text":"children(c::Context)\n\nReturns all the children of a node as Context objects.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#Base.parent-Tuple{PlantGraphs.Context}","page":"Graphs","title":"Base.parent","text":"parent(c::Context; nsteps::Int)\n\nReturns the parent of a node that is nsteps away towards the root of the graph. Intended to be used within a rule or query.\n\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\n\nKeywords\n\nnsteps: Number of steps to traverse the graph towards the root node.\n\nDetails\n\nIf has_parent() returns false for the same node or the algorithm has reached the root node but nsteps have not been reached, then parent() will return missing, otherwise it returns the Context associated to the matching node.\n\nReturn\n\nReturn a Context object or missing.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(2) + (B1(1) + A1(3), B1(4))\n           g = Graph(axiom = axiom)\n               function qfun(n)\n               np = parent(n, nsteps = 2)\n               !ismissing(np) && data(np).val == 2\n           end\n           Q1 = Query(A1, condition = qfun)\n           R1 = apply(g, Q1)\n           Q2 = Query(B1, condition = qfun)\n           R2 = apply(g, Q2)\n           (R1,R2)\n       end\n(A1[A1(3)], B1[])\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.ancestor-Tuple{PlantGraphs.Context}","page":"Graphs","title":"PlantGraphs.ancestor","text":"ancestor(c::Context; condition = x -> true, max_level::Int = typemax(Int))\n\nReturns the first ancestor of a node that matches the condition. Intended to be used within a rule or query.\n\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\n\nKeywords\n\ncondition: An user-defined function that takes a Context object as input\n\nand returns true or false.\n\nmax_level::Int: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\n\nDetails\n\nIf has_ancestor() returns false for the same node and condition, ancestor() will return missing, otherwise it returns the Context associated to the matching node\n\nReturns\n\nReturn a Context object or missing.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + (B1(1) + A1(3), B1(4))\n           g = Graph(axiom = axiom)\n               function qfun(n)\n               na = ancestor(n, condition = x -> (data(x).val == 1))\n               if !ismissing(na)\n                   data(na) isa B1\n               else\n                   false\n               end\n           end\n           Q1 = Query(A1, condition = qfun)\n           R1 = apply(g, Q1)\n           Q2 = Query(B1, condition = qfun)\n           R2 = apply(g, Q2)\n           (R1,R2)\n       end\n(A1[A1(3)], B1[])\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.apply-Union{Tuple{N}, Tuple{Q}, Tuple{PlantGraphs.Graph, PlantGraphs.Query{N, Q}}} where {Q, N}","page":"Graphs","title":"PlantGraphs.apply","text":"apply(g::Graph, query::Query)\n\nReturn an array with all the nodes in the graph that match the query supplied by the user.\n\nExamples\n\njulia> struct A <: Node end\n\n\njulia> struct B <: Node end\n\n\njulia> axiom = A() + B();\n\njulia> g = Graph(axiom = axiom)\nDynamic graph with 2 nodes of types A,B and 0 rewriting rules.\n\njulia> query = Query(A)\nQuery object for nodes of type A\n\njulia> apply(g, query)\n1-element Vector{A}:\n A()\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.calculate_resolution-Tuple{}","page":"Graphs","title":"PlantGraphs.calculate_resolution","text":"calculate_resolution(;width = 1024/300*2.54, height = 768/300*2.54,\n                      format = \"raster\", dpi = 300)\n\nCalculate the resolution required to achieve a specific width and height (in cm) of the exported image, with a particular dpi (for raster formats).\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.data-Tuple{PlantGraphs.Context}","page":"Graphs","title":"PlantGraphs.data","text":"data(c::Context)\n\nReturns the data stored in a node. Intended to be used within a rule or query.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.data-Tuple{PlantGraphs.Graph}","page":"Graphs","title":"PlantGraphs.data","text":"data(g::Graph)\n\nReturns the graph-level variables.\n\nExample\n\njulia> struct A <: Node end\n\n\njulia> axiom = A()\nA()\n\njulia> g = Graph(axiom = axiom, data = 2)\nDynamic graph with 1 nodes of types A and 0 rewriting rules.\nDynamic graph variables stored in struct of type Int64\n\njulia> data(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.draw-Tuple{PlantGraphs.Graph}","page":"Graphs","title":"PlantGraphs.draw","text":"draw(g::Graph; resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15,\n     node_size = 5)\n\nVisualize a graph as network diagram.\n\nArguments\n\ng::Graph: The graph to be visualized.\n\nKeywords\n\nresolution = (1920, 1080): The resolution of the image to be rendered, in\n\npixels (online relevant for native and web backends). Default resolution is HD.\n\nnlabels_textsize = 15: Customize the size of the labels in the diagram.\narrow_size = 15: Customize the size of the arrows representing edges in the\n\ndiagram.\n\nnode_size = 5: Customize the size of the nodes in the diagram.\n\nDetails\n\nBy default, nodes are labelled with the type of data stored and their unique ID. See function node_label() to customize the label for different types of data.\n\nSee save from FileIO to export the network diagram as a raster or vector image (depending on the backend). The function calculate_resolution() can be useful to ensure a particular dpi of the exported image (assuming some physical size).\n\nThe graphics backend will interact with the environment where the Julia code is being executed (i.e., terminal, IDE such as VS Code, interactive notebook such as Jupyter or Pluto). These interactions are all controlled by the graphics package Makie that VPL relies on. Some details on the expected behavior specific to draw() can be found in the general VPL documentation.\n\nReturns\n\nThis function returns a Makie Figure object, while producing the visualization as a side effect.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + (B1(1) + A1(3), B1(4))\n           g = Graph(axiom = axiom)\n           import CairoMakie # or GLMakie, WGLMakie, etc.\n           draw(g)\n       end\nFigure()\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.draw-Tuple{PlantGraphs.StaticGraph}","page":"Graphs","title":"PlantGraphs.draw","text":"draw(g::StaticGraph; resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15,\n     node_size = 5)\n\nEquivalent to the method draw(g::Graph; kwargs...) but  to visualize static graphs (e.g., the axiom of a graph).\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.get_descendant","page":"Graphs","title":"PlantGraphs.get_descendant","text":"get_descendant(c::Context; condition = x -> true, max_level::Int = typemax(Int))\n\nReturns the first descendant of a node that matches the condition. Intended to be used within a rule or query.\n\ngetdescendant is an alias for get_descendant for compatibility with AbstractTrees.jl\n\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\n\nKeywords\n\ncondition: An user-defined function that takes a Context object as input\n\nand returns true or false.\n\nmax_level::Int: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\n\nDetails\n\nIf has_descendant() returns false for the same node and condition, get_descendant() will return missing, otherwise it returns the Context associated to the matching node.\n\nReturn\n\nReturn a Context object or missing.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + (B1(1) + A1(3), B1(4))\n           g = Graph(axiom = axiom)\n               function qfun(n)\n               na = get_descendant(n, condition = x -> (data(x).val == 1))\n               if !ismissing(na)\n                   data(na) isa B1\n               else\n                   false\n               end\n           end\n           Q1 = Query(A1, condition = qfun)\n           R1 = apply(g, Q1)\n           Q2 = Query(B1, condition = qfun)\n           R2 = apply(g, Q2)\n           (R1,R2)\n       end\n(A1[A1(1)], B1[])\n\n\n\n\n\n","category":"function"},{"location":"api/graphs/#PlantGraphs.get_root","page":"Graphs","title":"PlantGraphs.get_root","text":"get_root(g::Graph)\n\nExtract the root node of a graph.\n\ngetroot is an alias for get_root for compatibility with AbstractTrees.jl\n\n\n\n\n\n","category":"function"},{"location":"api/graphs/#PlantGraphs.graph_data-Tuple{PlantGraphs.Context}","page":"Graphs","title":"PlantGraphs.graph_data","text":"graph_data(c::Context)\n\nReturns the graph-level variables. Intended to be used within a rule or query.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.has_ancestor-Tuple{PlantGraphs.Context}","page":"Graphs","title":"PlantGraphs.has_ancestor","text":"has_ancestor(c::Context; condition = x -> true, max_level::Int = typemax(Int))\n\nCheck if a node has an ancestor that matches the condition. Intended to be used within a rule or query.\n\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\n\nKeywords\n\ncondition: An user-defined function that takes a Context object as input\n\nand returns true or false.\n\nmax_level::Int: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\n\nDetails\n\nThis function traverses the graph from the node associated to c towards the root of the graph until a node is found for which condition returns true. If no node meets the condition, then it will return false. The defaults values for this function are such that the algorithm always returns true after one step (unless it is applied to the root node) in which case it is equivalent to calling has_parent on the node.\n\nThe number of levels that the algorithm is allowed to traverse is capped by max_level (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).\n\nThe function condition should take an object of type Context as input and return true or false.\n\nReturns\n\nReturn a tuple with two values a Bool and an Int, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(2) + (B1(1) + A1(3), B1(4))\n           g = Graph(axiom = axiom)\n               function qfun(n)\n               has_ancestor(n, condition = x -> data(x).val == 1)[1]\n           end\n           Q1 = Query(A1, condition = qfun)\n           R1 = apply(g, Q1)\n               Q2 = Query(B1, condition = qfun)\n           R2 = apply(g, Q2)\n           (R1,R2)\n       end\n(A1[A1(3)], B1[])\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.has_children-Tuple{PlantGraphs.Context}","page":"Graphs","title":"PlantGraphs.has_children","text":"has_children(c::Context)\n\nCheck if a node has at least one child and return true or false. Intended to be used within a rule or query.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.has_descendant-Tuple{PlantGraphs.Context}","page":"Graphs","title":"PlantGraphs.has_descendant","text":"has_descendant(c::Context; condition = x -> true, max_level::Int = typemax(Int))\n\nCheck if a node has a descendant that matches the optional condition. Intended to be used within a rule or query.\n\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\n\nKeywords\n\ncondition: An user-defined function that takes a Context object as input\n\nand returns true or false.\n\nmax_level::Int: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\n\nDetails\n\nThis function traverses the graph from the node associated to c towards the leaves of the graph until a node is found for which condition returns true. If no node meets the condition, then it will return false. The defaults values for this function are such that the algorithm always returns true after one step (unless it is applied to a leaf node) in which case it is equivalent to calling has_children on the node.\n\nThe number of levels that the algorithm is allowed to traverse is capped by max_level (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).\n\nThe function condition should take an object of type Context as input and return true or false.\n\nReturns\n\nReturn a tuple with two values a Bool and an Int, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(2) + (B1(1) + A1(3), B1(4))\n           g = Graph(axiom = axiom)\n               function qfun(n)\n               has_descendant(n, condition = x -> data(x).val == 1)[1]\n           end\n           Q1 = Query(A1, condition = qfun)\n           R1 = apply(g, Q1)\n           Q2 = Query(B1, condition = qfun)\n           R2 = apply(g, Q2)\n           (R1,R2)\n       end\n(A1[A1(2)], B1[])\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.has_parent-Tuple{PlantGraphs.Context}","page":"Graphs","title":"PlantGraphs.has_parent","text":"has_parent(c::Context)\n\nCheck if a node has a parent and return true or false. Intended to be used within a rule or query.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.is_leaf-Tuple{PlantGraphs.Context}","page":"Graphs","title":"PlantGraphs.is_leaf","text":"is_leaf(c::Context)\n\nCheck if a node is a leaf in the graph (i.e., has no children) and return true or false. Intended to be used within a rule or query.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.is_root","page":"Graphs","title":"PlantGraphs.is_root","text":"is_root(c::Context)\n\nCheck if a node is the root of the graph (i.e., has no parent) and return true or false. Intended to be used within a rule or query.\n\nisroot is an alias for is_root for compatibility with AbstractTrees.jl\n\n\n\n\n\n","category":"function"},{"location":"api/graphs/#PlantGraphs.node_label-Tuple{PlantGraphs.Node, Any}","page":"Graphs","title":"PlantGraphs.node_label","text":"node_label(n::Node, id)\n\nFunction to construct a label for a node to be used by draw() when visualizing. The user can specialize this method for user-defined data types to customize the labels. By default, the type of data stored in the node and the unique ID of the node are used as labels.\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.rewrite!-Tuple{PlantGraphs.Graph}","page":"Graphs","title":"PlantGraphs.rewrite!","text":"rewrite!(g::Graph)\n\nApply the graph-rewriting rules stored in the graph.\n\nArguments\n\ng::Graph: The graph to be rewritten. It will be modified in-place.\n\nDetails\n\nThis function will match the left-hand sides of all the rules in a graph. If any node is matched by more than one rule this will result in an error. The rules are then applied in order to replaced the matched nodes with the result of executing the right hand side of the rules. The rules are applied in the order in which they are stored in the graph but the order in which the nodes are processed is not defined. Since graph rewriting is semantically a parallel process, the rules should not be rely on any particular order for their functioning.\n\nReturns\n\nThis function returns nothing, but the graph passed as input will be modified by the execution of the rules.\n\nExamples\n\njulia> let\n           struct A <: Node end\n           struct B <: Node end\n           axiom = A() + B()\n           rule = Rule(A, rhs = x -> A() + B())\n           g = Graph(axiom = axiom, rules = rule)\n           rewrite!(g)\n       end\n\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.rules-Tuple{PlantGraphs.Graph}","page":"Graphs","title":"PlantGraphs.rules","text":"rules(g::Graph)\n\nReturns a tuple with all the graph-rewriting rules stored in a dynamic graph\n\nExamples\n\njulia> struct A <: Node end\n\n\njulia> struct B <: Node end\n\n\njulia> axiom = A() + B();\n\njulia> rule = Rule(A, rhs = x -> A() + B())\nRule replacing nodes of type A without context capturing.\n\njulia> rules_graph = Graph(axiom = axiom, rules = rule)\nDynamic graph with 2 nodes of types A,B and 1 rewriting rules.\n\njulia> rules(rules_graph)\n(Rule replacing nodes of type A without context capturing.\n,)\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.traverse-Tuple{PlantGraphs.Graph}","page":"Graphs","title":"PlantGraphs.traverse","text":"traverse(g::Graph; fun = () -> nothing)\n\nIterates over all the nodes in the graph and execute for the function fun on each node\n\nArguments\n\ng::Graph: The graph object that will be traversed.\n\nKeywords\n\nfun: A function or function-like object defined by the user that will be\n\napplied to each node.\n\nDetails\n\nThis traveral happens in the order in which the nodes are stored in the graph. This order is arbitrary and may vary across executions of the code (it does not correspond to the order in which nodes are created). For algorithms that require a particular traveral order of the graph, see traverse_dfs and traverse_bfs.\n\nThis function does not store any results generated by fun. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).\n\nThe function or function-like object provided by the user should take only one argument that corresponds to applying data() to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see Query and general VPL documentation).\n\nReturns\n\nThis function returns nothing but fun may have side-effects.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           struct Foo\n               vals::Vector{Int}\n           end\n           function (f::Foo)(x)\n                   push!(f.vals, x.val)\n           end\n           f = Foo(Int[])\n               axiom = A1(2) + (B1(1) + A1(3), B1(4))\n                   g = Graph(axiom = axiom)\n           traverse(g, fun = f)\n           f.vals\n       end\n4-element Vector{Int64}:\n 2\n 1\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.traverse_bfs-Tuple{PlantGraphs.Graph}","page":"Graphs","title":"PlantGraphs.traverse_bfs","text":"traverse_bfs(g::Graph; fun = () -> nothing, ID = root_id(g))\n\nIterates over all the nodes in the graph (breadth-first order, starting at a any node) and execute for the function fun on each node\n\nArguments\n\ng::Graph: The graph object that will be traversed.\n\nKeywords\n\nfun: A function or function-like object defined by the user that will be\n\napplied to each node.\n\nID: The ID of the node where the traveral should start. This argument is, by default,\n\nthe root of the graph.\n\nDetails\n\nThis traveral happens in a breadth-first order. That is, all nodes at a given depth of the the graph are visited first, then moving on to the next level. Hence, this algorithm should always generate the same result when applied to the same graph (assuming the user-defined function is not stochastic). For a version of this function that us depth-first order see traverse_dfs.\n\nThis function does not store any results generated by fun. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).\n\nThe function or function-like object provided by the user should take only one argument that corresponds to applying data() to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see Query and general VPL documentation).\n\nReturns\n\nThis function returns nothing but fun may have side-effects.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           struct Foo\n               vals::Vector{Int}\n           end\n           function (f::Foo)(x)\n               push!(f.vals, x.val)\n           end\n           f = Foo(Int[])\n               axiom = A1(2) + (B1(1) + A1(3), B1(4))\n                   g = Graph(axiom = axiom)\n           traverse_bfs(g, fun = f)\n           f.vals\n       end\n4-element Vector{Int64}:\n 2\n 1\n 4\n 3\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#PlantGraphs.traverse_dfs-Tuple{PlantGraphs.Graph}","page":"Graphs","title":"PlantGraphs.traverse_dfs","text":"traverse_dfs(g::Graph; fun = () -> nothing, ID = root_id(g))\n\nIterates over all the nodes in the graph (depth-first order, starting at a any node) and execute for the function fun on each node\n\nArguments\n\ng::Graph: The graph object that will be traversed.\n\nKeywords\n\nfun: A function or function-like object defined by the user that will be\n\napplied to each node.\n\nID: The ID of the node where the traveral should start. This argument is\n\nassigned by keyword and is, by default, the root of the graph.\n\nDetails\n\nThis traveral happens in a depth-first order. That is, all nodes in a branch of the graph are visited until reach a leaf node, then moving to the next branch. Hence, this algorithm should always generate the same result when applied to the same graph (assuming the user-defined function is not stochastic). For a version of this function that us breadth-first order see traverse_bfs.\n\nThis function does not store any results generated by fun. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).\n\nThe function or function-like object provided by the user should take only one argument that corresponds to applying data() to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see Query and general VPL documentation).\n\nReturns\n\nThis function returns nothing but fun may have side-effects.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           struct Foo\n               vals::Vector{Int}\n           end\n           function (f::Foo)(x)\n                   push!(f.vals, x.val)\n           end\n           f = Foo(Int[])\n           axiom = A1(2) + (B1(1) + A1(3), B1(4))\n               g = Graph(axiom = axiom)\n           traverse_dfs(g, fun = f)\n           f.vals\n       end\n4-element Vector{Int64}:\n 2\n 4\n 1\n 3\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#Private","page":"Graphs","title":"Private","text":"","category":"section"},{"location":"api/graphs/","page":"Graphs","title":"Graphs","text":"Private functions, types or constants from PlantGraphs. These are not exported, so you need to prefix the function name with PlantGeomPrimitives. to access them. Also bear in mind that these are not part of the public API, so they may change without notice.","category":"page"},{"location":"api/graphs/","page":"Graphs","title":"Graphs","text":"Modules = [PlantGraphs]\nPublic = false\nPrivate = true","category":"page"},{"location":"api/graphs/#PlantGraphs.Context","page":"Graphs","title":"PlantGraphs.Context","text":"Context\n\nData structure than links a node to the rest of the graph.\n\nFields\n\ngraph: Dynamic graph that contains the node.\nnode: Node inside the graph.\n\nDetails\n\nA Context object wraps references to a node and its associated graph. The purpose of this structure is to be able to test relationships among nodes within a graph (from with a query or rule), as well as access the data stored in a node (with data()) or the graph (with graph_data()).\n\nUsers do not build Context objects directly but they are provided by VPL as inputs to the user-defined functions inside rules and queries.\n\n\n\n\n\n","category":"type"},{"location":"api/graphs/#Base.:+-Tuple{PlantGraphs.Node, PlantGraphs.Node}","page":"Graphs","title":"Base.:+","text":"+(n1::Node, n2::Node)\n\nCreates a graph with two nodes where n1 is the root and n2 is the insertion point.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + B1(1)\n           import CairoMakie # or GLMakie, WGLMakie, etc.\n           draw(axiom)\n       end\nFigure()\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#Base.:+-Tuple{PlantGraphs.Node, PlantGraphs.StaticGraph}","page":"Graphs","title":"Base.:+","text":"+(n::Node, g::StaticGraph)\n\nCreates a graph as the result of appending the static graph g to the node n.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + B1(1)\n           axiom = A1(2) + axiom\n           import CairoMakie # or GLMakie, WGLMakie, etc.\n           draw(axiom)\n       end\nFigure()\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#Base.:+-Tuple{PlantGraphs.Node, Tuple}","page":"Graphs","title":"Base.:+","text":"+(g::StaticGraph, T::Tuple)\n+(n::Node, T::Tuple)\n\nCreates a graph as the result of appending a tuple of graphs/nodes T to the insertion point of the graph g or node n. Each graph/node in L becomes a branch.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + (B1(1) + A1(3), B1(4))\n           import CairoMakie # or GLMakie, WGLMakie, etc.\n           draw(axiom)\n       end\nFigure()\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.Node}","page":"Graphs","title":"Base.:+","text":"+(g::StaticGraph, n::Node)\n\nCreates a graph as the result of appending the node n to the insertion point of graph g.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + B1(1)\n           axiom = axiom + A1(2)\n           import CairoMakie # or GLMakie, WGLMakie, etc.\n           draw(axiom)\n       end\nFigure()\n\n\n\n\n\n","category":"method"},{"location":"api/graphs/#Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.StaticGraph}","page":"Graphs","title":"Base.:+","text":"+(g1::StaticGraph, g2::StaticGraph)\n\nCreates a graph as the result of appending g2 to the insertion point of g1. The insertion point of the final graph corresponds to the insertion point of g2.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom1 = A1(1) + B1(1)\n           axiom2 = A1(2) + B1(2)\n           axiom = axiom1 + axiom2\n           import CairoMakie # or GLMakie, WGLMakie, etc.\n           draw(axiom)\n       end\nFigure()\n\n\n\n\n\n","category":"method"},{"location":"tutorials/tree/#Tree","page":"Tree","title":"Tree","text":"","category":"section"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"Alejandro Morales","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"In this example we build a 3D representation of a binary TreeTypes. Although this will not look like a real plant, this example will help introduce additional features of VPL.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"The model requires five types of nodes:","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"Meristem: These are the nodes responsible for growth of new organs in our binary TreeTypes. They contain no data or geometry (i.e. they are a point in the 3D structure).","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"Internode: The result of growth of a branch, between two nodes. Internodes are represented by cylinders with a fixed width but variable length.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"Node: What is left after a meristem produces a new organ (it separates internodes). They contain no data or geometry (so also a point) but are required to keep the branching structure of the tree as well as connecting leaves.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"Bud: These are dormant meristems associated to tree nodes. When they are activated, they become an active meristem that produces a branch. They contain no data or geometry but they change the orientation of the turtle.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"BudNode: The node left by a bud after it has been activated. They contain no data or geometry but they change the orientation of the turtle.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"Leaf: These are the nodes associated to leaves in the TreeTypes. They are represented by ellipses with a particular orientation and insertion angle. The insertion angle is assumed constant, but the orientation angle varies according to an elliptical phyllotaxis rule.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"In this first simple model, only internodes grow over time according to a relative growth rate, whereas leaves are assumed to be of fixed sized determined at their creation. For simplicity, all active meristems will produce an phytomer (combination of node, internode, leaves and buds) per time step. Bud break is assumed stochastic, with a probability that increases proportional to the number of phytomers from the apical meristem (up to 1). In the following tutorials, these assumptions are replaced by more realistic models of light interception, photosynthesis, etc.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"In order to simulate growth of the 3D binary tree, we need to define a parameter describing the relative rate at which each internode elongates in each iteration of the simulation, a coefficient to compute the probability of bud break as well as the insertion and orientation angles of the leaves. We could stored these values as global constants, but VPL offers to opportunity to store them per plant. This makes it easier to manage multiple plants in the same simulation that may belong to different species, cultivars, ecotypes or simply to simulate plant-to-plant variation. Graphs in VPL can store an object of any user-defined type that will me made accessible to graph rewriting rules and queries. For this example, we define a data type treeparams that holds the relevant parameters. We use Base.@kwdef to assign default values to all parameters and allow to assign them by name.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"using VirtualPlantLab\nusing ColorTypes\nimport GLMakie\n\nmodule TreeTypes\n    import VirtualPlantLab\n    # Meristem\n    struct Meristem <: VirtualPlantLab.Node end\n    # Bud\n    struct Bud <: VirtualPlantLab.Node end\n    # Node\n    struct Node <: VirtualPlantLab.Node end\n    # BudNode\n    struct BudNode <: VirtualPlantLab.Node end\n    # Internode (needs to be mutable to allow for changes over time)\n    Base.@kwdef mutable struct Internode <: VirtualPlantLab.Node\n        length::Float64 = 0.10 ## Internodes start at 10 cm\n    end\n    # Leaf\n    Base.@kwdef struct Leaf <: VirtualPlantLab.Node\n        length::Float64 = 0.20 ## Leaves are 20 cm long\n        width::Float64  = 0.1 ## Leaves are 10 cm wide\n    end\n    # Graph-level variables\n    Base.@kwdef struct treeparams\n        growth::Float64 = 0.1\n        budbreak::Float64 = 0.25\n        phyllotaxis::Float64 = 140.0\n        leaf_angle::Float64 = 30.0\n        branch_angle::Float64 = 45.0\n    end\nend","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"As always, the 3D structure and the color of each type of node are implemented with the feed! method. In this case, the internodes and leaves have a 3D representation, whereas bud nodes rotate the turtle. The rest of the elements of the trees are just points in the 3D structure, and hence do not have an explicit geometry:","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"# Create geometry + color for the internodes\nfunction VirtualPlantLab.feed!(turtle::Turtle, i::TreeTypes.Internode, vars)\n    # Rotate turtle around the head to implement elliptical phyllotaxis\n    rh!(turtle, vars.phyllotaxis)\n    HollowCylinder!(turtle, length = i.length, height = i.length/15, width = i.length/15,\n                move = true, color = RGB(0.5,0.4,0.0))\n    return nothing\nend\n\n# Create geometry + color for the leaves\nfunction VirtualPlantLab.feed!(turtle::Turtle, l::TreeTypes.Leaf, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.leaf_angle)\n    # Generate the leaf\n    Ellipse!(turtle, length = l.length, width = l.width, move = false,\n             color = RGB(0.2,0.6,0.2))\n    # Rotate turtle back to original direction\n    ra!(turtle, vars.leaf_angle)\n    return nothing\nend\n\n# Insertion angle for the bud nodes\nfunction VirtualPlantLab.feed!(turtle::Turtle, b::TreeTypes.BudNode, vars)\n    # Rotate turtle around the arm for insertion angle\n    ra!(turtle, -vars.branch_angle)\nend","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"The growth rule for a branch within a tree is simple: a phytomer (or basic unit of morphology) is composed of a node, a leaf, a bud node, an internode and an active meristem at the end. Each time step, the meristem is replaced by a new phytomer, allowing for developmemnt within a branch.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"meristem_rule = Rule(TreeTypes.Meristem, rhs = mer -> TreeTypes.Node() +\n                                              (TreeTypes.Bud(), TreeTypes.Leaf()) +\n                                         TreeTypes.Internode() + TreeTypes.Meristem())","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"In addition, every step of the simulation, each bud may break, creating a new branch. The probability of bud break is proportional to the number of phytomers from the apical meristem (up to 1), which requires a relational rule to count the number of internodes in the graph up to reaching a meristem. When a bud breaks, it is replaced by a bud node, an internode and a new meristem. This new meristem becomes the apical meristem of the new branch, such that meristem_rule would apply. Note how we create an external function to compute whether a bud breaks or not. This is useful to keep the branch_rule rule simple and readable, while allow for a relatively complex bud break model. It also makes it easier to debug the bud break model, since it can be tested independently of the graph rewriting.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"function prob_break(bud)\n    # We move to parent node in the branch where the bud was created\n    node =  parent(bud)\n    # We count the number of internodes between node and the first Meristem\n    # moving down the graph\n    check, steps = has_descendant(node, condition = n -> data(n) isa TreeTypes.Meristem)\n    steps = Int(ceil(steps/2)) ## Because it will count both the nodes and the internodes\n    # Compute probability of bud break and determine whether it happens\n    if check\n        prob =  min(1.0, steps*graph_data(bud).budbreak)\n        return rand() < prob\n    # If there is no meristem, an error happened since the model does not allow\n    # for this\n    else\n        error(\"No meristem found in branch\")\n    end\nend\nbranch_rule = Rule(TreeTypes.Bud,\n            lhs = prob_break,\n            rhs = bud -> TreeTypes.BudNode() + TreeTypes.Internode() + TreeTypes.Meristem())","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"A binary tree initializes as an internode followed by a meristem, so the axiom can be constructed simply as:","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"axiom = TreeTypes.Internode() + TreeTypes.Meristem()","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"And the object for the tree can be constructed as in previous examples, by passing the axiom and the graph rewriting rules, but in this case also with the object with growth-related parameters.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"tree = Graph(axiom = axiom, rules = (meristem_rule, branch_rule), data = TreeTypes.treeparams())","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"Note that so far we have not included any code to simulate growth of the internodes. The reason is that, as elongation of internotes does not change the topology of the graph (it simply changes the data stored in certain nodes), this process does not need to be implemented with graph rewriting rules. Instead, we will use a combination of a query (to identify which nodes need to be altered) and direct modification of these nodes:","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"getInternode = Query(TreeTypes.Internode)","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"If we apply the query to a graph using the apply function, we will get an array of all the nodes that match the query, allow for direct manipulation of their contents. To help organize the code, we will create a function that simulates growth by multiplying the length argument of all internodes in a tree by the growth parameter defined in the above:","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"function elongate!(tree, query)\n    for x in apply(tree, query)\n        x.length = x.length*(1.0 + data(tree).growth)\n    end\nend","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"Note that we use vars on the Graph object to extract the object that was stored inside of it. Also, as this function will modify the graph which is passed as input, we append an ! to the name (this not a special syntax of the language, its just a convention in the Julia community). Also, in this case, the query object is kept separate from the graph. We could have also stored it inside the graph like we did for the parameter growth. We could also have packaged the graph and the query into another type representing an individual TreeTypes. This is entirely up to the user and indicates that a model can be implemented in many differences ways with VPL.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"Simulating the growth a tree is a matter of elongating the internodes and applying the rules to create new internodes:","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"function growth!(tree, query)\n    elongate!(tree, query)\n    rewrite!(tree)\nend","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"and a simulation for n steps is achieved with a simple loop:","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"function simulate(tree, query, nsteps)\n    new_tree = deepcopy(tree)\n    for i in 1:nsteps\n        growth!(new_tree, query)\n    end\n    return new_tree\nend","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"Notice that the simulate function creates a copy of the object to avoid overwriting it. If we run the simulation for a couple of steps","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"newtree = simulate(tree, getInternode, 2)","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"The binary tree after two iterations has two branches, as expected:","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"render(Scene(newtree))","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"Notice how the lengths of the prisms representing internodes decreases as the branching order increases, as the internodes are younger (i.e. were generated fewer generations ago). Further steps will generate a structure that is more tree-like.","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"newtree = simulate(newtree, getInternode, 15)\nrender(Scene(newtree))","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"","category":"page"},{"location":"tutorials/tree/","page":"Tree","title":"Tree","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#The-Virtual-Plant-Laboratory","page":"Virtual Plant Laboratory","title":"The Virtual Plant Laboratory","text":"","category":"section"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"Alejandro Morales","category":"page"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"Centre for Crop Systems Analysis - Wageningen University","category":"page"},{"location":"#Introduction","page":"Virtual Plant Laboratory","title":"Introduction","text":"","category":"section"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"The Virtual Plant Laboratory (VPL) is a collection of Julia packages that aid in the construction, simulation and visualization of functional-structural plant models (FSPM). Users are meant to make use of the interface package (VirtualPlantLab.jl) which provides the API to the different packages in VPL. Additional packages complement the functionality of VPL forming the VPLverse (see below for details).","category":"page"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"VPL is not a standalone solution to all the computational problems relevant to FSPM, but rather it focuses on those algorithms and data structures that are specific to FSPM and for which there are no good solutions in the Julia package ecosystem. Furthermore, VPL is 100% written in Julia and therefore VPL will work in any platform and with any code editor where Julia works. Finally, VPL does not offer a domain specific language for FSPM but rather it allows building FSP models by creating user-defined data types and methods.","category":"page"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"There is no standard definition of what an FSPM is (though these models will always involve some combination of plant structure and function) so VPL may not be useful with every possible FSPM. Instead, VPL focuses on models that represent individual plants as graphs of elements (usually organs) that interact with each other and with the environment. In a typical VPL model, each plant is represented by its own graph which can change dynamically through the iterative application of graph rewriting rules. Based on this goal, what VPL offers are data structures and algorithms that allow modelling the dynamic evolution of graphs that represent plants as collections of organs or other morphological elements and modelling the interaction between plants and their environment by generating 3D structures and simulating capture of different resources (e.g. light).","category":"page"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"In terms of design, VPL gives priority to performance and simple interfaces as opposed to complex layers of abstraction. This implies that models in VPL may be more verbose and procedural (as opposed to descriptive) than in other FSPM software, but that may also make them more transparent and easier to follow.","category":"page"},{"location":"#Installation","page":"Virtual Plant Laboratory","title":"Installation","text":"","category":"section"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"VPL requires using Julia version 1.9 or higher. The installation of core of VPL is as easy as running the following code:","category":"page"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"] add VirtualPlantLab","category":"page"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"This will install all the packages that form the core of VPL. Additional packages that are meant to work with VPL (or as standalone packages) are available as part of the VPLverse (see section on Organization). These are not necessary to build an FSP models but in many cases they will be useful to complement the functionality of VPL.","category":"page"},{"location":"#Documentation","page":"Virtual Plant Laboratory","title":"Documentation","text":"","category":"section"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"Documentation for VPL is provided in this website in four formats:","category":"page"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"User manual\nTutorials\nAPI\nVPLverse\nTechnical notes for developers","category":"page"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"New users are expected to start with the tutorials and consult the user manual to understand better the different concepts used in VPL and get an overview of the different options available. The API documentation describes each individual function and data type, with an emphasis on inputs and outputs and (in addition to this website) it can be accessed from within Julia with ? (see the section Accessing Documentation in the Julia manual).","category":"page"},{"location":"","page":"Virtual Plant Laboratory","title":"Virtual Plant Laboratory","text":"The technical notes are useful for people who want to understand the internal details of VPL and how different algorithms are implemented (i.e. the technical notes should be seen as a supplement to the source code of VPL).","category":"page"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine","page":"PlantSimEngine package","title":"PlantSimEngine","text":"","category":"section"},{"location":"VPLVerse/PlantSimEngine/","page":"PlantSimEngine package","title":"PlantSimEngine package","text":"The documentation for PlantSimEngine.jl is hosted in its own website. Public and private API is documented below:","category":"page"},{"location":"VPLVerse/PlantSimEngine/","page":"PlantSimEngine package","title":"PlantSimEngine package","text":"CurrentModule = PlantSimEngine","category":"page"},{"location":"VPLVerse/PlantSimEngine/#API-documentation","page":"PlantSimEngine package","title":"API documentation","text":"","category":"section"},{"location":"VPLVerse/PlantSimEngine/","page":"PlantSimEngine package","title":"PlantSimEngine package","text":"Modules = [PlantSimEngine]\nPrivate = false","category":"page"},{"location":"VPLVerse/PlantSimEngine/#PlantMeteo.TimeStepTable-Union{Tuple{DataFrames.DataFrame}, Tuple{Status}, Tuple{DataFrames.DataFrame, Any}} where Status","page":"PlantSimEngine package","title":"PlantMeteo.TimeStepTable","text":"TimeStepTable{Status}(df::DataFrame)\n\nMethod to build a TimeStepTable (from PlantMeteo.jl)  from a DataFrame, but with each row being a Status.\n\nNote\n\nModelList uses TimeStepTable{Status} by default (see examples below).\n\nExamples\n\nusing PlantSimEngine, DataFrames\n\n# A TimeStepTable from a DataFrame:\ndf = DataFrame(\n    Tₗ=[25.0, 26.0],\n    aPPFD=[1000.0, 1200.0],\n    Cₛ=[400.0, 400.0],\n    Dₗ=[1.0, 1.2],\n)\nTimeStepTable{Status}(df)\n\n# A leaf with several values for at least one of its variable will automatically use \n# TimeStepTable{Status} with the time steps:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# The status of the leaf is a TimeStepTable:\nstatus(models)\n\n# Of course we can also create a TimeStepTable with Status manually:\nTimeStepTable(\n    [\n        Status(Tₗ=25.0, aPPFD=1000.0, Cₛ=400.0, Dₗ=1.0),\n        Status(Tₗ=26.0, aPPFD=1200.0, Cₛ=400.0, Dₗ=1.2),\n    ]\n)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.AbstractModel","page":"PlantSimEngine package","title":"PlantSimEngine.AbstractModel","text":"Abstract model type. All models are subtypes of this one.\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.ModelList","page":"PlantSimEngine package","title":"PlantSimEngine.ModelList","text":"ModelList(models::M, status::S)\nModelList(;\n    status=nothing,\n    init_fun::Function=init_fun_default,\n    type_promotion=nothing,\n    variables_check=true,\n    kwargs...\n)\n\nList the models for a simulation (models), and does all boilerplate for variable initialization,  type promotion, time steps handling.\n\nnote: Note\nThe status field depends on the input models. You can get the variables needed by a model using variables on the instantiation of a model. You can also use inputs and outputs instead.\n\nArguments\n\nmodels: a list of models. Usually given as a NamedTuple, but can be any other structure that \n\nimplements getproperty.\n\nstatus: a structure containing the initializations for the variables of the models. Usually a NamedTuple\n\nwhen given as a kwarg, or any structure that implements the Tables interface from Tables.jl (e.g. DataFrame, see details).\n\nnsteps=nothing: the number of time steps to pre-allocated. If nothing, the number of time steps is deduced from the status (or 1 if no status is given).\ninit_fun: a function that initializes the status based on a vector of NamedTuples (see details).\ntype_promotion: optional type conversion for the variables with default values.\n\nnothing by default, i.e. no conversion. Note that conversion is not applied to the variables input by the user as kwargs (need to do it manually). Should be provided as a Dict with current type as keys and new type as values.\n\nvariables_check=true: check that all needed variables are initialized by the user.\nkwargs: the models, named after the process they simulate.\n\nDetails\n\nThe argument init_fun is set by default to init_fun_default which initializes the status with a TimeStepTable of Status structures.\n\nIf you change init_fun by another function, make sure the type you are using (i.e. in place of TimeStepTable)  implements the Tables.jl interface (e.g. DataFrame does). And if you still use TimeStepTable but only change Status, make sure the type you give is indexable using the dot synthax (e.g. x.var).\n\nIf you need to input a custom Type for the status and make your users able to only partially initialize  the status field in the input, you'll have to implement a method for add_model_vars!, a function that  adds the models variables to the type in case it is not fully initialized. The default method is compatible  with any type that implements the Tables.jl interface (e.g. DataFrame), and NamedTuples.\n\nNote that ModelListmakes a copy of the input status if it does not list all needed variables.\n\nExamples\n\nWe'll use the dummy models from the dummy.jl in the examples folder of the package. It  implements three dummy processes: Process1Model, Process2Model and Process3Model, with one model implementation each: Process1Model, Process2Model and Process3Model.\n\njulia> using PlantSimEngine;\n\nIncluding an example script that implements dummy processes and models:\n\njulia> include(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model());\n[ Info: Some variables must be initialized before simulation: (process1 = (:var1, :var2), process2 = (:var1,)) (see `to_initialize()`)\n\njulia> typeof(models)\nModelList{NamedTuple{(:process1, :process2, :process3), Tuple{Process1Model, Process2Model, Process3Model}}, TimeStepTable{Status{(:var4, :var5, :var6, :var1, :var3, :var2), NTuple{6, Base.RefValue{Float64}}}}}\n\nNo variables were given as keyword arguments, that means that the status of the ModelList is not set yet, and all variables are initialized to their default values given in the inputs and outputs (usually typemin(Type), i.e. -Inf for floating point numbers). This component cannot be simulated yet.\n\nTo know which variables we need to initialize for a simulation, we use to_initialize:\n\njulia> to_initialize(models)\n(process1 = (:var1, :var2), process2 = (:var1,))\n\nWe can now provide values for these variables in the status field, and simulate the ModelList,  e.g. for process3 (coupled with process1 and process2):\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3));\n\njulia> meteo = Atmosphere(T = 22.0, Wind = 0.8333, P = 101.325, Rh = 0.4490995);\n\njulia> run!(models,meteo)\n\njulia> models[:var6]\n1-element Vector{Float64}:\n 58.0138985\n\nIf we want to use special types for the variables, we can use the type_promotion argument:\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0, var2=0.3), type_promotion = Dict(Float64 => Float32));\n\nWe used type_promotion to force the status into Float32:\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float64\n Float64\n Float32\n\nBut we see that only the default variables (the ones that are not given in the status arguments) were converted to Float32, the two other variables that we gave were not converted. This is because we want to give the ability to users to give any type for the variables they provide  in the status. If we want all variables to be converted to Float32, we can pass them as Float32:\n\njulia> models = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=(var1=15.0f0, var2=0.3f0), type_promotion = Dict(Float64 => Float32));\n\nWe used type_promotion to force the status into Float32:\n\njulia> [typeof(models[i][1]) for i in keys(status(models))]\n6-element Vector{DataType}:\n Float32\n Float32\n Float32\n Float32\n Float32\n Float32\n\nWe can also use DataFrame as the status type:\n\njulia> using DataFrames;\n\njulia> df = DataFrame(:var1 => [13.747, 13.8], :var2 => [1.0, 1.0]);\n\njulia> m = ModelList(process1=Process1Model(1.0), process2=Process2Model(), process3=Process3Model(), status=df, init_fun=x -> DataFrame(x));\n\nNote that we use init_fun to force the status into a DataFrame, otherwise it would be automatically converted into a TimeStepTable{Status}.\n\njulia> status(m)\n2×6 DataFrame\n Row │ var4     var5     var6     var1     var3     var2    \n     │ Float64  Float64  Float64  Float64  Float64  Float64 \n─────┼──────────────────────────────────────────────────────\n   1 │    -Inf     -Inf     -Inf   13.747     -Inf      1.0\n   2 │    -Inf     -Inf     -Inf   13.8       -Inf      1.0\n\nNote that computations will be slower using DataFrame, so if performance is an issue, use TimeStepTable instead (or a NamedTuple as shown in the example).\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.Status","page":"PlantSimEngine package","title":"PlantSimEngine.Status","text":"Status(vars)\n\nStatus type used to store the values of the variables during simulation. It is mainly used as the structure to store the variables in the TimeStepRow of a TimeStepTable (see  PlantMeteo.jl docs) of a ModelList.\n\nMost of the code is taken from MasonProtter/MutableNamedTuples.jl, so Status is a MutableNamedTuples with a few modifications, so in essence, it is a stuct that stores a NamedTuple of the references to the values of the variables, which makes it mutable.\n\nExamples\n\nA leaf with one value for all variables will make a status with one time step:\n\njulia> st = PlantSimEngine.Status(Rₛ=13.747, sky_fraction=1.0, d=0.03, aPPFD=1500.0);\n\nAll these indexing methods are valid:\n\njulia> st[:Rₛ]\n13.747\n\njulia> st.Rₛ\n13.747\n\njulia> st[1]\n13.747\n\nSetting a Status variable is very easy:\n\njulia> st[:Rₛ] = 20.0\n20.0\n\njulia> st.Rₛ = 21.0\n21.0\n\njulia> st[1] = 22.0\n22.0\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.EF-Tuple{Any, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.EF","text":"EF(obs,sim)\n\nReturns the Efficiency Factor between observations obs and simulations sim using NSE (Nash-Sutcliffe efficiency) model. More information can be found at https://en.wikipedia.org/wiki/Nash%E2%80%93Sutcliffemodelefficiency_coefficient.\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nEF(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.NRMSE-Tuple{Any, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.NRMSE","text":"NRMSE(obs,sim)\n\nReturns the Normalized Root Mean Squared Error between observations obs and simulations sim. Normalization is performed using division by observations range (max-min).\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nNRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.RMSE-Tuple{Any, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.RMSE","text":"RMSE(obs,sim)\n\nReturns the Root Mean Squared Error between observations obs and simulations sim.\n\nThe closer to 0 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\nRMSE(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.dep","page":"PlantSimEngine package","title":"PlantSimEngine.dep","text":"dep(m::ModelList, nsteps=1; verbose::Bool=true)\n\nGet the model dependency graph given a ModelList. If one graph is returned, then all models are coupled. If several graphs are returned, then only the models inside each graph are coupled, and the models in different graphs are not coupled. nsteps is the number of steps the dependency graph will be used over. It is used to determine the length of the simulation_id argument for each soft dependencies in the graph.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\ndep(models)\n\n# or directly with the processes:\nvars = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ndep(;vars...)\n\n\n\n\n\n","category":"function"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.dr-Tuple{Any, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.dr","text":"dr(obs,sim)\n\nReturns the Willmott’s refined index of agreement dᵣ. Willmot et al. 2011. A refined index of model performance. https://rmets.onlinelibrary.wiley.com/doi/10.1002/joc.2419\n\nThe closer to 1 the better.\n\nExamples\n\nusing PlantSimEngine\n\nobs = [1.0, 2.0, 3.0]\nsim = [1.1, 2.1, 3.1]\n\ndr(obs, sim)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.fit","page":"PlantSimEngine package","title":"PlantSimEngine.fit","text":"fit()\n\nOptimize the parameters of a model using measurements and (potentially) initialisation values. \n\nModellers should implement a method to fit for their model, with the following design pattern:\n\nThe call to the function should take the model type as the first argument (T::Type{<:AbstractModel}),  the data as the second argument (as a Table.jl compatible type, such as DataFrame), and the  parameters initializations as keyword arguments (with default values when necessary).\n\nFor example the method for fitting the Beer model from the example script (see src/examples/Beer.jl) looks like  this:\n\nfunction PlantSimEngine.fit(::Type{Beer}, df; J_to_umol=PlantMeteo.Constants().J_to_umol)\n    k = Statistics.mean(log.(df.Ri_PAR_f ./ (df.PPFD ./ J_to_umol)) ./ df.LAI)\n    return (k=k,)\nend\n\nThe function should return the optimized parameters as a NamedTuple of the form (parameter_name=parameter_value,).\n\nHere is an example usage with the Beer model, where we fit the k parameter from \"measurements\" of PPFD, LAI  and Ri_PAR_f. \n\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/Beer.jl\"))\nm = ModelList(Beer(0.6), status=(LAI=2.0,))\nmeteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0)\nrun!(m, meteo)\ndf = DataFrame(aPPFD=m[:aPPFD][1], LAI=m.status.LAI[1], Ri_PAR_f=meteo.Ri_PAR_f[1])\nfit(Beer, df)\n\nNote that this is a dummy example to show that the fitting method works, as we simulate the PPFD  using the Beer-Lambert law with a value of k=0.6, and then use the simulated PPFD to fit the k parameter again, which gives the same value as the one used on the simulation.\n\n\n\n\n\n","category":"function"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.init_mtg_models!-Tuple{Any, Dict{String, <:PlantSimEngine.ModelList}, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.init_mtg_models!","text":"init_mtg_models!(\n    mtg::MultiScaleTreeGraph.Node,\n    models::Dict{String,<:ModelList},\n    i=nothing;\n    verbose=true,\n    attr_name=:models\n)\n\ninitialize the components of an MTG (i.e. nodes) with the corresponding models.\n\nThe function checks if the models associated to each component of the MTG are fully initialized, and if not, tries to initialize the variables using the MTG attributes with the exact same name, and if not found, returns an error.\n\nArguments\n\nmtg::MultiScaleTreeGraph.Node: the MTG tree.\nmodels::Dict{String,ModelList}: a dictionary of models named by components names\ni=nothing: the time-step to initialize. If nothing, initialize all the time-steps.\nverbose = true: return information during the processes\nattr_name = :models: the node attribute name used to store the models, default to \n\nSymbol(MultiScaleTreeGraph.cache_name(\"PlantSimEngine models\"))\n\nExamples\n\nusing PlantSimEngine, MultiScaleTreeGraph\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\n# Make an MTG:\nmtg = Node(MultiScaleTreeGraph.NodeMTG(\"/\", \"Plant\", 1, 1))\ninternode = Node(mtg, MultiScaleTreeGraph.NodeMTG(\"/\", \"Internode\", 1, 2))\nleaf = Node(mtg, MultiScaleTreeGraph.NodeMTG(\"<\", \"Leaf\", 1, 2))\nleaf[:var1] = [15.0, 16.0]\nleaf[:var2] = 0.3\n\n# Declare our models:\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    )\n)\n\n# Checking which variables are needed for our models:\n[component => to_initialize(model) for (component, model) in models]\n# OK we need to initialize :var1 and :var2\n\n# We could compute them directly inside the MTG from available variables instead of \n# giving them as initialisations:\ntransform!(\n    mtg,\n    :var1 => (x -> x .+ 2.0) => :var2,\n    ignore_nothing = true\n)\n\n# Initialising all components with their corresponding models and initialisations at time-step 1:\ninit_mtg_models!(mtg, models, 1)\n\nNote that this is possible only because the initialisation values are found in the MTG. If the initialisations are constant values between components, we can directly initialize them in the models definition (as we do in the begining).\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.init_status!-Tuple{Dict{String, PlantSimEngine.ModelList}}","page":"PlantSimEngine package","title":"PlantSimEngine.init_status!","text":"init_status!(object::Dict{String,ModelList};vars...)\ninit_status!(component::ModelList;vars...)\n\nInitialise model variables for components with user input.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n    )\n)\n\ninit_status!(models, var1=1.0 , var2=2.0)\nstatus(models[\"Leaf\"])\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.init_variables-Tuple{T} where T<:PlantSimEngine.AbstractModel","page":"PlantSimEngine package","title":"PlantSimEngine.init_variables","text":"init_variables(models...)\n\nInitialized model variables with their default values. The variables are taken from the inputs and outputs of the models.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\ninit_variables(Process1Model(2.0))\ninit_variables(process1=Process1Model(2.0), process2=Process2Model())\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.inputs-Tuple{T} where T<:PlantSimEngine.AbstractModel","page":"PlantSimEngine package","title":"PlantSimEngine.inputs","text":"inputs(model::AbstractModel)\ninputs(...)\n\nGet the inputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no inputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\ninputs(Process1Model(1.0))\n\n# output\n(:var1, :var2)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.is_initialized-Tuple{T} where T<:PlantSimEngine.ModelList","page":"PlantSimEngine package","title":"PlantSimEngine.is_initialized","text":"is_initialized(m::T) where T <: ModelList\nis_initialized(m::T, models...) where T <: ModelList\n\nCheck if the variables that must be initialized are, and return true if so, and false and an information message if not.\n\nNote\n\nThere is no way to know before-hand which process will be simulated by the user, so if you have a component with a model for each process, the variables to initialize are always the smallest subset of all, meaning it is considered the user will simulate the variables needed for other models.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nis_initialized(models)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.outputs-Tuple{T} where T<:PlantSimEngine.AbstractModel","page":"PlantSimEngine package","title":"PlantSimEngine.outputs","text":"outputs(model::AbstractModel)\noutputs(...)\n\nGet the outputs of one or several models.\n\nReturns an empty tuple by default for AbstractModels (no outputs) or Missing models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\noutputs(Process1Model(1.0))\n\n# output\n(:var3,)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.run!","page":"PlantSimEngine package","title":"PlantSimEngine.run!","text":"run!(object, meteo, constants, extra=nothing; check=true, executor=Floops.ThreadedEx())\n\nRun the simulation for each model in the model list in the correct order, i.e. respecting the dependency graph.\n\nIf several time-steps are given, the models are run sequentially for each time-step.\n\nArguments\n\nobject: a ModelList, an array or dict of ModelList, or an MTG.\nmeteo: a PlantMeteo.TimeStepTable of \n\nPlantMeteo.Atmosphere or a single PlantMeteo.Atmosphere.\n\nconstants: a PlantMeteo.Constants object, or a NamedTuple of constant keys and values.\nextra: extra parameters.\ncheck: if true, check the validity of the model list before running the simulation (takes a little bit of time), and return more information while running.\nexecutor: the Floops executor used to run the simulation either in sequential (executor=SequentialEx()), in a \n\nmulti-threaded way (executor=ThreadedEx(), the default), or in a distributed way (executor=DistributedEx()).\n\nReturns\n\nModifies the status of the object in-place. Users may retrieve the results from the object using  the status  function (see examples).\n\nDetails\n\nModel execution\n\nThe models are run according to the dependency graph. If a model has a soft dependency on another model (i.e. its inputs are computed by another model), the other model is run first. If a model has several soft dependencies, the parents (the soft dependencies) are always computed first.\n\nParallel execution\n\nUsers can ask for parallel execution by providing a compatible executor to the executor argument. The package will also automatically check if the execution can be parallelized. If it is not the case and the user asked for a parallel computation, it return a warning and run the simulation sequentially. We use the Floops package to run the simulation in parallel. That means that you can provide any compatible executor to the executor argument. You can take a look at FoldsThreads.jl for extra thread-based executors, FoldsDagger.jl for  Transducers.jl-compatible parallel fold implemented using the Dagger.jl framework, and soon FoldsCUDA.jl for GPU computations  (see this issue) and FoldsKernelAbstractions.jl. You can also take a look at  ParallelMagics.jl to check if automatic parallelization is possible.\n\nExample\n\nImport the packages: \n\njulia> using PlantSimEngine, PlantMeteo;\n\nLoad the dummy models given as example in the package:\n\njulia> include(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\nCreate a model list:\n\njulia> models = ModelList(Process1Model(1.0), Process2Model(), Process3Model(), status = (var1=1.0, var2=2.0));\n\nCreate meteo data:\n\njulia> meteo = Atmosphere(T=20.0, Wind=1.0, P=101.3, Rh=0.65, Ri_PAR_f=300.0);\n\nRun the simulation:\n\njulia> run!(models, meteo);\n\nGet the results:\n\njulia> (models[:var4],models[:var6])\n([12.0], [41.95])\n\n\n\n\n\n","category":"function"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.status-Tuple{Any}","page":"PlantSimEngine package","title":"PlantSimEngine.status","text":"status(m)\nstatus(m::AbstractArray{<:ModelList})\nstatus(m::AbstractDict{T,<:ModelList})\n\nGet a ModelList status, i.e. the state of the input (and output) variables.\n\nSee also is_initialized and to_initialize\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\n# Create a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nstatus(models)\n\n# Or just one variable:\nstatus(models,:var1)\n\n\n# Or the status at the ith time-step:\nstatus(models, 2)\n\n# Or even more simply:\nmodels[:var1]\n# output\n2-element Vector{Float64}:\n 15.0\n 16.0\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.to_initialize-Tuple{PlantSimEngine.AbstractDependencyNode}","page":"PlantSimEngine package","title":"PlantSimEngine.to_initialize","text":"to_initialize(m::AbstractDependencyNode)\n\nReturn the variables that must be initialized providing a set of models and processes. The function just returns the inputs and outputs of each model, with their default values. To take into account model coupling, use the function at an upper-level instead, i.e.  to_initialize(m::ModelList) or to_initialize(m::DependencyGraph).\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.to_initialize-Tuple{PlantSimEngine.ModelList}","page":"PlantSimEngine package","title":"PlantSimEngine.to_initialize","text":"to_initialize(v::T, vars...) where T <: Union{Missing,AbstractModel}\nto_initialize(m::T)  where T <: ModelList\nto_initialize(m::DependencyGraph)\n\nReturn the variables that must be initialized providing a set of models and processes. The function takes into account model coupling and only returns the variables that are needed considering that some variables that are outputs of some models are used as inputs of others.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nto_initialize(process1=Process1Model(1.0), process2=Process2Model())\n\n# Or using a component directly:\nmodels = ModelList(process1=Process1Model(1.0), process2=Process2Model())\nto_initialize(models)\n\nm = ModelList(\n    (\n        process1=Process1Model(1.0),\n        process2=Process2Model()\n    ),\n    Status(var1 = 5.0, var2 = -Inf, var3 = -Inf, var4 = -Inf, var5 = -Inf)\n)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.variables-Tuple{Module}","page":"PlantSimEngine package","title":"PlantSimEngine.variables","text":"variables(pkg::Module)\n\nReturns a dataframe of all variables, their description and units in a package that has PlantSimEngine as a dependency (if implemented by the authors).\n\nNote to developers\n\nDevelopers of a package that depends on PlantSimEngine should  put a csv file in \"data/variables.csv\", then this file will be  returned by the function.\n\nExamples\n\nHere is an example with the PlantBiophysics package:\n\n#] add PlantBiophysics\nusing PlantBiophysics\nvariables(PlantBiophysics)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.variables-Tuple{PlantSimEngine.SoftDependencyNode}","page":"PlantSimEngine package","title":"PlantSimEngine.variables","text":"variables(m::AbstractDependencyNode)\n\nReturns a tuple with the name of the inputs and outputs variables needed by a model in  a dependency graph.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.variables-Union{Tuple{T}, Tuple{T, Vararg{Any}}} where T<:Union{Missing, PlantSimEngine.AbstractModel}","page":"PlantSimEngine package","title":"PlantSimEngine.variables","text":"variables(model)\nvariables(model, models...)\n\nReturns a tuple with the name of the variables needed by a model, or a union of those variables for several models.\n\nNote\n\nEach model can (and should) have a method for this function.\n\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\nvariables(Process1Model(1.0))\n\nvariables(Process1Model(1.0), Process2Model())\n\n# output\n\n5-element Vector{Symbol}:\n :var1\n :var2\n :var3\n :var4\n :var5\n\nSee also\n\ninputs, outputs and variables_typed\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.@process-Tuple{Any, Vararg{Any}}","page":"PlantSimEngine package","title":"PlantSimEngine.@process","text":"@process(process::String, doc::String=\"\"; verbose::Bool=true)\n\nThis macro generate the abstract type and some boilerplate code for the simulation of a process, along  with its documentation. It also prints out a short tutorial for implementing a model if verbose=true.\n\nThe abstract process type is then used as a supertype of all models implementations for the  process, and is named \"Abstract<ProcessName>Model\", e.g. AbstractGrowthModel for a process called growth.\n\nThe first argument to @process is the new process name,  the second is any additional documentation that should be added  to the Abstract<ProcessName>Model type, and the third determines whether  the short tutorial should be printed or not.\n\nNewcomers are encouraged to use this macro because it explains in detail what to do next with the process. But more experienced users may want to directly define their process without  printing the tutorial. To do so, you can just define a new abstract type and define it as a  subtype of AbstractModel:\n\nabstract type MyNewProcess <: AbstractModel end\n\nExamples\n\n@process \"dummy_process\" \"This is a dummy process that shall not be used\"\n\n\n\n\n\n","category":"macro"},{"location":"VPLVerse/PlantSimEngine/#Un-exported","page":"PlantSimEngine package","title":"Un-exported","text":"","category":"section"},{"location":"VPLVerse/PlantSimEngine/","page":"PlantSimEngine package","title":"PlantSimEngine package","text":"Private functions, types or constants from PlantSimEngine. These are not exported, so you need to use PlantSimEngine. to access them (e.g. PlantSimEngine.DataFormat).","category":"page"},{"location":"VPLVerse/PlantSimEngine/","page":"PlantSimEngine package","title":"PlantSimEngine package","text":"Modules = [PlantSimEngine]\nPublic = false\nPrivate = true","category":"page"},{"location":"VPLVerse/PlantSimEngine/#DataFrames.DataFrame-Tuple{T} where T<:(AbstractArray{<:PlantSimEngine.ModelList})","page":"PlantSimEngine package","title":"DataFrames.DataFrame","text":"DataFrame(components <: AbstractArray{<:ModelList})\nDataFrame(components <: AbstractDict{N,<:ModelList})\n\nFetch the data from a ModelList (or an Array/Dict of) status into a DataFrame.\n\nExamples\n\nusing PlantSimEngine\nusing DataFrames\n\n# Creating a ModelList\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n# Converting to a Dict of ModelLists\nmodels = Dict(\n    \"Leaf\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    ),\n    \"InterNode\" => ModelList(\n        process1=Process1Model(1.0),\n        process2=Process2Model(),\n        process3=Process3Model()\n    )\n)\n\n# Converting to a DataFrame\ndf = DataFrame(models)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#DataFrames.DataFrame-Union{Tuple{PlantSimEngine.ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S<:PlantMeteo.TimeStepTable}","page":"PlantSimEngine package","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,<:TimeStepTable})\n\nImplementation of DataFrame for a ModelList model with several time steps.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#DataFrames.DataFrame-Union{Tuple{PlantSimEngine.ModelList{T, S}}, Tuple{S}, Tuple{T}} where {T, S<:PlantSimEngine.Status}","page":"PlantSimEngine package","title":"DataFrames.DataFrame","text":"DataFrame(components::ModelList{T,S}) where {T,S<:AbstractDict}\n\nImplementation of DataFrame for a ModelList model with one time step.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.DataFormat-Tuple{Type{<:DataFrames.AbstractDataFrame}}","page":"PlantSimEngine package","title":"PlantSimEngine.DataFormat","text":"DataFormat(T::Type)\n\nReturns the data format of the type T. The data format is used to determine how to iterate over the data. The following data formats are supported:\n\nTableAlike: The data is a table-like object, e.g. a DataFrame or a TimeStepTable. The data is iterated over by rows using the Tables.jl interface.\nSingletonAlike: The data is a singleton-like object, e.g. a NamedTuple   or a TimeStepRow. The data is iterated over by columns.\n\nThe default implementation returns TableAlike for AbstractDataFrame, TimeStepTable, AbstractVector and Dict, TreeAlike for Node, SingletonAlike for Status, ModelList, NamedTuple and TimeStepRow.\n\nThe default implementation for Any throws an error. Users that want to use another input should define this trait for the new data format, e.g.:\n\nPlantSimEngine.DataFormat(::Type{<:MyType}) = TableAlike()\n\nExamples\n\njulia> using PlantSimEngine, PlantMeteo, DataFrames\n\njulia> PlantSimEngine.DataFormat(DataFrame)\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(TimeStepTable([Status(a = 1, b = 2, c = 3)]))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat([1, 2, 3])\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Dict(:a => 1, :b => 2))\nPlantSimEngine.TableAlike()\n\njulia> PlantSimEngine.DataFormat(Status(a = 1, b = 2, c = 3))\nPlantSimEngine.SingletonAlike()\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.DependencyGraph","page":"PlantSimEngine package","title":"PlantSimEngine.DependencyGraph","text":"DependencyGraph{T}(roots::T, not_found::Dict{Symbol,DataType})\n\nA graph of dependencies between models.\n\nArguments\n\nroots::T: the root nodes of the graph.\nnot_found::Dict{Symbol,DataType}: the models that were not found in the graph.\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.DependencyTrait","page":"PlantSimEngine package","title":"PlantSimEngine.DependencyTrait","text":"DependencyTrait(T::Type)\n\nReturns information about the eventual dependence of a model T to other time-steps or objects for its computation. The dependence trait is used to determine if a model is parallelizable  or not.\n\nThe following dependence traits are supported:\n\nTimeStepDependencyTrait: Trait that defines whether a model can be parallelizable over time-steps for its computation.\nObjectDependencyTrait: Trait that defines whether a model can be parallelizable over objects for its computation.\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.ObjectDependencyTrait","page":"PlantSimEngine package","title":"PlantSimEngine.ObjectDependencyTrait","text":"ObjectDependencyTrait(::Type{T})\n\nDefines the trait about the eventual dependence of a model T to other objects for its computation. This dependency trait is used to determine if a model is parallelizable over objects or not.\n\nThe following dependency traits are supported:\n\nIsObjectDependent: The model depends on other objects for its computation, it cannot be run in parallel.\nIsObjectIndependent: The model does not depend on other objects for its computation, it can be run in parallel.\n\nAll models are object dependent by default (i.e. IsObjectDependent). This is probably not right for the majority of models, but:\n\nIt is the safest default, as it will not lead to incorrect results if the user forgets to override this trait\n\nwhich is not the case for the opposite (i.e. IsObjectIndependent)\n\nIt is easy to override this trait for models that are object independent\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is object independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # false\n\nDefine a model that is object dependent:\n\nstruct MyModel2 <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel2}) = IsObjectDependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"type"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.TimeStepDependencyTrait-Tuple{Type}","page":"PlantSimEngine package","title":"PlantSimEngine.TimeStepDependencyTrait","text":"TimeStepDependencyTrait(::Type{T})\n\nDefines the trait about the eventual dependence of a model T to other time-steps for its computation.  This dependency trait is used to determine if a model is parallelizable over time-steps or not.\n\nThe following dependency traits are supported:\n\nIsTimeStepDependent: The model depends on other time-steps for its computation, it cannot be run in parallel.\nIsTimeStepIndependent: The model does not depend on other time-steps for its computation, it can be run in parallel.\n\nAll models are time-step dependent by default (i.e. IsTimeStepDependent). This is probably not right for the  majority of models, but:\n\nIt is the safest default, as it will not lead to incorrect results if the user forgets to override this trait\n\nwhich is not the case for the opposite (i.e. IsTimeStepIndependent)\n\nIt is easy to override this trait for models that are time-step independent\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nObjectDependencyTrait: Defines the trait about the eventual dependence of a model to other objects for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is time-step independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\nCheck if the model is parallelizable over time-steps:\n\ntimestep_parallelizable(MyModel()) # false\n\nDefine a model that is time-step dependent:\n\nstruct MyModel2 <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel2}) = IsTimeStepDependent()\n\nCheck if the model is parallelizable over time-steps:\n\ntimestep_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#Base.copy-Tuple{T} where T<:(AbstractArray{<:PlantSimEngine.ModelList})","page":"PlantSimEngine package","title":"Base.copy","text":"Base.copy(l::AbstractArray{<:ModelList})\n\nCopy an array-alike of ModelList\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#Base.copy-Tuple{T} where T<:(AbstractDict{N, <:PlantSimEngine.ModelList} where N)","page":"PlantSimEngine package","title":"Base.copy","text":"Base.copy(l::AbstractDict{N,<:ModelList} where N)\n\nCopy a Dict-alike ModelList\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#Base.copy-Tuple{T} where T<:PlantSimEngine.ModelList","page":"PlantSimEngine package","title":"Base.copy","text":"Base.copy(l::ModelList)\nBase.copy(l::ModelList, status)\n\nCopy a ModelList, eventually with new values for the status.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=15.0, var2=0.3)\n)\n\n# Copy the model list:\nml2 = copy(models)\n\n# Copy the model list with new status:\nml3 = copy(models, TimeStepTable([Status(var1=20.0, var2=0.5))])\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#Base.getindex-Union{Tuple{T}, Tuple{T, Any}} where T<:PlantSimEngine.ModelList","page":"PlantSimEngine package","title":"Base.getindex","text":"getindex(component<:ModelList, key::Symbol)\ngetindex(component<:ModelList, key)\n\nIndexing a component models structure:     - with an integer, will return the status at the ith time-step     - with anything else (Symbol, String) will return the required variable from the status\n\nExamples\n\nusing PlantSimEngine\n\nlm = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status = (var1=[15.0, 16.0], var2=0.3)\n);\n\nlm[:var1] # Returns the value of the Tₗ variable\nlm[2]  # Returns the status at the second time-step\nlm[2][:var1] # Returns the value of Tₗ at the second time-step\nlm[:var1][2] # Equivalent of the above\n\n# output\n16.0\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.add_model_vars-Tuple{Any, Any, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.add_model_vars","text":"add_model_vars(x, models, type_promotion; init_fun=init_fun_default)\n\nCheck which variables in x are not initialized considering a set of models and the variables needed for their simulation. If some variables are uninitialized, initialize them to their default values.\n\nThis function needs to be implemented for each type of x. The default method works for  any Tables.jl-compatible x and for NamedTuples.\n\nCareful, the function makes a copy of the input x if it does not list all needed variables.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.check_dimensions-Tuple{Any, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.check_dimensions","text":"check_dimensions(component,weather)\ncheck_dimensions(status,weather)\n\nChecks if a component status (or a status directly) and the weather have the same length, or if they can be recycled (length 1 for one of them).\n\nExamples\n\nusing PlantSimEngine, PlantMeteo\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\n# Creating a dummy weather:\nw = Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0)\n\n# Creating a dummy component:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    status=(var1=[15.0, 16.0], var2=0.3)\n)\n\n# Checking that the number of time-steps are compatible (here, they are, it returns nothing):\nPlantSimEngine.check_dimensions(models, w) \n\n# Creating a dummy weather with 3 time-steps:\nw = Weather([\n    Atmosphere(T = 20.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 25.0, Rh = 0.5, Wind = 1.0),\n    Atmosphere(T = 30.0, Rh = 0.5, Wind = 1.0)\n])\n\n# Checking that the number of time-steps are compatible (here, they are not, it throws an error):\nPlantSimEngine.check_dimensions(models, w)\n\n# output\nERROR: DimensionMismatch: Component status should have the same number of time-steps (2) than weather data (3).\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.convert_vars-Tuple{Dict{DataType, DataType}, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.convert_vars","text":"convert_vars(type_promotion::Dict{DataType,DataType}, ref_vars)\nconvert_vars(type_promotion::Nothing, ref_vars)\n\nConvert the status variables to the type specified in the type promotion dictionary.\n\nExamples\n\nIf we want all the variables that are Reals to be Float32, we can use:\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nref_vars = init_variables(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n)\ntype_promotion = Dict(Real => Float32)\n\nPlantSimEngine.convert_vars(type_promotion, ref_vars.process3)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.diff_vars-Tuple{Any, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.diff_vars","text":"diff_vars(x, y)\n\nReturns the names of variables that have different values in x and y.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.draw_guide-NTuple{5, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.draw_guide","text":"draw_guide(h, w, prefix, isleaf, guides)\n\nDraw the line guide for one node of the dependency graph.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.draw_panel-NTuple{5, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.draw_panel","text":"draw_panel(node, graph, prefix, dep_graph_guides, parent; title=\"Soft-coupled model\")\n\nDraw the panels for all dependencies\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.drop_process-Tuple{Any, Symbol}","page":"PlantSimEngine package","title":"PlantSimEngine.drop_process","text":"drop_process(proc_vars, process)\n\nReturn a new NamedTuple with the process process removed from the NamedTuple proc_vars.\n\nArguments\n\nproc_vars::NamedTuple: the NamedTuple from which we want to remove the process process.\nprocess::Symbol: the process we want to remove from the NamedTuple proc_vars.\n\nReturns\n\nA new NamedTuple with the process process removed from the NamedTuple proc_vars.\n\nExample\n\njulia> drop_process((a = 1, b = 2, c = 3), :b)\n(a = 1, c = 3)\n\njulia> drop_process((a = 1, b = 2, c = 3), (:a, :c))\n(b = 2,)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.flatten_vars-Tuple{Any}","page":"PlantSimEngine package","title":"PlantSimEngine.flatten_vars","text":"flatten_vars(vars)\n\nReturn a set of the variables in the vars dictionary.\n\nArguments\n\nvars::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => symbols of inputs.\n\nReturns\n\nA set of the variables in the vars dictionary.\n\nExample\n\njulia> flatten_vars(Dict(:process1 => (:var1, :var2), :process2 => (:var3, :var4)))\nSet{Symbol} with 4 elements:\n  :var4\n  :var3\n  :var2\n  :var1\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.get_Ref_i-Union{Tuple{T}, Tuple{Any, Any, T}} where T<:Nothing","page":"PlantSimEngine package","title":"PlantSimEngine.get_Ref_i","text":"get_Ref_i(node, attr, i<:Nothing)\nget_Ref_i(node, attr, i)\n\nGet reference to node attribute at ith value or value if i<:Nothing.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.homogeneous_ts_kwargs-Tuple{Any, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"homogeneous_ts_kwargs(kwargs)\n\nBy default, the function returns its argument.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.homogeneous_ts_kwargs-Union{Tuple{T}, Tuple{N}, Tuple{NamedTuple{N, T}, Any}} where {N, T}","page":"PlantSimEngine package","title":"PlantSimEngine.homogeneous_ts_kwargs","text":"kwargs_to_timestep(kwargs::NamedTuple{N,T}) where {N,T}\n\nTakes a NamedTuple with optionnaly vector of values for each variable, and makes a  vector of NamedTuple, with each being a time step. It is used to be able to e.g. give constant values for all time-steps for one variable.\n\nExamples\n\nPlantSimEngine.homogeneous_ts_kwargs((Tₗ=[25.0, 26.0], aPPFD=1000.0))\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.init_variables_manual-Tuple{Any, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.init_variables_manual","text":"init_variables_manual(models...;vars...)\n\nReturn an initialisation of the model variables with given values.\n\nExamples\n\nusing PlantSimEngine\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model()\n)\n\nPlantSimEngine.init_variables_manual(status(models), (var1=20.0,))\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.object_parallelizable-Tuple{T} where T","page":"PlantSimEngine package","title":"PlantSimEngine.object_parallelizable","text":"object_parallelizable(x::T)\nobject_parallelizable(x::DependencyGraph)\n\nReturns true if the model x is parallelizable, i.e. if the model can be computed in parallel for different objects, or false otherwise. \n\nThe default implementation returns false for all models. If you develop a model that is parallelizable over objects, you should add a method to ObjectDependencyTrait for your model.\n\nNote that this method can also be applied on a DependencyGraph directly, in which case it returns true if all models in the graph are parallelizable, and false otherwise.\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nObjectDependencyTrait: Defines the trait about the eventual dependence of a model to other objects for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is object independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable over objects:\n\nobject_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.parallelizable-Tuple{T} where T","page":"PlantSimEngine package","title":"PlantSimEngine.parallelizable","text":"parallelizable(::T)\nobject_parallelizable(x::DependencyGraph)\n\nReturns true if the model T or the whole dependency graph is parallelizable, i.e. if the model can be computed in parallel for different time-steps or objects. The default implementation returns false for all models.\n\nSee also\n\ntimestep_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nobject_parallelizable: Returns true if the model is parallelizable over objects, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is parallelizable:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\n# Override the object dependency trait:\nPlantSimEngine.ObjectDependencyTrait(::Type{MyModel}) = IsObjectIndependent()\n\nCheck if the model is parallelizable:\n\nparallelizable(MyModel()) # true\n\nOr if we want to be more explicit:\n\ntimestep_parallelizable(MyModel())\nobject_parallelizable(MyModel())\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.search_inputs_in_output-Tuple{Any, Any, Any}","page":"PlantSimEngine package","title":"PlantSimEngine.search_inputs_in_output","text":"search_inputs_in_output(process, inputs, outputs)\n\nReturn a dictionary with the soft dependencies of the processes in the dependency graph d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nprocess::Symbol: the process for which we want to find the soft dependencies.\ninputs::Dict{Symbol, Vector{Pair{Symbol}, Tuple{Symbol, Vararg{Symbol}}}}: a dict of process => symbols of inputs per process.\noutputs::Dict{Symbol, Tuple{Symbol, Vararg{Symbol}}}: a dict of process => symbols of outputs per process.\n\nDetails\n\nThe inputs (and similarly, outputs) give the inputs of each process, classified by the process it comes from. It can  come from itself (its own inputs), or from another process that is a hard-dependency.\n\nReturns\n\nA dictionary with the soft dependencies for the processes.\n\nExample\n\nin_ = Dict(\n    :process3 => [:process3=>(:var4, :var5), :process2=>(:var1, :var3), :process1=>(:var1, :var2)],\n    :process4 => [:process4=>(:var0,)],\n    :process6 => [:process6=>(:var7, :var9)],\n    :process5 => [:process5=>(:var5, :var6)],\n)\n\nout_ = Dict(\n    :process3 => Pair{Symbol}[:process3=>(:var4, :var6), :process2=>(:var4, :var5), :process1=>(:var3,)],\n    :process4 => [:process4=>(:var1, :var2)],\n    :process6 => [:process6=>(:var8,)],\n    :process5 => [:process5=>(:var7,)],\n)\n\nsearch_inputs_in_output(:process3, in_, out_)\n(process4 = (:var1, :var2),)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.soft_dependencies","page":"PlantSimEngine package","title":"PlantSimEngine.soft_dependencies","text":"soft_dependencies(d::DependencyGraph)\n\nReturn a DependencyGraph with the soft dependencies of the processes in the dependency graph d. A soft dependency is a dependency that is not explicitely defined in the model, but that can be inferred from the inputs and outputs of the processes.\n\nArguments\n\nd::DependencyGraph: the hard-dependency graph.\n\nExample\n\nusing PlantSimEngine\n\n# Load the dummy models given as example in the package:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\n# Create a model list:\nmodels = ModelList(\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n)\n\n# Create the hard-dependency graph:\nhard_dep = hard_dependencies(models.models, verbose=true)\n\n# Get the soft dependencies graph:\nsoft_dep = soft_dependencies(hard_dep)\n\n\n\n\n\n","category":"function"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.timestep_parallelizable-Tuple{T} where T","page":"PlantSimEngine package","title":"PlantSimEngine.timestep_parallelizable","text":"timestep_parallelizable(x::T)\ntimestep_parallelizable(x::DependencyGraph)\n\nReturns true if the model x is parallelizable, i.e. if the model can be computed in parallel over time-steps, or false otherwise.\n\nThe default implementation returns false for all models. If you develop a model that is parallelizable over time-steps, you should add a method to ObjectDependencyTrait for your model.\n\nNote that this method can also be applied on a DependencyGraph directly, in which case it returns true if all models in the graph are parallelizable, and false otherwise.\n\nSee also\n\nobject_parallelizable: Returns true if the model is parallelizable over time-steps, and false otherwise.\nparallelizable: Returns true if the model is parallelizable, and false otherwise.\nTimeStepDependencyTrait: Defines the trait about the eventual dependence of a model to other time-steps for its computation.\n\nExamples\n\nDefine a dummy process:\n\nusing PlantSimEngine\n\n# Define a test process:\n@process \"TestProcess\"\n\nDefine a model that is time-step independent:\n\nstruct MyModel <: AbstractTestprocessModel end\n\n# Override the time-step dependency trait:\nPlantSimEngine.TimeStepDependencyTrait(::Type{MyModel}) = IsTimeStepIndependent()\n\nCheck if the model is parallelizable over objects:\n\ntimestep_parallelizable(MyModel()) # true\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.HardDependencyNode, Function, Vector}","page":"PlantSimEngine package","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::HardDependencyNode, f::Function, var::Vector)\n\nApply function f to node, and then its children (hard-dependency nodes).\n\nMutate the vector var by pushing a pair of the node process name and the result of the function f.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.traverse_dependency_graph!-Tuple{PlantSimEngine.SoftDependencyNode, Function, Vector}","page":"PlantSimEngine package","title":"PlantSimEngine.traverse_dependency_graph!","text":"traverse_dependency_graph(node::SoftDependencyNode, f::Function, var::Vector; visit_hard_dep=true)\n\nApply function f to node, visit its hard dependency nodes (if visit_hard_dep=true), and  then its soft dependency children.\n\nMutate the vector var by pushing a pair of the node process name and the result of the function f.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.traverse_dependency_graph-Tuple{PlantSimEngine.DependencyGraph, Function}","page":"PlantSimEngine package","title":"PlantSimEngine.traverse_dependency_graph","text":"traverse_dependency_graph(graph::DependencyGraph, f::Function, visit_hard_dep=true)\n\nTraverse the dependency graph and apply the function f to each node. The first-level soft-dependencies are traversed first, then their hard-dependencies (if visit_hard_dep=true), and then the children of the soft-dependencies.\n\nReturn a vector of pairs of the node and the result of the function f.\n\nExample\n\nusing PlantSimEngine\n\nfunction f(node)\n    node.value\nend\n\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"))\n\nvars = (\n    process1=Process1Model(1.0),\n    process2=Process2Model(),\n    process3=Process3Model(),\n    process4=Process4Model(),\n    process5=Process5Model(),\n    process6=Process6Model(),\n    process7=Process7Model(),\n)\n\ngraph = dep(vars)\ntraverse_dependency_graph(graph, f)\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.update_mtg_models!-Tuple{MultiScaleTreeGraph.Node, Any, Any, Symbol}","page":"PlantSimEngine package","title":"PlantSimEngine.update_mtg_models!","text":"update_mtg_models!(mtg::MultiScaleTreeGraph.Node, i, attr_name::Symbol)\n\nUpdate the mtg models initialisations by using the ith time-step. The mtg is considered fully initialized already once, so init_mtg_models! must be called before update_mtg_models!.\n\nThe values are updated only for node attributes in to_init. Those attributes must have several time-steps, i.e. indexable by 1:n time-steps.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.variables_typed-Tuple{T} where T<:PlantSimEngine.AbstractModel","page":"PlantSimEngine package","title":"PlantSimEngine.variables_typed","text":"variables_typed(model)\nvariables_typed(model, models...)\n\nReturns a named tuple with the name and the types of the variables needed by a model, or a union of those for several models.\n\nExamples\n\nusing PlantSimEngine;\n\n# Including an example script that implements dummy processes and models:\ninclude(joinpath(pkgdir(PlantSimEngine), \"examples/dummy.jl\"));\n\nPlantSimEngine.variables_typed(Process1Model(1.0))\n(var1 = Float64, var2 = Float64, var3 = Float64)\n\nPlantSimEngine.variables_typed(Process1Model(1.0), Process2Model())\n\n# output\n(var4 = Float64, var5 = Float64, var1 = Float64, var2 = Float64, var3 = Float64)\n\nSee also\n\ninputs, outputs and variables\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#PlantSimEngine.vars_not_init_-Union{Tuple{T}, Tuple{T, Any}} where T<:PlantSimEngine.Status","page":"PlantSimEngine package","title":"PlantSimEngine.vars_not_init_","text":"vars_not_init_(st<:Status, var_names)\n\nGet which variable is not properly initialized in the status struct.\n\n\n\n\n\n","category":"method"},{"location":"VPLVerse/PlantSimEngine/#Tables.schema-Union{Tuple{PlantMeteo.TimeStepTable{T}}, Tuple{T}} where T<:PlantSimEngine.Status","page":"PlantSimEngine package","title":"Tables.schema","text":"Tables.schema(m::TimeStepTable{Status})\n\nCreate a schema for a TimeStepTable{Status}.\n\n\n\n\n\n","category":"method"}]
}
