<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Ray tracing · Virtual Plant Laboratory</title><meta name="title" content="Ray tracing · Virtual Plant Laboratory"/><meta property="og:title" content="Ray tracing · Virtual Plant Laboratory"/><meta property="twitter:title" content="Ray tracing · Virtual Plant Laboratory"/><meta name="description" content="Documentation for Virtual Plant Laboratory."/><meta property="og:description" content="Documentation for Virtual Plant Laboratory."/><meta property="twitter:description" content="Documentation for Virtual Plant Laboratory."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Virtual Plant Laboratory</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Virtual Plant Laboratory</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Julia/">Julia basic concepts</a></li><li><a class="tocitem" href="../Graphs/">Dynamic graph creation and manipulation</a></li><li><a class="tocitem" href="../Geometry/Primitives/">Geometry primitives</a></li><li><a class="tocitem" href="../Geometry/Turtle/">Turtle geometry and scenes</a></li><li class="is-active"><a class="tocitem" href>Ray tracing</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#How-ray-tracing-works"><span>How ray tracing works</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Radiation-sources"><span>Radiation sources</span></a></li><li><a class="tocitem" href="#Materials"><span>Materials</span></a></li><li><a class="tocitem" href="#Acceleration-of-ray-tracing"><span>Acceleration of ray tracing</span></a></li><li><a class="tocitem" href="#Grid-cloner-for-edge-effects"><span>Grid cloner for edge effects</span></a></li></ul></li><li><a class="tocitem" href="../Visualization/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/intro_tut/">Intro</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Getting started with VPL</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/getting_started/algae/">Algae growth</a></li><li><a class="tocitem" href="../../tutorials/getting_started/snowflakes/">The Koch snowflake</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">From tree to forest</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/from_tree_forest/tree/">Tree</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/forest/">Forest</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/growthforest/">Growth forest</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/raytracedforest/">Ray-traced forest</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">More on rules and queries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/more_rules_queries/context/">Context sensitive rules</a></li><li><a class="tocitem" href="../../tutorials/more_rules_queries/relationalqueries/">Relational queries</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/GridCloner/">Setting up a grid cloner</a></li><li><a class="tocitem" href="../../howto/Message/">Messages in scenes</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/graphs/">Graphs</a></li><li><a class="tocitem" href="../../api/geometry/">Scenes and 3D meshes</a></li><li><a class="tocitem" href="../../api/turtle/">Turtle geometry</a></li><li><a class="tocitem" href="../../api/raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../../api/viz/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">VPLVerse</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">SkyDomes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/SkyDomes/">SkyDomes package</a></li><li><a class="tocitem" href="../../VPLVerse/SkyDomes/API/">SkyDomes API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Ecophys</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/Ecophys/">Ecophys package</a></li><li><a class="tocitem" href="../../VPLVerse/Ecophys/photosynthesis/">Photosynthesis API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">PlantSimEngine</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/PlantSimEngine/">PlantSimEngine package</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">PlantBioPhysics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/PlantBioPhysics/">PlantBioPhysics package</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developers/organization/">Internal organization</a></li><li><a class="tocitem" href="../../developers/use&amp;dev_packages/">Package and Environment Management for VPL</a></li><li><a class="tocitem" href="../../developers/style/">Styling protocol</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Ray tracing</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Ray tracing</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/VPLDocs/blob/master/docs/src/manual/Raytracer.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="manual_raytracer"><a class="docs-heading-anchor" href="#manual_raytracer">Ray tracing</a><a id="manual_raytracer-1"></a><a class="docs-heading-anchor-permalink" href="#manual_raytracer" title="Permalink"></a></h1><p>Alejandro Morales</p><p>Centre for Crop Systems Analysis - Wageningen University</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>VPL offers a built-in ray tracer that can be used to simulate the distribution of irradiance within a 3D scene. It is a Monte Carloy ray tracer written 100% in Julia with the following features:</p><ul><li>Multiple wavelengths.</li><li>Most common types of materials and radiation sources are provided, but additional ones can be added by the user.</li><li>Support for multi-threaded execution.</li><li>An Bounding Volume Hierarchy to speed up the computation.</li><li>A grid cloner that duplicates (implicitly) the scene in a grid to approximate large canopies.</li><li>A Russian roulette mechanism to reduce the number of iterations per ray needed while avoiding introducing biases in the computations.</li></ul><h2 id="How-ray-tracing-works"><a class="docs-heading-anchor" href="#How-ray-tracing-works">How ray tracing works</a><a id="How-ray-tracing-works-1"></a><a class="docs-heading-anchor-permalink" href="#How-ray-tracing-works" title="Permalink"></a></h2><p>Rays are generated from the radiation soures. A ray is defined by an origin, a direction and a ray <em>payload</em> that contains the radiant power per wavelength (this would usually be W or umol/s, but the ray tracer is agnostic with respect to units). Ray tracing is a recursive process in which a ray is traced through the scene (by testing whether the ray intersects different parts of the scenes and triangles in it) until it either hits a triangle in a mesh or leaves the scene through its boundaries.</p><p>When a ray hits a triangle inside a mesh, the ray is modified according to the <code>Material</code> object associated to that triangle (see below). In most cases this would result in a new ray being generated (either as reflected or transmitted radiation) which is then traced. Also, in most cases, a fraction of the radiant power carried by the ray will be transferred to the <code>Material</code> object.</p><p>The recursive nature of the ray tracer allows simulating scattering within the scene and, if multiple wavelengths are used and optical properties vary per wavelength, also changes in the spectral composition of the radiation (e.g., red/far red). As the rays are scattered, their radiant power decreases such that at some point it is not worth tracing them any further. The user can control the maximum number of iterations per ray after which termination may be considered (this is <code>maxiter</code> in <a href="../../api/raytracer/#PlantRayTracer.RTSettings"><code>PlantRayTracer.RTSettings</code></a>).</p><p>If <code>maxiter = 1</code>, the ray tracer will effectively behave as a <em>ray caster</em>, meaning than only primary rays are traced (e.g., for a field crop, this means that only direct and diffuse radiation will be simulated, not the scattered component).</p><p>Once <code>maxiter</code> is reached though, the ray is not guaranteed to be terminated. The reason is that terminating all rays will introduce a bias in the results (i.e., total radiation in the scene will be underestimated), especially when a large number of raus is simulated. To avoid this, VPL implements a Russian roulette mechanism that will terminate a ray with a probability (<code>pkill</code>) and increase the payload of the rays that survive. This introduces variance</p><p>The ray tracer supports the construction of a bounding volume hierarchy (BVH) that can be used to speed up the computations (by minimizing the number of ray triangle intersections), especially for scenes with a  large number of triangles. The BVH is constructed automatically (see below) but the user can specific some settings to control its construction. It is also possible to turn off this structure altogether, in which case all rays will be tested against all triangles.</p><p>In order to simulate large canopies, VPL implements a grid cloner that will duplicated (with minimum memory and computational overhead) the scene in a grid along the different axes. This is particularly useful for reducing edge effects without having to simulate a large number of plants (see below for details).</p><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><p>To use ray tracing the user will need to define a <code>Scene</code> object (see <a href="../../api/geometry/#PlantGeomPrimitives.Scene-Tuple{Vector{&lt;:PlantGeomPrimitives.Scene}}"><code>PlantGeomPrimitives.Scene</code></a>) and the radiation sources (see below) which are then combined with <code>RayTracer()</code>. This results in a <code>Raytracer</code> object that contains all the necessary information to perform the ray tracing. To actually execute the ray tracing the user will need to call <code>trace!()</code> on this object.</p><p>Executing the ray tracer will return the total number of rays that were tracer (including secondary rays) but the most important change is that radiant power stored in the <code>Material</code> objects in the scene will be updated automatically. This means that the user will need to store the <code>Material</code> objects in a data structure that is accesible (e.g., within a node in a graph).</p><p>Most of the settings for the ray tracer are defined in the <code>RTSettings</code> object which is passed to <code>RayTracer()</code> when creating the ray tracer. These settings include <code>maxiter</code> and <code>pkill</code> for the Russian roulette, the settings for the grid cloner and whether the tracing should be run in parallel or not.</p><h2 id="Radiation-sources"><a class="docs-heading-anchor" href="#Radiation-sources">Radiation sources</a><a id="Radiation-sources-1"></a><a class="docs-heading-anchor-permalink" href="#Radiation-sources" title="Permalink"></a></h2><p>VPL define radiation sources as a combination of of a <em>geometry</em> component and an <em>angle</em> component. The geometry component determines where are the rays being generated, whereas the angle component determines the direction of the rays. Each radiation source is thus constructed by specifying the geometry and the angle, plus the number of rays and radiant power per wavelength to be stored in the ray. See documentation on <a href="../../api/raytracer/#PlantRayTracer.Source-Tuple{Any, Any, Number, Integer}"><code>PlantRayTracer.Source</code></a> for more details.</p><p>The followig geometry components are available in VPL:</p><ul><li><code>PointSource</code>: All rays are generated from a single point in space.</li><li><code>LineSource</code>: All rays are generated from a line in space.</li><li><code>AreaSource</code>: All rays are generated from the surface of a user-defined mesh.</li></ul><p>The following angle components are available in VPL:</p><ul><li><code>FixedSource</code>: All rays have the same direction.</li><li><code>LambertianSource</code>: The direction of the rays follows Lambert&#39;s cosine law.</li></ul><p>This means that the irradiance is the same when viewed from any angle.</p><p>A special type of radiation source is the <code>DirectionalSource</code> which is used to simulate solar radiation. Rays from this source are generated from the upper face of the scene bounding box and their direction is defined in polar coordinates (i.e., by a zenith and azimuth angle). Because of the way directional sources are implemented it is recommended that a grid cloner is used (this is the default) as otherwise there will parts of the scene that will recieve no rays. See documentation on <a href="../../api/raytracer/#PlantRayTracer.DirectionalSource-Tuple{PlantRayTracer.AABB}"><code>PlantRayTracer.DirectionalSource</code></a> for more details.</p><h2 id="Materials"><a class="docs-heading-anchor" href="#Materials">Materials</a><a id="Materials-1"></a><a class="docs-heading-anchor-permalink" href="#Materials" title="Permalink"></a></h2><p>Several types of materials are available for ray tracing, which all inherit from the <code>Material</code> abstract type. The materials play two roles: (i) they define the optical properties of the surface (i.e., reflectance and transmittance) for the different wavelengths being simulated, and (ii) store the radiant power absorbed by the surface. If the radiant power of a surface is needed, it is important that the material object is stored in a data structure that the user can have access to (e.g., within a node in a graph) as the raytracer will simply modify in-place (without creating a copy) the material object when a ray is absorbed. The radiant power in a material can be retrieved by applying <code>power()</code> to the object.</p><p>Materials are added to the scene at ther same time as the geometry either via <code>feed()</code> or <code>add!()</code>. It is possible to add one material per mesh (in which case all triangles within that mesh will share the same material object) or one material per triangle. In either case, VPL will take care of creating the corresponding association between the material and the triangles.</p><p>VPL will not check that the number of wavelengths in the material matches the equivalent number in the radiation source or that the same ordering is used. This is entirely up to the user.</p><p>The following material types are available in VPL:</p><ul><li><code>Black</code>: A material that absorbs all the rays that hit it (equivalent to no</li></ul><p>reflectance or transmittance). It is not a realistic material but it is useful for debugging purposes or for special uses of a ray tracer (e.g., to compute ground cover).</p><ul><li><code>Sensor</code>: A material that registers the rays that hit and their radian power</li></ul><p>but it does not alter the radiant power or the direction of the rays themselves. This is useful for measuring the distribution of irradiance within canopy without disturbing the system. Note that a <code>Sensor</code> will not add to the scattering counter either so there is no need to modify the settings of the Russian roulette.</p><ul><li><code>Lambertian</code>: A material that describes a perfect diffuser with user-defined</li></ul><p>reflectance and transmittance per wavelength.</p><ul><li><code>Phong</code>: A modified Phong material that implements the equations by</li></ul><p><a href="https://www.cs.princeton.edu/courses/archive/fall03/cs526/papers/lafortune94.pdf">Lafortune &amp; Willems (1994)</a>. Reflectance is modelled as a combination of a diffuse and a specular component per wavelength.</p><h2 id="Acceleration-of-ray-tracing"><a class="docs-heading-anchor" href="#Acceleration-of-ray-tracing">Acceleration of ray tracing</a><a id="Acceleration-of-ray-tracing-1"></a><a class="docs-heading-anchor-permalink" href="#Acceleration-of-ray-tracing" title="Permalink"></a></h2><p>In order to accelerate the tracing of rays within the 3D scene, a <a href="https://en.wikipedia.org/wiki/Bounding_interval_hierarchy">bounding volume hierarchy</a> may be used by setting <code>acceleration = BVH</code> in the call to <code>RayTracer()</code>. This will create a series of nested <a href="https://en.wikipedia.org/wiki/Bounding_volume">axis-aligned bounding boxes</a> organized as a binary tree. The purpose of this structure is to reduce the number of triangles that need to be tested against each ray (i.e., if a ray does not intersect a particular box, it will not intersect any of the triangles inside of it). This does add some additional cost due to the need to test the intersection of rays against the bounding boxes, but ideally this is much less than the cost of testing against all the excluded triangles.</p><p>The tree is constructed by recursively splitting each box into two halves and allocating the different triangles in the mesh to the corresponding boxes. Two rules are available for splitting the boxes, which must also be specified in the call to <code>RayTracer()</code>:</p><ul><li><code>rule = AvgSplit(N, L)</code>: It splits each node along the longest axis at the</li></ul><p>average coordinate of the triangles in the node. The splitting is repeated until the number of triangles in a node is lessor equal than <code>N</code> or the total number of recursive splits (i.e., the depth of the binary tree) reaches <code>L</code>.</p><ul><li><code>rule = SAH{K}(N, L)</code>: It splits each node using the <a href="https://medium.com/@bromanz/how-to-create-awesome-accelerators-the-surface-area-heuristic-e14b5dec6160">Surface Area Heuristic</a></li></ul><p>that defines the expected computation of ray tracing a splitted node versus not doing it. This method computes the cost of splitting each box along each of its three axes at different positions given by the value <code>K</code>. When <code>K = 1</code> the split occurs at the median of the triangles in the box. For <code>K &gt; 1</code> the splits occur at different quantiles of the triangles in the box. The splitting is repeated until the number of triangles in a node is lessor equal than <code>N</code> or the total number of recursive splits reaches <code>L</code> or the cost of splitting a node exceeds the cost of not splitting it.</p><p>For debugging purposes (or for very small scenes), the user may also specify <code>acceleration = Naive</code> which will basically not implement any acceleration structured and all rays will be tested against all triangles.</p><p>The acceleration structure is created from a <code>Scene</code> object via the <code>accelerate()</code> function, and allows specifying the <code>acceleration</code> and <code>rule</code> arguments. This will also be responsible of translating the triangular mesh into the data structure used by the ray tracer (triangles in <a href="https://en.wikipedia.org/wiki/Barycentric_coordinate_system">barycentric coordinates</a>) as well as fitting a grid cloner to the scene (see below).</p><h2 id="Grid-cloner-for-edge-effects"><a class="docs-heading-anchor" href="#Grid-cloner-for-edge-effects">Grid cloner for edge effects</a><a id="Grid-cloner-for-edge-effects-1"></a><a class="docs-heading-anchor-permalink" href="#Grid-cloner-for-edge-effects" title="Permalink"></a></h2><p>The grid cloner is used to minimize border effects when tracing rays from the sources towards the scene. The grid cloner is a form of <a href="https://en.wikipedia.org/wiki/Geometry_instancing">geometric <em>instancing</em></a> where the same scene is repeated multiple times along the X, Y or Z direction. In practice, to avoid excessive memory usage, the scene is not actually replicated but rather the rays positions are modified to emulate the effect of the scene being repeated.</p><p>In order a grid cloner structure on top of a scene, the user needs to specify the number of duplications to perform in each direction (<code>nx</code>, <code>ny</code> and <code>nz</code>) as well as the offsets between the different copies (<code>dx</code>, <code>dy</code> and <code>dz</code>). The grid cloner is created from a <code>Scene</code> object via the <code>accelerate()</code> function, but the settings to control the grid cloner must be set when creating the <code>RTSettings</code> object.</p><p>By default, the grid cloner is enabled in the X and Y directions by replicating the scene three times in each direction (this means creating a grid of 7 x 7 = 49 copies of the scene including the original). The offsets between the copies are set by default to width of the scene in the X and Y directions such that there is no overlapping. The grid cloner is disabled in the Z direction by default.</p><p>Note that whereas a grid cloner will not increase significantly the memory used by the ray tracer, it will increase ray tracing times as fewer rays will be able to leave the scene. On the other hand, a small (or no) grid cloner will create an edge effect such that only plants in the center of the scene will be able to capture the behaviour within a large canopy.</p><p>The actual number of copies to use will depend on plant dimension and solar angles, so a general recommendation is not possible. Regarding the offsets, these would be related to the sowing/planting pattern in the case of plant production systems on a regular grid and in many case this would mean that the copies overlap (and this would be correct) so the defaults should be overriden in most cases. Using a grid cloner should not be substitute for using a sufficient number of plants in the scene in order to capture the plant-to-plant variability, but simply to avoid edge effects.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Geometry/Turtle/">« Turtle geometry and scenes</a><a class="docs-footer-nextpage" href="../Visualization/">3D visualization »</a><div class="flexbox-break"></div></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 8 May 2024 14:01">Wednesday 8 May 2024</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
