<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Multiple dispatch and composition · Virtual Plant Laboratory</title><meta name="title" content="Multiple dispatch and composition · Virtual Plant Laboratory"/><meta property="og:title" content="Multiple dispatch and composition · Virtual Plant Laboratory"/><meta property="twitter:title" content="Multiple dispatch and composition · Virtual Plant Laboratory"/><meta name="description" content="Documentation for Virtual Plant Laboratory."/><meta property="og:description" content="Documentation for Virtual Plant Laboratory."/><meta property="twitter:description" content="Documentation for Virtual Plant Laboratory."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Virtual Plant Laboratory</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Virtual Plant Laboratory</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox" checked/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Julia/">Julia basic concepts</a></li><li class="is-active"><a class="tocitem" href>Multiple dispatch and composition</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li><a class="tocitem" href="#Abstract-types"><span>Abstract types</span></a></li><li><a class="tocitem" href="#Composition"><span>Composition</span></a></li><li><a class="tocitem" href="#Method-forwarding"><span>Method forwarding</span></a></li><li><a class="tocitem" href="#About-object-oriented-programming"><span>About object-oriented programming</span></a></li></ul></li><li><a class="tocitem" href="../Modules/">Modules and files</a></li></ul></li><li><a class="tocitem" href="../../Graphs/">Dynamic graph creation and manipulation</a></li><li><a class="tocitem" href="../../Geometry/Primitives/">Geometry primitives</a></li><li><a class="tocitem" href="../../Geometry/Turtle/">Turtle geometry and scenes</a></li><li><a class="tocitem" href="../../Raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../../Visualization/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/intro_tut/">Intro</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Getting started with VPL</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/getting_started/algae/">Algae growth</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/snowflakes/">The Koch snowflake</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">From tree to forest</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/from_tree_forest/tree/">Tree</a></li><li><a class="tocitem" href="../../../tutorials/from_tree_forest/forest/">Forest</a></li><li><a class="tocitem" href="../../../tutorials/from_tree_forest/growthforest/">Growth forest</a></li><li><a class="tocitem" href="../../../tutorials/from_tree_forest/raytracedforest/">Ray-traced forest</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">More on rules and queries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/more_rules_queries/context/">Context sensitive rules</a></li><li><a class="tocitem" href="../../../tutorials/more_rules_queries/relationalqueries/">Relational queries</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../howto/GridCloner/">Setting up a grid cloner</a></li><li><a class="tocitem" href="../../../howto/Message/">Messages in scenes</a></li><li><a class="tocitem" href="../../../howto/Materials/">Multiple materials/colors</a></li><li><a class="tocitem" href="../../../howto/Traversal/">Advanced traversal</a></li><li><a class="tocitem" href="../../../howto/Coordinates/">Absolute coordinates</a></li><li><a class="tocitem" href="../../../howto/LightSources/">Creating light sources</a></li><li><a class="tocitem" href="../../../howto/Slicer/">Using the slicer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/graphs/">Graphs</a></li><li><a class="tocitem" href="../../../api/geometry/">Scenes and 3D meshes</a></li><li><a class="tocitem" href="../../../api/turtle/">Turtle geometry</a></li><li><a class="tocitem" href="../../../api/raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../../../api/viz/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">VPLVerse</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">SkyDomes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../VPLVerse/SkyDomes/">SkyDomes package</a></li><li><a class="tocitem" href="../../../VPLVerse/SkyDomes/API/">SkyDomes API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Ecophys</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../VPLVerse/Ecophys/">Ecophys package</a></li><li><a class="tocitem" href="../../../VPLVerse/Ecophys/photosynthesis/">Photosynthesis API</a></li><li><a class="tocitem" href="../../../VPLVerse/Ecophys/growth/">Growth API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">PlantSimEngine</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../VPLVerse/PlantSimEngine/">PlantSimEngine package</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">PlantBioPhysics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../VPLVerse/PlantBioPhysics/">PlantBioPhysics package</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../developers/organization/">Internal organization</a></li><li><a class="tocitem" href="../../../developers/use&amp;dev_packages/">Package and Environment Management for VPL</a></li><li><a class="tocitem" href="../../../developers/style/">Styling protocol</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">Julia</a></li><li class="is-active"><a href>Multiple dispatch and composition</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Multiple dispatch and composition</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/VPLDocs/blob/master/docs/src/manual/Julia/Objects.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="manual_objets"><a class="docs-heading-anchor" href="#manual_objets">Multiple dispatch and composition</a><a id="manual_objets-1"></a><a class="docs-heading-anchor-permalink" href="#manual_objets" title="Permalink"></a></h1><p>In this document we will learn how types and methods relate in Julia.</p><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>A type in Julia is a structure that collects related data and can be assigned specific behavior (see below on <em>methods</em>). We create types using the <code>struct</code> keyword (with optional modifiers) and listing the data fields that the type will contain (and we recommend to include the type of data, for performance reasons).</p><p>For example, we can create types that represent leaves and fruits of a plant with some basic properties.</p><pre><code class="language-julia hljs">struct Leaf
    length::Float64
    width::Float64
    weight::Float64
    color::String
end

struct Fruit
    radius::Float64
    weight::Float64
    color::String
end</code></pre><p>We can create instances of these types:</p><pre><code class="language-julia hljs">L = Leaf(10.0, 5.0, 1.0, &quot;green&quot;)
F = Fruit(1.0, 0.5, 1.0, &quot;red&quot;)</code></pre><p>All the data fields in a type are public by default, which means that we can access them directly.</p><pre><code class="language-julia hljs">L.length
F.color</code></pre><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><p>Functions in Julia can be defined to operate on specific types of data if you annotate the type of arguments in the function definition. For example, we can define a function to calculate the surface area of a plant organ, but the formula to be used is different for leaves and fruits. We could define two different functions, one for each type (e.g., <code>area_leaf</code> and <code>area_fruit</code>), but this would make the code more quite cumbersome and hard to manage. Instead, we can define a single function <code>area</code> that will behave differently depending on the type of the argument passed to it:</p><pre><code class="language-julia hljs"># Area of a leaf assuming an ellipse
function area(organ::Leaf)
    pi*organ.length*organ.width/4
end

# Area of a fruit assuming a sphere
function area(organ::Fruit)
    4*pi*organ.radius^2
end</code></pre><p>We can now call the function <code>area</code> with either a leaf or a fruit and it will return the correct area:</p><pre><code class="language-julia hljs">area(L)
area(F)</code></pre><p>This is an example of <em>multiple dispatch</em>, which is a key feature of Julia. It allows us to define functions that can operate on different types of data and have different behavior depending on the type of the argument passed to it. The <em>dispatch</em> part means that the call to the function <code>area</code> will be dispatched to the correct method based on the type of the argument passed to it.</p><p>Dispatch will work on the combination of the types of all arguments, not just the first one. For example, let&#39;s define two types of pests that can affect a plant, a larva that can infest fruits and a caterpillar that can infest leaves. We want to test whether a particular pest can infest a particular organ of the plant. We can define the types and methods as follows:</p><pre><code class="language-julia hljs">struct Larva
end
struct Caterpillar
end
# Method to test whether a larva can infest an organ
infest(pest::Larva, organ::Fruit) = true
infest(pest::Larva, organ::Leaf) = false
# Method to test whether a caterpillar can infest an organ
infest(pest::Caterpillar, organ::Fruit) = false
infest(pest::Caterpillar, organ::Leaf) = true</code></pre><p>Note that we did not add any fields to the pest types, as for now we are only interested in whether they can infest a particular organ or not. Also, we are defining the methods using a simpler syntax (without the <code>function</code> and <code>end</code> keyword) as they are quite simple.</p><p>Note that you can also define methods where the arguments are not annotated with specific types. This will become a default method that will be called if the types of the arguments do not match any of the the other methods. For example, we can add a default method that returns <code>false</code> by default:</p><pre><code class="language-julia hljs">infest(pest, organ) = false</code></pre><p>This means that if we call <code>infest</code> with a pest and an organ that are not <code>Larva</code> or <code>Caterpillar</code> and <code>Fruit</code> or <code>Leaf</code>, respectively, it will return <code>false</code>. Of course, we can add more specific methods later to handle other types of pests or organs.</p><p>Note that you can define methods for types that you did not create, not just for your own types, even if they are stored in packages you downloaded from the internet. This allows extending functionality of existing types and allows your own types to interact with types defined by someone else.</p><p>Also, you can sometimes define types and methods that are meant to use by some algorithm in a package, also extending the functionality of that package. For example, in VPL, you can define types that are meant to be used as nodes in graphs and this can be achieved by simply defining a couple of methods for specific functions defined in VPL (like the <code>feed!</code> method to generate geometry). The flexibility of multiple dispatch is one of the key features of Julia.</p><h2 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h2><p>Abstract types are an optional feature in Julia that allows implementing a reduced form of <em>inheritance</em> in Julia. The idea is that one can define a method for an abstract type and any type that inherits from that abstract type will match that method. Abstract types can also inherit from other abstract types, allowing to create a hierarchy of types.</p><p>For example, we could define an abstract type <code>Organ</code> from which all plants organs will inherit. Abstract types do not contain any data and we cannot create instances of them, they are really just tags for asigning methods. Inheritance is indicated with the symbol <code>&lt;:</code> after the name of the type.</p><p>Let&#39;s create a new version of the <code>Leaf</code> and <code>Fruit</code> types that inherit from an <code>Organ</code> abstract type. Unfortunately, Julia does not allow redefining types (unless you put them in a module and import said module, we will do this in the VPL tutorials), so we will just call them <code>Leaf2</code> and <code>Fruit2</code> for the purpose of this example:</p><pre><code class="language-julia hljs">abstract type Organ end

struct Leaf2 &lt;: Organ
    length::Float64
    width::Float64
    weight::Float64
    color::String
end

struct Fruit2 &lt;: Organ
    radius::Float64
    weight::Float64
    color::String
end</code></pre><p>We could now define a method that operates on any organ, regardless of its type, for example, to extract the color of the organ:</p><pre><code class="language-julia hljs">get_color(organ::Organ) = organ.color</code></pre><p>And we can call it with any organ type that inherits from <code>Organ</code>:</p><pre><code class="language-julia hljs">L2 = Leaf2(10.0, 5.0, 1.0, &quot;green&quot;)
F2 = Fruit2(1.0, 0.5, 1.0, &quot;red&quot;)
println(&quot;Leaf2 color: &quot;, get_color(L2))
println(&quot;Fruit2 color: &quot;, get_color(F2))</code></pre><p>Note that if we now define a method of <code>get_color</code> for <code>Leaf2</code> or <code>Fruit2</code>, it will override the method for <code>Organ</code> and that one will be called instead. That is, the method defined for the abstract type will be called only if there is no more specific method defined for the concrete type. Abstract types and inheritance are not as important in Julia as in traditional object-oriented programming languages.</p><p>In the context of VPL, you will need to define some types to extend the functionality of the package and in those cases you will need to inherit from specific abstract types defined in VPL. For example, when defining your own type of data structures to be used as node in dynamic graphs (see tutorials for examples) those types will need to inherit from the <code>Node</code> abstract type defined in VPL. This allows the internal code for graph rewriting to handle objects defined by the user (which are obviously not known by the VPL developers ahead of time).</p><p>In addition, the user will have to define specific methods for their data structures that are expected by the VPL in order for their internal algorithms to work properly. This is known as an <em>interface</em> and it is a common practice in Julia programming. For example, in the most common version of FSP models built with VPL, the user will have to define data types that inherit from <code>Node</code> and define a method for the <code>feed!</code> function that generates the geometry associated to each type of node. If you omit the <code>feed!</code> method, you will still be able to use those types as nodes in the dynamic graphs but they will not generate any geometry (which in some cases it may be what you want).</p><h2 id="Composition"><a class="docs-heading-anchor" href="#Composition">Composition</a><a id="Composition-1"></a><a class="docs-heading-anchor-permalink" href="#Composition" title="Permalink"></a></h2><p>In the previous sections we have seen how to define types and methods in Julia, as well as how to use abstract types to create a hierarchy of types. These two approaches allow for reuse of methods for multiple types (that share the same abstract type) as well as extending code to work with new types. However, the methods that are being reused expected certain data to be expected in the type. For example, the <code>get_color</code> method above expects that the type has a <code>color</code> field, otherwise it will throw an error. There is therefore a need to reuse data as well, not just methods. This is where <em>composition</em> comes into play.</p><p>Composition is a design principle in which a complex object is composed of simpler objects. The idea is that the simpler objects implement a specific functionality with associated data such that we can add functionality to a type by composing it with other types. Let&#39;s define the functionality <em>growth</em> that will confer any organ the ability to grow. We will assume a logistic growth model, where current growth rate is proportional to the current weight. We thus need to keep track of the current weight, the maximum weight that the organ can attain and the relative growth rate. We can define a type that implements this functionality as follows:</p><pre><code class="language-julia hljs">mutable struct Growth
    weight::Float64 # Current weight of the organ
    max_weight::Float64 # Maximum weight of the organ
    rgr::Float64 # Relative growth rate
end</code></pre><p>Note that we added the <code>mutable</code> keyword to the type definition, which means that instances of this type can be modified after they are created. This is important because we will need to update the current weight of the organ as it grows. We can then define a method that will update the current weight of the organ based on the growth rate and the maximum weight:</p><pre><code class="language-julia hljs">function grow!(growth::Growth)
    if growth.weight &lt; growth.max_weight
        growth.weight += growth.rgr*growth.weight*(1 - growth.weight/growth.max_weight)
    end
    return nothing
end</code></pre><p>Note that we modify the <code>weight</code> field of the <code>growth</code> instance in place, which is possible because we defined the type as <code>mutable</code>. The <code>grow!</code> function will not return anything, it will just update the <code>weight</code> field of the <code>growth</code> instance.</p><p>We can now define new types of leaves and fruits that will have the ability to grow by composing them with the <code>Growth</code> type. As explained before, we need to define new types because we did not put them in their own module and import it:</p><pre><code class="language-julia hljs">struct Leaf3 &lt;: Organ
    length::Float64
    width::Float64
    color::String
    growth::Growth # Composition with Growth type
end
struct Fruit3 &lt;: Organ
    radius::Float64
    color::String
    growth::Growth # Composition with Growth type
end</code></pre><p>Note how we have replaced the previous <code>weight</code> field with a <code>growth</code> field that contains an instance of the <code>Growth</code> type. We can now create instances of <code>Leaf3</code> and <code>Fruit3</code> and pass an instance of <code>Growth</code> to them:</p><pre><code class="language-julia hljs">L3 = Leaf3(10.0, 5.0, &quot;green&quot;, Growth(1.0, 0.1, 0.1))
F3 = Fruit3(1.0, &quot;red&quot;, Growth(1.0, 0.2, 0.1))</code></pre><p>Of course our types would need to be improved as their dimensions are now decoupled from the weight of the organ itself, but remember that this is just an example to illustrate features of the Julia language and in a real model we would later add changes to the types as needed (in fact, you are likely to develop models in this iterative, dynamic way, rather than figure everything out ahead of time). We can now call the <code>grow!</code> method on the <code>growth</code> field of the <code>Leaf3</code> and <code>Fruit3</code> instances to update their current weight:</p><pre><code class="language-julia hljs">grow!(L3.growth)
grow!(F3.growth)</code></pre><p>And the weight of the organs will be updated accordingly. We can access the current weight of the organs by accessing the <code>weight</code> field of the <code>growth</code> field:</p><pre><code class="language-julia hljs">L3.growth.weight
F3.growth.weight</code></pre><h2 id="Method-forwarding"><a class="docs-heading-anchor" href="#Method-forwarding">Method forwarding</a><a id="Method-forwarding-1"></a><a class="docs-heading-anchor-permalink" href="#Method-forwarding" title="Permalink"></a></h2><p>We have seen how to compose types in Julia to add functionality to them. However, this means that we need to access the methods of the composed type through the field name, which can be cumbersome. For example, we need to call <code>grow!(L3.growth)</code> to grow the leaf, which is not very intuitive. We can use <em>method forwarding</em> to make this more intuitive. Method forwarding is a technique that allows us to define methods that forward the call to the method of the composed type. For example, we can define a method for the <code>grow!</code> function that forwards the call to the <code>growth</code> field of the organ. We can define this method per organ type or, if we expect all organs to grow, we can define it for the abstract type <code>Organ</code> so that all organs will have the same behavior:</p><pre><code class="language-julia hljs">function grow!(organ::Organ)
    grow!(organ.growth)
end</code></pre><p>Now we can call <code>grow!(L3)</code> and <code>grow!(F3)</code> to grow the leaf and the fruit, respectively:</p><pre><code class="language-julia hljs">grow!(L3)
grow!(F3)</code></pre><p>Here we are using multiple dispatch and inheritance to use the <code>grow!</code> method on all organs while relying on type composition to implement the actual growth functionality. If you need to forward many methods you may want to use a macro to automate the process or use existing packages that already implement such macros (e.g., <code>MethodForwarding.jl</code> or <code>ForwardMethods.jl</code>).</p><p>At this point you may be wondering why we did not just define the <code>grow!</code> method directly in the <code>Leaf3</code> and <code>Fruit3</code> types. The reason is modularity. By separating the data structures and methods according to functionality, we can encapsulate the relevant code and make it easier to use, without necessarily having to know all the details. This approach is currently being used in the VPLverse package <code>Ecophys.jl</code>, where data structures for, for example, photosynthesis are defined with associated methods. Thus, adding the ability to photosynthesize to a plant organ is as simply as adding one of the relevant data types from <code>Ecophys.jl</code> and calling the relevant method.</p><h2 id="About-object-oriented-programming"><a class="docs-heading-anchor" href="#About-object-oriented-programming">About object-oriented programming</a><a id="About-object-oriented-programming-1"></a><a class="docs-heading-anchor-permalink" href="#About-object-oriented-programming" title="Permalink"></a></h2><p>If one searches online whether Julia implements object-oriented programming (OOP), the results will be mixed as it depends entirely on how does one define OOP. If the definition matches what is understood by OOP in languages such as C++, Java or Python (i.e. <em>classic</em> OOP), then the answer is simply no. The reason for this is that:</p><ul><li>Julia only allows inheritance from abstract types. This means that concrete types in Julia can inherit methods from their parent types but not data.</li><li>Data types in Julia encapsulate data but not methods (i.e., objects in Julia do not own methods).</li></ul><p>If one defines OOP as a paradigm that requires encapsulation of data (but not necessarily methods) and inheritance of methods (but not necessarily data) then the approach used in Julia and described above would qualify as OOP. That is, the answer to whether Julia implements OOP depends entirely on how one defines the paradigm and there is simply no right or wrong way of defining concepts.</p><p>If you are transitioning form a language with <em>classic</em> OOP  you will need to rethink how to organize your code if you want to stick to a <em>Julian</em> way of programming. Essentially you should replace inheritance of data with object composition (plus optionally method forwarding) and use multiple method dispatch for functionality (what in <em>classic</em> OOP would be <em>interfaces</em>). Searching online for <em>composition over inheritance</em> may help with the transition (e.g., https://en.wikipedia.org/wiki/Composition<em>over</em>inheritance).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Julia/">« Julia basic concepts</a><a class="docs-footer-nextpage" href="../Modules/">Modules and files »</a><div class="flexbox-break"></div></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 6 August 2025 11:43">Wednesday 6 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
