<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Julia basic concepts · Virtual Plant Laboratory</title><meta name="title" content="Julia basic concepts · Virtual Plant Laboratory"/><meta property="og:title" content="Julia basic concepts · Virtual Plant Laboratory"/><meta property="twitter:title" content="Julia basic concepts · Virtual Plant Laboratory"/><meta name="description" content="Documentation for Virtual Plant Laboratory."/><meta property="og:description" content="Documentation for Virtual Plant Laboratory."/><meta property="twitter:description" content="Documentation for Virtual Plant Laboratory."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">Virtual Plant Laboratory</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Virtual Plant Laboratory</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox" checked/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Julia basic concepts</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li class="toplevel"><a class="tocitem" href="#Running-Julia"><span>Running Julia</span></a></li><li class="toplevel"><a class="tocitem" href="#Basic-concepts"><span>Basic concepts</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Methods"><span>Methods</span></a></li><li><a class="tocitem" href="#Abstract-types"><span>Abstract types</span></a></li><li><a class="tocitem" href="#Modules"><span>Modules</span></a></li><li><a class="tocitem" href="#Adding-methods-to-existing-functions"><span>Adding methods to existing functions</span></a></li><li><a class="tocitem" href="#Macros"><span>Macros</span></a></li><li><a class="tocitem" href="#Dot-notation"><span>Dot notation</span></a></li><li class="toplevel"><a class="tocitem" href="#Improving-performance"><span>Improving performance</span></a></li><li><a class="tocitem" href="#Type-instability"><span>Type instability</span></a></li><li><a class="tocitem" href="#Performance-annotations"><span>Performance annotations</span></a></li><li><a class="tocitem" href="#Global-variables-and-type-instability"><span>Global variables and type instability</span></a></li></ul></li><li><a class="tocitem" href="../Objects/">Multiple dispatch and composition</a></li><li><a class="tocitem" href="../Modules/">Modules and files</a></li></ul></li><li><a class="tocitem" href="../../Graphs/">Dynamic graph creation and manipulation</a></li><li><a class="tocitem" href="../../Geometry/Primitives/">Geometry primitives</a></li><li><a class="tocitem" href="../../Geometry/Turtle/">Turtle geometry and scenes</a></li><li><a class="tocitem" href="../../Raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../../Visualization/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/intro_tut/">Intro</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Getting started with VPL</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/getting_started/algae/">Algae growth</a></li><li><a class="tocitem" href="../../../tutorials/getting_started/snowflakes/">The Koch snowflake</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">From tree to forest</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/from_tree_forest/tree/">Tree</a></li><li><a class="tocitem" href="../../../tutorials/from_tree_forest/forest/">Forest</a></li><li><a class="tocitem" href="../../../tutorials/from_tree_forest/growthforest/">Growth forest</a></li><li><a class="tocitem" href="../../../tutorials/from_tree_forest/raytracedforest/">Ray-traced forest</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">More on rules and queries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/more_rules_queries/context/">Context sensitive rules</a></li><li><a class="tocitem" href="../../../tutorials/more_rules_queries/relationalqueries/">Relational queries</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../howto/GridCloner/">Setting up a grid cloner</a></li><li><a class="tocitem" href="../../../howto/Message/">Messages in scenes</a></li><li><a class="tocitem" href="../../../howto/Materials/">Multiple materials/colors</a></li><li><a class="tocitem" href="../../../howto/Traversal/">Advanced traversal</a></li><li><a class="tocitem" href="../../../howto/Coordinates/">Absolute coordinates</a></li><li><a class="tocitem" href="../../../howto/LightSources/">Creating light sources</a></li><li><a class="tocitem" href="../../../howto/Slicer/">Using the slicer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../api/graphs/">Graphs</a></li><li><a class="tocitem" href="../../../api/geometry/">Scenes and 3D meshes</a></li><li><a class="tocitem" href="../../../api/turtle/">Turtle geometry</a></li><li><a class="tocitem" href="../../../api/raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../../../api/viz/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">VPLVerse</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">SkyDomes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../VPLVerse/SkyDomes/">SkyDomes package</a></li><li><a class="tocitem" href="../../../VPLVerse/SkyDomes/API/">SkyDomes API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Ecophys</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../VPLVerse/Ecophys/">Ecophys package</a></li><li><a class="tocitem" href="../../../VPLVerse/Ecophys/photosynthesis/">Photosynthesis API</a></li><li><a class="tocitem" href="../../../VPLVerse/Ecophys/growth/">Growth API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">PlantSimEngine</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../VPLVerse/PlantSimEngine/">PlantSimEngine package</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">PlantBioPhysics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../VPLVerse/PlantBioPhysics/">PlantBioPhysics package</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../developers/organization/">Internal organization</a></li><li><a class="tocitem" href="../../../developers/use&amp;dev_packages/">Package and Environment Management for VPL</a></li><li><a class="tocitem" href="../../../developers/style/">Styling protocol</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">Julia</a></li><li class="is-active"><a href>Julia basic concepts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Julia basic concepts</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/VPLDocs/blob/master/docs/src/manual/Julia/Julia.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="manual_julia"><a class="docs-heading-anchor" href="#manual_julia">Julia basic concepts</a><a id="manual_julia-1"></a><a class="docs-heading-anchor-permalink" href="#manual_julia" title="Permalink"></a></h1><p>Alejandro Morales</p><p>Centre for Crop Systems Analysis - Wageningen University</p><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>This is not a tutorial or introduction to Julia, but a collection of basic concepts about Julia that are particularly useful to understand VPL.  It is assumed that the reader has some experience with programming in other languages, such as Matlab, R or Python. These concepts should be complemented with general introductory material about Julia, which can be found at the official <a href="https://julialang.org/">Julia website</a>.</p><p>Julia is a dynamic, interactive programming language, like Matlab, R or Python. Thus, it is very easy to use and learn incrementally. The language is young and well-designed, with an emphasis on numerical/scientific computation, although it is starting to occupy some space in areas such as data science and machine learning. It has a clear syntax and better consistency than some older programming languages.</p><p>Unlike Matlab, R or Python, Julia was designed from the beginning to be fast (as fast as statically compiled languages like C, C++ or Fortran). However, achieving this goal does require paying attention to certain aspects of the language, such as <em>type stability</em> and <em>dynamic memory allocation</em>, which are not always obvious to the user coming from other scientific dynamic languages. In the different sections below, a few basic Julia concepts are presented, first by ignoring performance considerations and focusing on syntax, and then by showing how to improve the performance of the code. Some concepts are ignored as they are not deemed relevant for the use of VPL.</p><h1 id="Running-Julia"><a class="docs-heading-anchor" href="#Running-Julia">Running Julia</a><a id="Running-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Running-Julia" title="Permalink"></a></h1><p>There are different ways of executing Julia code (most popular ones are VS Code and Jupyter notebook):</p><ul><li>Interactive Julia console from terminal/console (REPL)</li><li>Plugins for code editors<ul><li>Visual Studio Code (most popular)</li><li>Atom/Juno (less popular now)</li><li>vim, Emacs and others (less popular)</li></ul></li><li>Code cells inside a Jupyter notebook</li><li>Code cells inside Pluto notebook (a Julia implementation of a reactive notebook)</li></ul><p>The first time in a Julia session that a method is called, it will take extra time as the method will have to be compiled (i.e. Julia uses a Just-in-Time compiler as opposed to an interpreter). Also, the first time you load a package after installation/update it will take extra time to load due to precompilation (this reduces JIT compilation times somewhat). Moreover, code editors and notebooks may need to run additional code to achieve their full functionality, which may add some delays in executing the code.</p><h1 id="Basic-concepts"><a class="docs-heading-anchor" href="#Basic-concepts">Basic concepts</a><a id="Basic-concepts-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-concepts" title="Permalink"></a></h1><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><p>A function is defined with the following syntax.</p><pre><code class="language-julia hljs">function foo(x)
    x^2
end
foo(2.0)</code></pre><p>Very short functions can also be defined in one line</p><pre><code class="language-julia hljs">foo2(x) = x^2</code></pre><pre><code class="language-julia hljs">foo2(2.0)</code></pre><p>Functions can also be defined with the &quot;<span>$\to$</span>&quot; syntax. The result can be assigned to any variable.</p><pre><code class="language-julia hljs">foo3 = x -&gt; x^2</code></pre><pre><code class="language-julia hljs">foo3(2.0)</code></pre><p>A <code>begin</code> - <code>end</code> block can be used to store a sequence of statements in multiple lines and assign them to &quot;short function or a &quot;<span>$\to$</span> function.</p><pre><code class="language-julia hljs">foo4 = begin
    x -&gt; x^2
end</code></pre><pre><code class="language-julia hljs">foo4(2.0)</code></pre><p>Once created, there is no difference among <code>foo</code>, <code>foo2</code>, <code>foo3</code> and <code>foo4</code>.</p><p>Anonymous functions are useful when passing a function to another function as argument. For example, the function <code>bar</code> below allows applying any function <code>f</code> to an argument <code>x</code>. In this case we could pass any of the variables defined above, or just create an anonymous function in-place.</p><pre><code class="language-julia hljs">function bar(x, f)
    f(x)
end
bar(2.0, x -&gt; x^2)</code></pre><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><p>A Type in Julia is a data structure that can contain one or more fields. Types are used to keep related data together, and to select the right method implementation of a function (see below). It shares some properties of Classes in Object-Oriented Programming, but there are also important differences.</p><p>Julia types can be immutable or mutable.</p><p>Immutable means that, once created, the fields of an object cannot be changed. They are defined with the following syntax:</p><pre><code class="language-julia hljs">struct Point
  x
  y
  z
end</code></pre><pre><code class="language-julia hljs">p = Point(0.0, 0.0, 0.0)</code></pre><pre><code class="language-julia hljs">p.x = 1.0</code></pre><p>Mutable means that the fields of an object can be modified after creation. The definition is similar, just needs to add the keyword <code>mutable</code></p><pre><code class="language-julia hljs">mutable struct mPoint
  x
  y
  z
end</code></pre><pre><code class="language-julia hljs">mp = mPoint(0.0, 0.0, 0.0)</code></pre><pre><code class="language-julia hljs">mp.x = 1.0
mp</code></pre><p>We can always check the type of object with the function <code>typeof</code></p><pre><code class="language-julia hljs">typeof(p)</code></pre><p>If you forget the fields of a type, try to use <code>fieldnames</code> in the type (not the object). It will return the name of all the fields it contains (the &quot;:&quot; in front of each name can be ignored)</p><pre><code class="language-julia hljs">fieldnames(Point)</code></pre><p>Note that, for performance reasons, the type of each field should be annotated in the type definition as in:</p><pre><code class="language-julia hljs">struct pPoint
  x::Float64
  y::Float64
  z::Float64
end
pPoint(1.0, 2.0, 3.0)</code></pre><p>Also, note that there are no private fields in a Julia type (like Python, unlike C++ or Java).</p><h2 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h2><p>Methods are functions with the same name but specialized for different types.</p><p>Methods are automatically created by specifying the type of (some of) the arguments of a function, like in the following example</p><pre><code class="language-julia hljs">function dist(p1::pPoint, p2::pPoint)
    dx = p1.x - p2.x
    dy = p1.y - p2.y
    dz = p1.z - p2.z
    sqrt(dx^2 + dy^2 + dz^2)
end</code></pre><pre><code class="language-julia hljs">p1 = pPoint(1.0, 0.0, 0.0)
p2 = pPoint(0.0, 1.0, 0.0)
dist(p1, p2)</code></pre><p>Note that this function will not work for <code>mPoint</code>s</p><pre><code class="language-julia hljs">mp1 = mPoint(1.0, 0.0, 0.0)
mp2 = mPoint(0.0, 1.0, 0.0)
dist(mp1, mp2)</code></pre><p>So we need to define <code>dist</code> for <code>mPoint</code> as arguments, or use inheritance (see below).</p><h2 id="Abstract-types"><a class="docs-heading-anchor" href="#Abstract-types">Abstract types</a><a id="Abstract-types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-types" title="Permalink"></a></h2><p>Types cannot inherit from other types.</p><p>However, when multiple types share analogous functionality, it is possible to group them by &quot;abstract types&quot; from which they can inherit. Note that abstract types do not contain any fields, so inheritance only works for methods. &quot;abstract types are defined by how they act&quot; (C. Rackauckas)</p><p>For example, we may define an abstract type <code>Vec3</code> as any type for which a distance (<code>dist</code>) can be calculated. The default implementation assumes that the type contains fields <code>x</code>, <code>y</code> and <code>z</code>, though inherited methods can always be overridden.</p><p>Inheritance is indicated by the &quot;&lt;:&quot; syntax after the name of the type in its declaration.</p><pre><code class="language-julia hljs"># Vec3 contains no data, but dist actually assumes that x, y and z are fields of any type inheriting from Vec3
abstract type Vec3 end
function dist(p1::Vec3, p2::Vec3)
    dx = p1.x - p2.x
    dy = p1.y - p2.y
    dz = p1.z - p2.z
    sqrt(dx^2 + dy^2 + dz^2)
end
# Like before, but inhering from Vec3
struct Point2 &lt;: Vec3
  x::Float64
  y::Float64
  z::Float64
end
mutable struct mPoint2 &lt;: Vec3
  x::Float64
  y::Float64
  z::Float64
end
struct Point3 &lt;: Vec3
  x::Float64
  y::Float64
end</code></pre><p>The method now works with <code>Point2</code> and <code>mPoint2</code></p><pre><code class="language-julia hljs">p1 = Point2(1.0, 0.0, 0.0)
p2 = Point2(0.0, 1.0, 0.0)
dist(p1, p2)
mp1 = mPoint2(1.0, 0.0, 0.0)
mp2 = mPoint2(0.0, 1.0, 0.0)
dist(mp1, mp2)</code></pre><p>The method will try to run with <code>Point3</code> but it will raise an error because <code>Point3</code> does not have the field <code>z</code>.</p><pre><code class="language-julia hljs">p3 = Point3(1.0, 0.0)
dist(p1, p3)</code></pre><h3 id="Optional-and-keyword-arguments"><a class="docs-heading-anchor" href="#Optional-and-keyword-arguments">Optional and keyword arguments</a><a id="Optional-and-keyword-arguments-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-and-keyword-arguments" title="Permalink"></a></h3><p>Functions can have optional arguments (i.e. arguments with default values) as well as keyword arguments, which are like optional arguments but you need to use their name (rather than position) to assign a value.</p><p>An example of a function with optional arguments:</p><pre><code class="language-julia hljs">opfoo(a, b::Int = 0) = a + b
opfoo(1)</code></pre><pre><code class="language-julia hljs">opfoo(1,1)</code></pre><p>An example of a function with keyword arguments</p><pre><code class="language-julia hljs">kwfoo(a; b::Int = 0) = a + b
kwfoo(1)</code></pre><pre><code class="language-julia hljs">kwfoo(1, b = 1)</code></pre><h2 id="Modules"><a class="docs-heading-anchor" href="#Modules">Modules</a><a id="Modules-1"></a><a class="docs-heading-anchor-permalink" href="#Modules" title="Permalink"></a></h2><p>Within a Julia session you cannot redefine Types. Also, if you assign different data to the same name, it will simply overwrite the previous data (note: these statements are simplifications of what it actually happens, but it suffices for now).</p><p>To avoid name clashes, Julia allows collecting functions, methods, types and abstract types into Modules. Every Julia package includes at least one module.</p><p>A module allows exporting a subset of the the names defined inside of it:</p><pre><code class="language-julia hljs">module Mod

export fooz

fooz(x) = abs(x)

struct bar
   data
end

end</code></pre><p>In order to use a module the <code>using</code> command must be used (the <code>.</code> is required and indicates that the module was defined in the current scoppe, as modules can be nested).</p><pre><code class="language-julia hljs">using .Mod</code></pre><p>Exportednames can be used directly</p><pre><code class="language-julia hljs">fooz(-1)</code></pre><p>Unexported names can still be retrieved, but must be qualified by the module name.</p><pre><code class="language-julia hljs">b = Mod.fooz(-1.0)</code></pre><h2 id="Adding-methods-to-existing-functions"><a class="docs-heading-anchor" href="#Adding-methods-to-existing-functions">Adding methods to existing functions</a><a id="Adding-methods-to-existing-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-methods-to-existing-functions" title="Permalink"></a></h2><p>If a function is defined inside a module (e.g., a Julia package) we can add methods to that function by accessing it through the module name. Let&#39;s define a function <code>abs_dist</code> that calculates the Manhattan (as opposed to Euclidean) distance between two points. We will put it inside a module called <code>Funs</code> to emulate a Julia package.</p><pre><code class="language-julia hljs">module Funs
  export manhattan
  function manhattan(p1, p2)
      dx = p1.x - p2.x
      dy = p1.y - p2.y
      dz = p1.z - p2.z
      abs(dx + dy + dz)
  end
end
using .Funs
manhattan(p1, p2)
manhattan(p1, p3)</code></pre><p>We see that we have the same error as before when using <code>p3</code>. Let&#39;s add methods for when one the first or second argument is a <code>Point3</code> that ignores the <code>z</code>:</p><pre><code class="language-julia hljs">Funs.manhattan(p1::Point3, p2) = abs(p1.x - p2.x + p1.y - p2.y)
Funs.manhattan(p1, p2::Point3) = abs(p1.x - p2.x + p1.y - p2.y)
manhattan(p1, p3)
manhattan(p3, p1)</code></pre><p>You can find all the methods of a function by using <code>methods()</code> on the function name:</p><pre><code class="language-julia hljs">methods(manhattan)</code></pre><h2 id="Macros"><a class="docs-heading-anchor" href="#Macros">Macros</a><a id="Macros-1"></a><a class="docs-heading-anchor-permalink" href="#Macros" title="Permalink"></a></h2><p>A macro is a function or statement that starts with <code>@</code>. The details of macros are not explained here, but it is important to know that they work by <strong>modifying the code</strong> that you write inside the macro, usually to provided specific features or to achieve higher performance. That is, a macro will take the code that you write and substitute it by some new code that then gets executed.</p><p>An useful macro is <code>@kwdef</code> provided by the module <code>Base</code>, which allows assigning default values to the fields of a type and use the fields as keyword arguments in the constructors. This macro needs to be written before the type definition. For example, a point constructed in this manner would be:</p><pre><code class="language-julia hljs">Base.@kwdef struct kwPoint
    x::Float64 = 0.0
    y::Float64 = 0.0
    z::Float64 = 0.0
end
kwPoint()
kwPoint(1,1,1)
kwPoint(y = 1)</code></pre><h2 id="Dot-notation"><a class="docs-heading-anchor" href="#Dot-notation">Dot notation</a><a id="Dot-notation-1"></a><a class="docs-heading-anchor-permalink" href="#Dot-notation" title="Permalink"></a></h2><p>Dot notation is a very useful feature of Julia that allows you to apply a function to each element of a vector. For example, if you want to calculate the square of each element of a vector you can do:</p><pre><code class="language-julia hljs">x = [1,2,3]
y = x.^2</code></pre><p>The dot notation can be used with any function, not just mathematical functions. For example, if you want to calculate the absolute value of each element of a vector you can do:</p><pre><code class="language-julia hljs">abs.(y)</code></pre><p>If the operation is more complex, the &#39;.&#39; should be used in all the steps or, alternatively, use the macro <code>@.</code> that does the same:</p><pre><code class="language-julia hljs">abs.(y) .+ x.^3
@. abs(y) + x^3</code></pre><p>The dot notation can also be used with functions that take more than one argument, but make sure that all the arguments have the same length</p><pre><code class="language-julia hljs">min.(x, y)
max.(x, y)</code></pre><h1 id="Improving-performance"><a class="docs-heading-anchor" href="#Improving-performance">Improving performance</a><a id="Improving-performance-1"></a><a class="docs-heading-anchor-permalink" href="#Improving-performance" title="Permalink"></a></h1><h2 id="Type-instability"><a class="docs-heading-anchor" href="#Type-instability">Type instability</a><a id="Type-instability-1"></a><a class="docs-heading-anchor-permalink" href="#Type-instability" title="Permalink"></a></h2><p>As indicated above, annotating the fields of a data type (<code>struct</code> or <code>mutable struct</code>) is required for achieve good performance. However, neither arguments of functions nor variables created through assignment require type annotation. This is because Julia uses type inference (i.e. it tries to infer the type of data to be stored in each newly created varaible) and compiles the code to machine level based on this inference. This leads to the concept of <em>type instability</em>: if the type of data stored in a variable changes over time, the compiler will need to accomodate for this, which results (for technical reasons beyond the scope of this document) in a loss of performance.</p><p>Here is a classic example of type instability. The following function will add up the squares of all the values in a vector:</p><pre><code class="language-julia hljs">function add_squares(x)
  out = 0
  for i in eachindex(x)
    out += x[i]^2
  end
  return out
end</code></pre><p>It looks innocent enough. The issue here is that <code>out</code> is initialized as an integer (<code>0</code>), but then it is assigned the result of <code>sqrt(x)</code>, which may be a real value (e.g. <code>1.0</code>), which would have to be stored as a floating point number. Because <code>out</code> has different types at different points in the code, the resulting code will be slower than it could be, but still correct (this is why Julia is useful for rapid code development compared to static languages like C++ or Java).</p><pre><code class="language-julia hljs">add_squares(collect(1:1000)) # type stable
add_squares(collect(1:1000.0)) # not type stable</code></pre><p>How do we measure performance then? The <code>@time</code> macro is useful for this if dealing with a slow function. Otherwise it is better to use <code>@btime</code> from the <em>BenchmarkTools</em> package (see documentation of the package to understand why we use <code>$</code>).</p><pre><code class="language-julia hljs">using BenchmarkTools
v1 = collect(1:1000)
v2 = collect(1:1000.0)
@btime add_squares($v1)
@btime add_squares($v2)</code></pre><p>The second code is 12 times slower than the first one. We can detect type instability by using the <code>@code_warntype</code> macro. This macro will print a internal representation of the code before it is compiled. The details are complex, but you just need to look for things in red (which indicate type instability).</p><pre><code class="language-julia hljs">@code_warntype add_squares(v1)
@code_warntype add_squares(v2)</code></pre><p>How do we fix this? We could write different methods for different types of x, but this is not very practical. Instead, we can use the <code>zero()</code> function combined with <code>eltype()</code> to initialize <code>out</code> with the correct type.</p><pre><code class="language-julia hljs">function add_squares(x)
  out = zero(eltype(x)) # Initialize out with the correct type with value of zero
  for i in eachindex(x)
    out += x[i]^2
  end
  return out
end</code></pre><p>You could also initialize out to the first element of x and iterate over the rest of the elements, but this may not always possible (e.g. if <code>x</code> is empty or has one value only), so the logic will get more complex.</p><p>Now the code is type stable:</p><pre><code class="language-julia hljs">@code_warntype add_squares(v1)
@code_warntype add_squares(v2)</code></pre><p>And the performance is more similar:</p><pre><code class="language-julia hljs">@btime add_squares($v1)
@btime add_squares($v2)</code></pre><h2 id="Performance-annotations"><a class="docs-heading-anchor" href="#Performance-annotations">Performance annotations</a><a id="Performance-annotations-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-annotations" title="Permalink"></a></h2><p>Sometimes code can be annotated to improve performance. For example, the <code>@simd</code> can be used in simple loops to indicate that the loop can be vectorized inside the CPU (it allows to run simple CPU instructions on small sets of data simultaneously). The <code>@inbounds</code> macro can be used to indicate that the code will not access elements outside the bounds of an array.</p><pre><code class="language-julia hljs">function add_squares(x)
  out = zero(eltype(x)) # Initialize out with the correct type with value of zero
  @simd for i in eachindex(x)
    @inbounds out += x[i]^2
  end
  return out
end
@btime add_squares($v1)
@btime add_squares($v2)</code></pre><p>Now we actually get faster performance for floating point number, which is related to the fact that the CPU can vectorize floating point operations more efficiently than integer operations (at least in this example). You can see the actual assembly code being generated (or an approximation of it) by using the <code>@code_native</code> macro. Any instruction that starts with <code>v</code> is a vectorized instruction. Note that sometimes Julia will automatically vectorize code without the need for the <code>@simd</code> but this is not always the case.</p><pre><code class="language-julia hljs">@code_native add_squares(v2)</code></pre><p>Notice how with some simple annotations and reorganizing the code to deal with type instability we were able to get a 30x speedup. Obviously this was a simple function with minimal runtime, so the speedup is not particularly useful, but this type of small functions are often the ones that are called many times in complex computations (e.g., ray tracing), so the speedup can be significant in actual applications. Whether you need to worry about performance depends on where the bottleneck is in your code.</p><p>For more details, see the sections of the manual on <a href="https://docs.julialang.org/en/v1/manual/profile/">profiling</a> and <a href="https://docs.julialang.org/en/v1/manual/performance-tips/">performance tips</a>.</p><h2 id="Global-variables-and-type-instability"><a class="docs-heading-anchor" href="#Global-variables-and-type-instability">Global variables and type instability</a><a id="Global-variables-and-type-instability-1"></a><a class="docs-heading-anchor-permalink" href="#Global-variables-and-type-instability" title="Permalink"></a></h2><p>Global variables are any variable defined in a module outside of a function that is accessed from within a function. Global variables are not recommended in general as they can easily introduce bugs in your code by making the logic of the program much harder to reason about. However, they can also introduce performance issues as any global variable that is not annotated with its type will lead to type instability.</p><p>For example, let&#39;s say we modify the <code>add_squares</code> function to use a global variable (a bit odd, but it is just to illustrate the point) to enable differen options in the code.</p><pre><code class="language-julia hljs">function add_squares(x)
  out = zero(eltype(x))
  if criterion &gt; 0
    @simd for i in eachindex(x)
      @inbounds out += x[i]^2
    end
  else
    @simd for i in eachindex(x)
      @inbounds out -= x[i]^2
    end
  end
  return out
end
criterion = 1
@code_warntype add_squares(v2)
@btime add_squares(v2)</code></pre><p>It is not a major hit in performance as <code>criterion</code> is only accessed once, but this can be a problem if the global variable is accessed many times in the code. The short term solution is to annotate the type of the global variable (but really we should be writing code without global variables). This can be frustating as once a global variable is created, you cannot annotate its type (even if it does not change!) without restarting the Julia session (unless it is inside a module).</p><pre><code class="language-julia hljs">function add_squares(x)
  out = zero(eltype(x))
  if criterion2 &gt; 0
    @simd for i in eachindex(x)
      @inbounds out += x[i]^2
    end
  else
    @simd for i in eachindex(x)
      @inbounds out -= x[i]^2
    end
  end
  return out
end
criterion2::Int64 = 1
@code_warntype add_squares(v2)
@btime add_squares(v2)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../">« Virtual Plant Laboratory</a><a class="docs-footer-nextpage" href="../Objects/">Multiple dispatch and composition »</a><div class="flexbox-break"></div></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 6 August 2025 11:43">Wednesday 6 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
