<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Graphs · Virtual Plant Laboratory</title><meta name="title" content="Graphs · Virtual Plant Laboratory"/><meta property="og:title" content="Graphs · Virtual Plant Laboratory"/><meta property="twitter:title" content="Graphs · Virtual Plant Laboratory"/><meta name="description" content="Documentation for Virtual Plant Laboratory."/><meta property="og:description" content="Documentation for Virtual Plant Laboratory."/><meta property="twitter:description" content="Documentation for Virtual Plant Laboratory."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Virtual Plant Laboratory</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Virtual Plant Laboratory</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Julia</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/Julia/Julia/">Julia basic concepts</a></li><li><a class="tocitem" href="../../manual/Julia/Objects/">Multiple dispatch and composition</a></li><li><a class="tocitem" href="../../manual/Julia/Modules/">Modules and files</a></li></ul></li><li><a class="tocitem" href="../../manual/Graphs/">Dynamic graph creation and manipulation</a></li><li><a class="tocitem" href="../../manual/Geometry/Primitives/">Geometry primitives</a></li><li><a class="tocitem" href="../../manual/Geometry/Turtle/">Turtle geometry and scenes</a></li><li><a class="tocitem" href="../../manual/Raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../../manual/Visualization/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/intro_tut/">Intro</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Getting started with VPL</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/getting_started/algae/">Algae growth</a></li><li><a class="tocitem" href="../../tutorials/getting_started/snowflakes/">The Koch snowflake</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">From tree to forest</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/from_tree_forest/tree/">Tree</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/forest/">Forest</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/growthforest/">Growth forest</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/raytracedforest/">Ray-traced forest</a></li><li><a class="tocitem" href="../../tutorials/from_tree_forest/photosynthesis/">Canopy photosynthesis</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">More on rules and queries</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/more_rules_queries/context/">Context sensitive rules</a></li><li><a class="tocitem" href="../../tutorials/more_rules_queries/relationalqueries/">Relational queries</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/GridCloner/">Setting up a grid cloner</a></li><li><a class="tocitem" href="../../howto/Message/">Messages in scenes</a></li><li><a class="tocitem" href="../../howto/Materials/">Multiple materials/colors</a></li><li><a class="tocitem" href="../../howto/Traversal/">Advanced traversal</a></li><li><a class="tocitem" href="../../howto/Coordinates/">Absolute coordinates</a></li><li><a class="tocitem" href="../../howto/LightSources/">Creating light sources</a></li><li><a class="tocitem" href="../../howto/Slicer/">Using the slicer</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">API</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Graphs</a><ul class="internal"><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Private"><span>Private</span></a></li></ul></li><li><a class="tocitem" href="../geometry/">Scenes and 3D meshes</a></li><li><a class="tocitem" href="../turtle/">Turtle geometry</a></li><li><a class="tocitem" href="../raytracer/">Ray tracing</a></li><li><a class="tocitem" href="../viz/">3D visualization</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">VPLVerse</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-6-1" type="checkbox"/><label class="tocitem" for="menuitem-6-1"><span class="docs-label">SkyDomes</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/SkyDomes/">SkyDomes package</a></li><li><a class="tocitem" href="../../VPLVerse/SkyDomes/API/">SkyDomes API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-2" type="checkbox"/><label class="tocitem" for="menuitem-6-2"><span class="docs-label">Ecophys</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/Ecophys/">Ecophys package</a></li><li><a class="tocitem" href="../../VPLVerse/Ecophys/photosynthesis/">Photosynthesis API</a></li><li><a class="tocitem" href="../../VPLVerse/Ecophys/growth/">Growth API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-3" type="checkbox"/><label class="tocitem" for="menuitem-6-3"><span class="docs-label">PlantSimEngine</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/PlantSimEngine/">PlantSimEngine package</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6-4" type="checkbox"/><label class="tocitem" for="menuitem-6-4"><span class="docs-label">PlantBioPhysics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../VPLVerse/PlantBioPhysics/">PlantBioPhysics package</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../developers/organization/">Internal organization</a></li><li><a class="tocitem" href="../../developers/use&amp;dev_packages/">Package and Environment Management for VPL</a></li><li><a class="tocitem" href="../../developers/style/">Styling protocol</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>Graphs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Graphs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/VPLDocs/blob/master/docs/src/api/graphs.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Graphs"><a class="docs-heading-anchor" href="#Graphs">Graphs</a><a id="Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs" title="Permalink"></a></h1><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><p>Includes functions defined by PlantGraphs as well as methods for functions defined by other packages.</p><article><details class="docstring" open="true"><summary id="PlantGraphs.Context"><a class="docstring-binding" href="#PlantGraphs.Context"><code>PlantGraphs.Context</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Context</code></pre><p>Data structure than links a node to the rest of the graph.</p><p><strong>Fields</strong></p><ul><li><code>graph</code>: Dynamic graph that contains the node.</li><li><code>node</code>: Node inside the graph.</li></ul><p><strong>Details</strong></p><p>A <code>Context</code> object wraps references to a node and its associated graph. The purpose of this structure is to be able to test relationships among nodes within a graph (from with a query or rule), as well as access the data stored in a node (with <code>data()</code>) or the graph (with <code>graph_data()</code>).</p><p>Users do not build <code>Context</code> objects directly but they are provided by VPL as inputs to the user-defined functions inside rules and queries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Types.jl#L112-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.Graph-Tuple{}"><a class="docstring-binding" href="#PlantGraphs.Graph-Tuple{}"><code>PlantGraphs.Graph</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Graph(;axiom, rules = nothing, data = nothing)</code></pre><p>Create a dynamic graph from an axiom, one or more rules and, optionally, graph-level variables.</p><p><strong>Arguments</strong></p><ul><li><code>axiom</code>: A single object inheriting from <code>Node</code> or a subgraph generated  with the graph construction DSL. It should represent the initial state of the dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>rules</code>:  A single <code>Rule</code> object or a tuple of <code>Rule</code> objects (optional). It should include all graph-rewriting rules of the graph.</li><li><code>data</code>: A single object of any user-defined type (optional). This will be the graph-level variable accessible from any rule or query applied to the graph.</li><li><code>FT</code>: Floating-point precision to be used when generating the 3D geometry associated to a graph.</li></ul><p><strong>Details</strong></p><p>All arguments are assigned by keyword. The axiom and rules are deep-copied when creating the graph but the graph-level variables (if a copy is needed due to mutability, the user needs to care of that).</p><p><strong>Returns</strong></p><p>An object of type <code>Graph</code> representing a dynamic graph. Printing this object results in a human-readable description of the type of data stored in the graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A0 &lt;: Node end;

julia&gt; struct B0 &lt;: Node end;

julia&gt; axiom = A0() + B0();

julia&gt; no_rules_graph = Graph(axiom = axiom);

julia&gt; rule = Rule(A0, rhs = x -&gt; A0() + B0());

julia&gt; rules_graph = Graph(axiom = axiom, rules = rule);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Graph.jl#L7-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.Node"><a class="docstring-binding" href="#PlantGraphs.Node"><code>PlantGraphs.Node</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Node</code></pre><p>Abstract type from which every node in a graph should inherit. This allows using the graph construction DSL.</p><p>This type is mutable.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct bar &lt;: Node
           x::Int
       end;

julia&gt; b1 = bar(1);

julia&gt; b2 = bar(2);

julia&gt; b1 + b2;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Types.jl#L3-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.Query-Tuple{DataType}"><a class="docstring-binding" href="#PlantGraphs.Query-Tuple{DataType}"><code>PlantGraphs.Query</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Query(N::DataType; condition = x -&gt; true)</code></pre><p>Create a query that matches nodes of type <code>nodetype</code> and a <code>condition</code>.</p><p><strong>Arguments</strong></p><ul><li><code>N::DataType</code>: Type of node to be matched.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: Function or function-like object that checks if a node should be selected.</li></ul><p><strong>Details</strong></p><p>If the <code>nodetype</code> should refer to a concrete type and match one of the types stored inside the graph. Abstract types or types that are not contained in the graph are allowed but the query will never return anything.</p><p>The <code>condition</code> must be a function or function-like object that takes a <code>Context</code> as input and returns <code>true</code> or <code>false</code>. The default <code>condition</code> always return <code>true</code> such that the query will</p><p><strong>Returns</strong></p><p>It returns an object of type <code>Query</code>. Use <code>apply()</code> to execute the query on a dynamic graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; struct B &lt;: Node end;

julia&gt; axiom = A() + B();

julia&gt; g = Graph(axiom = axiom);

julia&gt; query = Query(A);

julia&gt; apply(g, query);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Query.jl#L7-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.Rule-Tuple{DataType}"><a class="docstring-binding" href="#PlantGraphs.Rule-Tuple{DataType}"><code>PlantGraphs.Rule</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Rule(nodetype; lhs = x -&gt; true, rhs = x -&gt; nothing, captures = false)</code></pre><p>Create a replacement rule for nodes of type <code>nodetype</code>.</p><p><strong>Arguments</strong></p><ul><li><code>nodetype</code>: Type of node to be matched.</li></ul><p><strong>Keywords</strong></p><ul><li><code>lhs</code>: Function or function-like object that takes a <code>Context</code> object and returns whether the node should be replaced or not (with <code>true</code> or <code>false</code>).</li><li><code>rhs</code>: Function or function-like object that takes one or more <code>Context</code> objects and returns a replacement graph or <code>nothing</code>. If it takes several inputs, the first one will correspond to the node being replaced.</li><li><code>captures</code>: Either <code>false</code> or <code>true</code> to indicate whether the left-hand side of the rule is capturing nodes in the context of the replacement node to be used for the construction of the replace graph.</li></ul><p><strong>Details</strong></p><p>See VPL documentation for details on rule-based graph rewriting.</p><p><strong>Return</strong></p><p>An object of type <code>Rule</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; struct B &lt;: Node end;

julia&gt; axiom = A() + B();

julia&gt; rule = Rule(A, rhs = x -&gt; A() + B());

julia&gt; rules_graph = Graph(axiom = axiom, rules = rule);

julia&gt; rewrite!(rules_graph);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Rule.jl#L7-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractTrees.children-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#AbstractTrees.children-Tuple{PlantGraphs.Context}"><code>AbstractTrees.children</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">children(c::Context)</code></pre><p>Returns all the children of a node as <code>Context</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L347-L351">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractTrees.children-Tuple{PlantGraphs.GraphNode, PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#AbstractTrees.children-Tuple{PlantGraphs.GraphNode, PlantGraphs.StaticGraph}"><code>AbstractTrees.children</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">children(n::GraphNode, g::StaticGraph)</code></pre><p>Return an iterator over the children nodes of a given graph node in a static graph.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node for which to retrieve the children.</li><li><code>g::StaticGraph</code>: The static graph containing the node.</li></ul><p><strong>Returns</strong></p><p>An iterator over the <code>GraphNode</code> objects that are children of <code>n</code> in the static graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L405-L419">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.ancestor"><a class="docstring-binding" href="#PlantGraphs.ancestor"><code>PlantGraphs.ancestor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ancestor(node::GraphNode, g::Graph, condition, maxlevel::Int; level::Int=1)</code></pre><p>Retrieve the ancestor of a graph node that satisfies a given condition, with optional     recursive search up to a maximum depth.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>node::GraphNode</code>: The node from which to start the ancestor search.</li><li><code>g::Graph</code>: The graph containing the node.</li><li><code>condition</code>: A function that takes a <code>Context</code> and returns <code>true</code> if the ancestor matches the condition.</li><li><code>maxlevel::Int</code>: The maximum depth to search for ancestors.</li><li><code>level::Int=1</code>: (Optional) The current recursion level (default is 1).</li></ul><p><strong>Returns</strong></p><p>The ancestor node that matches the condition, or <code>missing</code> if none is found or the node is a root node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L369-L387">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.ancestor-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#PlantGraphs.ancestor-Tuple{PlantGraphs.Context}"><code>PlantGraphs.ancestor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ancestor(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Returns the first ancestor of a node that matches the <code>condition</code>. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input and returns <code>true</code> or <code>false</code>.</li><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when traversing the graph.</li></ul><p><strong>Details</strong></p><p>If <code>has_ancestor()</code> returns <code>false</code> for the same node and <code>condition</code>, <code>ancestor()</code> will return <code>missing</code>, otherwise it returns the <code>Context</code> associated to the matching node</p><p><strong>Returns</strong></p><p>Return a <code>Context</code> object or <code>missing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; function qfun(n)
           na = ancestor(n, condition = x -&gt; (data(x).val == 1))
           if !ismissing(na)
               data(na) isa B1
           else
               false
           end
       end;

julia&gt; Q1 = Query(A1, condition = qfun);

julia&gt; R1 = apply(g, Q1);

julia&gt; Q2 = Query(B1, condition = qfun);

julia&gt; R2 = apply(g, Q2);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L291-L339">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.apply!-Union{Tuple{N}, Tuple{Q}, Tuple{Any, PlantGraphs.Graph, PlantGraphs.Query{N, Q}}} where {Q, N}"><a class="docstring-binding" href="#PlantGraphs.apply!-Union{Tuple{N}, Tuple{Q}, Tuple{Any, PlantGraphs.Graph, PlantGraphs.Query{N, Q}}} where {Q, N}"><code>PlantGraphs.apply!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply!(output, g::Graph, query::Query)</code></pre><p>Fill an array <code>output</code> with all the nodes in the graph that match the query supplied by the user.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; struct B &lt;: Node end;

julia&gt; axiom = A() + B();

julia&gt; g = Graph(axiom = axiom);

julia&gt; output = A[];

julia&gt; query = Query(A);

julia&gt; apply!(output, g, query);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Query.jl#L101-L123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.apply-Union{Tuple{N}, Tuple{Q}, Tuple{PlantGraphs.Graph, PlantGraphs.Query{N, Q}}} where {Q, N}"><a class="docstring-binding" href="#PlantGraphs.apply-Union{Tuple{N}, Tuple{Q}, Tuple{PlantGraphs.Graph, PlantGraphs.Query{N, Q}}} where {Q, N}"><code>PlantGraphs.apply</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">apply(g::Graph, query::Query)</code></pre><p>Return an array with all the nodes in the graph that match the query supplied by the user.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; struct B &lt;: Node end;

julia&gt; axiom = A() + B();

julia&gt; g = Graph(axiom = axiom);

julia&gt; query = Query(A);

julia&gt; apply(g, query);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Query.jl#L67-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.calculate_resolution-Tuple{}"><a class="docstring-binding" href="#PlantGraphs.calculate_resolution-Tuple{}"><code>PlantGraphs.calculate_resolution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_resolution(;width = 1024/300*2.54, height = 768/300*2.54,
                      format = &quot;raster&quot;, dpi = 300)</code></pre><p>Calculate the resolution required to achieve a specific <code>width</code> and <code>height</code> (in cm) of the exported image, with a particular <code>dpi</code> (for raster formats).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Draw.jl#L188-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.data-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#PlantGraphs.data-Tuple{PlantGraphs.Context}"><code>PlantGraphs.data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">data(c::Context)</code></pre><p>Returns the data stored in a node. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L10-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.data-Tuple{PlantGraphs.GraphNode}"><a class="docstring-binding" href="#PlantGraphs.data-Tuple{PlantGraphs.GraphNode}"><code>PlantGraphs.data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">data(n::GraphNode)</code></pre><p>Returns the data stored in a graphnode. Users will generally not use this method as they will normally deal with <code>Context</code> objects.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L13-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.data-Tuple{PlantGraphs.Graph}"><a class="docstring-binding" href="#PlantGraphs.data-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.data</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>data(g::Graph)</p><p>Returns the graph-level variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; axiom = A();

julia&gt; g = Graph(axiom = axiom, data = 2);

julia&gt; data(g);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Graph.jl#L82-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.draw-Tuple{PlantGraphs.Graph}"><a class="docstring-binding" href="#PlantGraphs.draw-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.draw</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">draw(g::Graph; resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15,
     node_size = 5)</code></pre><p>Visualize a graph as network diagram.</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The graph to be visualized.</li></ul><p><strong>Keywords</strong></p><ul><li><code>resolution = (1920, 1080)</code>: The resolution of the image to be rendered, in pixels (online relevant for native and web backends). Default resolution is HD.</li><li><code>nlabels_textsize = 15</code>: Customize the size of the labels in the diagram.</li><li><code>arrow_size = 15</code>: Customize the size of the arrows representing edges in the diagram.</li><li><code>node_size = 5</code>: Customize the size of the nodes in the diagram.</li></ul><p><strong>Details</strong></p><p>By default, nodes are labelled with the type of data stored and their unique ID. See function <code>node_label()</code> to customize the label for different types of data.</p><p>See <code>save</code> from FileIO to export the network diagram as a raster or vector image (depending on the backend). The function <code>calculate_resolution()</code> can be useful to ensure a particular dpi of the exported image (assuming some physical size).</p><p>The graphics backend will interact with the environment where the Julia code is being executed (i.e., terminal, IDE such as VS Code, interactive notebook such as Jupyter or Pluto). These interactions are all controlled by the graphics package Makie that VPL relies on. Some details on the expected behavior specific to <code>draw()</code> can be found in the general VPL documentation.</p><p><strong>Returns</strong></p><p>This function returns a Makie <code>Figure</code> object, while producing the visualization as a side effect.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; import CairoMakie; # or GLMakie, WGLMakie, etc.

julia&gt; draw(g);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Draw.jl#L132-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.draw-Tuple{PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#PlantGraphs.draw-Tuple{PlantGraphs.StaticGraph}"><code>PlantGraphs.draw</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">draw(g::StaticGraph; resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15,
     node_size = 5)</code></pre><p>Equivalent to the method <code>draw(g::Graph; kwargs...)</code> but  to visualize static graphs (e.g., the axiom of a graph).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Draw.jl#L87-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.generate_id-Tuple{}"><a class="docstring-binding" href="#PlantGraphs.generate_id-Tuple{}"><code>PlantGraphs.generate_id</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate_id()</code></pre><p>Generate a new unique ID for a node in a graph and update the ID counter.</p><p><strong>Returns</strong></p><p>The new unique ID (an atomic <code>Int</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L15-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.get_descendant"><a class="docstring-binding" href="#PlantGraphs.get_descendant"><code>PlantGraphs.get_descendant</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_descendant(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Returns the first descendant of a node that matches the <code>condition</code>. Intended to be used within a rule or query.</p><p><code>getdescendant</code> is an alias for <code>get_descendant</code> for compatibility with AbstractTrees.jl</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input and returns <code>true</code> or <code>false</code>.</li><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when traversing the graph.</li></ul><p><strong>Details</strong></p><p>If <code>has_descendant()</code> returns <code>false</code> for the same node and <code>condition</code>, <code>get_descendant()</code> will return <code>missing</code>, otherwise it returns the <code>Context</code> associated to the matching node.</p><p><strong>Return</strong></p><p>Return a <code>Context</code> object or <code>missing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; function qfun(n)
           na = get_descendant(n, condition = x -&gt; (data(x).val == 1))
           if !ismissing(na)
               data(na) isa B1
           else
               false
           end
       end;

julia&gt; Q1 = Query(A1, condition = qfun);

julia&gt; R1 = apply(g, Q1);

julia&gt; Q2 = Query(B1, condition = qfun);

julia&gt; R2 = apply(g, Q2);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L385-L435">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.get_id!-Tuple{}"><a class="docstring-binding" href="#PlantGraphs.get_id!-Tuple{}"><code>PlantGraphs.get_id!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_id!()</code></pre><p>Get the current value of the ID counter for generating unique IDs for nodes in graphs.</p><p><strong>Returns</strong></p><p>The current value of the ID counter (an atomic <code>Int</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L37-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.get_root"><a class="docstring-binding" href="#PlantGraphs.get_root"><code>PlantGraphs.get_root</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">get_root(g::Graph)
get_root(g::StaticGraph)</code></pre><p>Extract the root node of a <code>Graph</code> or <code>StaticGraph</code> object.</p><p>You may also use <code>getroot</code> (for compatibility with AbstractTrees.jl).</p><p><strong>Returns</strong></p><p>The <code>GraphNode</code> object that is the root of the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L205-L216">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.graph-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#PlantGraphs.graph-Tuple{PlantGraphs.Context}"><code>PlantGraphs.graph</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">graph(c::Context)</code></pre><p>Returns the dynamic graph stored inside a <code>Context</code> object. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: The context associated to a node in a dynamic graph.</li></ul><p><strong>Returns</strong></p><p>The <code>Graph</code> object contained in the context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L21-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.graph_data-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#PlantGraphs.graph_data-Tuple{PlantGraphs.Context}"><code>PlantGraphs.graph_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">graph_data(c::Context)</code></pre><p>Returns the graph-level variables. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L35-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.has_ancestor"><a class="docstring-binding" href="#PlantGraphs.has_ancestor"><code>PlantGraphs.has_ancestor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_ancestor(node::GraphNode, g::Graph, condition, maxlevel::Int; level::Int=1)</code></pre><p>Check if a graph node has an ancestor that satisfies a given condition, with optional     recursive search up to a maximum depth.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>node::GraphNode</code>: The node from which to start the ancestor search.</li><li><code>g::Graph</code>: The graph containing the node.</li><li><code>condition</code>: A function that takes a <code>Context</code> and returns <code>true</code> if the ancestor matches</li></ul><p>the condition.</p><ul><li><code>maxlevel::Int</code>: The maximum depth to search for ancestors.</li><li><code>level::Int=1</code>: (Optional) The current recursion level (default is 1).</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(found::Bool, steps::Int)</code> where <code>found</code> is <code>true</code> if an ancestor matching the condition is found, and <code>steps</code> is the number of steps taken in the search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L197-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.has_ancestor-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#PlantGraphs.has_ancestor-Tuple{PlantGraphs.Context}"><code>PlantGraphs.has_ancestor</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_ancestor(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Check if a node has an ancestor that matches the condition. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input and returns <code>true</code> or <code>false</code>.</li><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when traversing the graph.</li></ul><p><strong>Details</strong></p><p>This function traverses the graph from the node associated to <code>c</code> towards the root of the graph until a node is found for which <code>condition</code> returns <code>true</code>. If no node meets the condition, then it will return <code>false</code>. The defaults values for this function are such that the algorithm always returns <code>true</code> after one step (unless it is applied to the root node) in which case it is equivalent to calling <code>has_parent</code> on the node.</p><p>The number of levels that the algorithm is allowed to traverse is capped by <code>max_level</code> (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).</p><p>The function <code>condition</code> should take an object of type <code>Context</code> as input and return <code>true</code> or <code>false</code>.</p><p><strong>Returns</strong></p><p>Return a tuple with two values a <code>Bool</code> and an <code>Int</code>, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(2) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; function qfun(n)
            has_ancestor(n, condition = x -&gt; data(x).val == 1)[1]
       end;

julia&gt; Q1 = Query(A1, condition = qfun);

julia&gt; R1 = apply(g, Q1);

julia&gt; Q2 = Query(B1, condition = qfun);

julia&gt; R2 = apply(g, Q2);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L98-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.has_children-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#PlantGraphs.has_children-Tuple{PlantGraphs.Context}"><code>PlantGraphs.has_children</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_children(c::Context)</code></pre><p>Check if a node has at least one child and return <code>true</code> or <code>false</code>. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L159-L164">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.has_children-Tuple{PlantGraphs.GraphNode}"><a class="docstring-binding" href="#PlantGraphs.has_children-Tuple{PlantGraphs.GraphNode}"><code>PlantGraphs.has_children</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_children(n::GraphNode)</code></pre><p>Check if a graph node has any children.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node to check for children.</li></ul><p><strong>Returns</strong></p><p><code>true</code> if the node has one or more children, otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L238-L251">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.has_descendant"><a class="docstring-binding" href="#PlantGraphs.has_descendant"><code>PlantGraphs.has_descendant</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">has_descendant(node::GraphNode, g::Graph, condition, maxlevel::Int; level::Int=1)</code></pre><p>Check if a graph node has a descendant that satisfies a given condition, with optional     recursive search up to a maximum depth.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>node::GraphNode</code>: The node from which to start the descendant search.</li><li><code>g::Graph</code>: The graph containing the node.</li><li><code>condition</code>: A function that takes a <code>Context</code> and returns <code>true</code> if the descendant</li></ul><p>matches the condition.</p><ul><li><code>maxlevel::Int</code>: The maximum depth to search for descendants.</li><li><code>level::Int=1</code>: (Optional) The current recursion level (default is 1).</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(found::Bool, steps::Int)</code> where <code>found</code> is <code>true</code> if a descendant matching the condition is found, and <code>steps</code> is the number of steps taken in the search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L274-L294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.has_descendant-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#PlantGraphs.has_descendant-Tuple{PlantGraphs.Context}"><code>PlantGraphs.has_descendant</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_descendant(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Check if a node has a descendant that matches the optional condition. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input and returns <code>true</code> or <code>false</code>.</li><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when traversing the graph.</li></ul><p><strong>Details</strong></p><p>This function traverses the graph from the node associated to <code>c</code> towards the leaves of the graph until a node is found for which <code>condition</code> returns <code>true</code>. If no node meets the condition, then it will return <code>false</code>. The defaults values for this function are such that the algorithm always returns <code>true</code> after one step (unless it is applied to a leaf node) in which case it is equivalent to calling <code>has_children</code> on the node.</p><p>The number of levels that the algorithm is allowed to traverse is capped by <code>max_level</code> (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).</p><p>The function <code>condition</code> should take an object of type <code>Context</code> as input and return <code>true</code> or <code>false</code>.</p><p><strong>Returns</strong></p><p>Return a tuple with two values a <code>Bool</code> and an <code>Int</code>, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(2) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; function qfun(n)
           has_descendant(n, condition = x -&gt; data(x).val == 1)[1]
       end;

julia&gt; Q1 = Query(A1, condition = qfun);

julia&gt; R1 = apply(g, Q1);

julia&gt; Q2 = Query(B1, condition = qfun);

julia&gt; R2 = apply(g, Q2);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L175-L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.has_parent-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#PlantGraphs.has_parent-Tuple{PlantGraphs.Context}"><code>PlantGraphs.has_parent</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_parent(c::Context)</code></pre><p>Check if a node has a parent and return <code>true</code> or <code>false</code>. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L63-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.has_parent-Tuple{PlantGraphs.GraphNode}"><a class="docstring-binding" href="#PlantGraphs.has_parent-Tuple{PlantGraphs.GraphNode}"><code>PlantGraphs.has_parent</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_parent(n::GraphNode)</code></pre><p>Check if a graph node has a parent.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node to check for a parent.</li></ul><p><strong>Returns</strong></p><p><code>true</code> if the node has a parent (i.e., its parent ID is not <code>missing</code>), otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L161-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.is_leaf-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#PlantGraphs.is_leaf-Tuple{PlantGraphs.Context}"><code>PlantGraphs.is_leaf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_leaf(c::Context)</code></pre><p>Check if a node is a leaf in the graph (i.e., has no children) and return <code>true</code> or <code>false</code>. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L167-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.is_leaf-Tuple{PlantGraphs.GraphNode}"><a class="docstring-binding" href="#PlantGraphs.is_leaf-Tuple{PlantGraphs.GraphNode}"><code>PlantGraphs.is_leaf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_leaf(n::GraphNode)</code></pre><p>Check if a graph node is a leaf node (i.e., has no children).</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node to check.</li></ul><p><strong>Returns</strong></p><p><code>true</code> if the node is a leaf node (has no children), otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L256-L269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.is_root"><a class="docstring-binding" href="#PlantGraphs.is_root"><code>PlantGraphs.is_root</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_root(c::Context)</code></pre><p>Check if a node is the root of the graph (i.e., has no parent) and return <code>true</code> or <code>false</code>. Intended to be used within a rule or query.</p><p><code>isroot</code> is an alias for <code>is_root</code> for compatibility with AbstractTrees.jl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L87-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.node_label-Tuple{PlantGraphs.Node, Any}"><a class="docstring-binding" href="#PlantGraphs.node_label-Tuple{PlantGraphs.Node, Any}"><code>PlantGraphs.node_label</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">node_label(n::Node, id)</code></pre><p>Function to construct a label for a node to be used by <code>draw()</code> when visualizing. The user can specialize this method for user-defined data types to customize the labels. By default, the type of data stored in the node and the unique ID of the node are used as labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Draw.jl#L3-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.reset_id!-Tuple{}"><a class="docstring-binding" href="#PlantGraphs.reset_id!-Tuple{}"><code>PlantGraphs.reset_id!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">reset_id!()</code></pre><p>Reset the ID counter for generating unique IDs for nodes in graphs to zero.</p><p><strong>Returns</strong></p><p>The new value of the ID counter (an atomic <code>Int</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L25-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.rewrite!-Tuple{PlantGraphs.Graph}"><a class="docstring-binding" href="#PlantGraphs.rewrite!-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.rewrite!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rewrite!(g::Graph)</code></pre><p>Apply the graph-rewriting rules stored in the graph.</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The graph to be rewritten. It will be modified in-place.</li></ul><p><strong>Details</strong></p><p>This function will match the left-hand sides of all the rules in a graph. If any node is matched by more than one rule this will result in an error. The rules are then applied in order to replaced the matched nodes with the result of executing the right hand side of the rules. The rules are applied in the order in which they are stored in the graph but the order in which the nodes are processed is not defined. Since graph rewriting is semantically a parallel process, the rules should not be rely on any particular order for their functioning.</p><p><strong>Returns</strong></p><p>This function returns <code>nothing</code>, but the graph passed as input will be modified by the execution of the rules.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; struct B &lt;: Node end;

julia&gt; axiom = A() + B();

julia&gt; rule = Rule(A, rhs = x -&gt; A() + B());

julia&gt; g = Graph(axiom = axiom, rules = rule);

julia&gt; rewrite!(g);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Rule.jl#L161-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.rules-Tuple{PlantGraphs.Graph}"><a class="docstring-binding" href="#PlantGraphs.rules-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.rules</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rules(g::Graph)</code></pre><p>Returns a tuple with all the graph-rewriting rules stored in a dynamic graph</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end;

julia&gt; struct B &lt;: Node end;

julia&gt; axiom = A() + B();

julia&gt; rule = Rule(A, rhs = x -&gt; A() + B());

julia&gt; rules_graph = Graph(axiom = axiom, rules = rule);

julia&gt; rules(rules_graph);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Graph.jl#L60-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.set_id!-Tuple{Any}"><a class="docstring-binding" href="#PlantGraphs.set_id!-Tuple{Any}"><code>PlantGraphs.set_id!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_id!(id)</code></pre><p>Set the ID counter for generating unique IDs for nodes in graphs to any integer value <code>id</code>.</p><p><strong>Returns</strong></p><p>The new value of the ID counter (an atomic <code>Int</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L47-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.static_graph-Tuple{PlantGraphs.Graph}"><a class="docstring-binding" href="#PlantGraphs.static_graph-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.static_graph</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">static_graph(g::Graph)</code></pre><p>Return the internal <code>StaticGraph</code> stored inside a dynamic <code>Graph</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The dynamic graph from which to retrieve the internal static graph.</li></ul><p><strong>Returns</strong></p><p>The <code>StaticGraph</code> object contained within the dynamic graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Graph.jl#L107-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.traverse-Tuple{PlantGraphs.Graph}"><a class="docstring-binding" href="#PlantGraphs.traverse-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.traverse</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">traverse(g::Graph; fun = () -&gt; nothing, order = &quot;any&quot;, ID = root_id(g))
traverse(g::StaticGraph; fun = () -&gt; nothing, order = &quot;any&quot;, ID = root_id(g))</code></pre><p>Iterates over all the nodes in the graph and execute for the function <code>fun</code> on each node</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code> or <code>g::StaticGraph</code>: The graph object that will be traversed.</li></ul><p><strong>Keywords</strong></p><ul><li><code>fun</code>: A function or function-like object defined by the user that will be applied to each node.</li><li><code>order</code>: Order in which the nodes in the graph will be visited. It can be &quot;any&quot; (default), &quot;dfs&quot; (depth-first search) or &quot;bfs&quot; (breadth-first search).</li><li><code>ID</code>: The ID of the node where the traveral should start. By default, traversal starts at the root of the graph.</li></ul><p><strong>Details</strong></p><p>When <code>order = &quot;any</code> traveral happens in the order in which the nodes are stored in the graph. This order is arbitrary (it does not correspond to the order in which nodes are created) but it should be reproducible (i.e., the same code will store the nodes in the same order). For algorithms that require use <code>any = &quot;dfs&quot;</code> or <code>any = &quot;bfs&quot;</code>.</p><p>When <code>order = &quot;dfs&quot;</code> the traveral happens in a depth-first order. That is, all nodes in a branch of the graph are visited until reach a leaf node, then moving to the next branch. Hence, this algorithm should always generate the same result when applied to the same graph (assuming the user-defined function is not stochastic)</p><p>When <code>order = &quot;bfs&quot;</code> the traveral happens in a breadth-first order. That is, all nodes at a given depth of the the graph are visited first, then moving on to the next level. Hence, this algorithm should always generate the same result when applied to the same graph (assuming the user-defined function is not stochastic). For a version of this function that us depth-first order see <code>traverse_dfs</code>.</p><p>This function does not store any results generated by <code>fun</code>. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).</p><p>The function or function-like object provided by the user should take only one argument that corresponds to applying <code>data()</code> to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see <code>Query</code> and general VPL documentation).</p><p><strong>Returns</strong></p><p>This function returns nothing but <code>fun</code> may have side-effects.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; struct Foo
         vals::Vector{Int}
       end;

julia&gt; function (f::Foo)(x)
         push!(f.vals, x.val)
       end;

julia&gt; f = Foo(Int[]);

julia&gt; axiom = A1(2) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; traverse(g, fun = f);

julia&gt; traverse(g, fun = f, order = &quot;dfs&quot;);

julia&gt; traverse(g, fun = f, order = &quot;bfs&quot;);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Algorithms.jl#L7-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.traverse_bfs-Tuple{PlantGraphs.Graph}"><a class="docstring-binding" href="#PlantGraphs.traverse_bfs-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.traverse_bfs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">traverse_bfs(g::Graph; fun = () -&gt; nothing, ID = root_id(g))
traverse_bfs(g::StaticGraph, fun, ID)</code></pre><p>Iterates over all the nodes in the graph in breadth-first order and executes the function <code>fun</code> on each node.</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code> or <code>g::StaticGraph</code>: The graph object to be traversed.</li></ul><p><strong>Keywords</strong></p><ul><li><code>fun</code>: A function or function-like object defined by the user that will be applied to each node.</li><li><code>ID</code>: The ID of the node where the traversal should start. By default, traversal starts at</li></ul><p>the root of the graph.</p><p><strong>Details</strong></p><p>Traversal happens in breadth-first order: all nodes at a given depth are visited first, then the algorithm moves to the next level. The function provided by the user should take only one argument corresponding to the data stored in each node. Results generated by <code>fun</code> are not stored by this function; side effects should be managed by the user.</p><p><strong>Returns</strong></p><p>This function returns nothing but <code>fun</code> may have side-effects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Algorithms.jl#L146-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.traverse_dfs-Tuple{PlantGraphs.Graph}"><a class="docstring-binding" href="#PlantGraphs.traverse_dfs-Tuple{PlantGraphs.Graph}"><code>PlantGraphs.traverse_dfs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">traverse_dfs(g::Graph; fun = () -&gt; nothing, ID = root_id(g))
traverse_dfs(g::StaticGraph, fun, ID)</code></pre><p>Iterates over all the nodes in the graph in depth-first order and executes the function <code>fun</code> on each node.</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code> or <code>g::StaticGraph</code>: The graph object to be traversed.</li></ul><p><strong>Keywords</strong></p><ul><li><code>fun</code>: A function or function-like object defined by the user that will be applied to each node.</li><li><code>ID</code>: The ID of the node where the traversal should start. By default, traversal starts at the root of the graph.</li></ul><p><strong>Details</strong></p><p>Traversal happens in depth-first order: all nodes in a branch are visited until a leaf node is reached, then the algorithm moves to the next branch. The function provided by the user should take only one argument corresponding to the data stored in each node. Results generated by <code>fun</code> are not stored by this function; side effects should be managed by the     user.</p><p><strong>Returns</strong></p><p>This function returns nothing but <code>fun</code> may have side-effects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Algorithms.jl#L100-L122">source</a></section></details></article><h2 id="Private"><a class="docs-heading-anchor" href="#Private">Private</a><a id="Private-1"></a><a class="docs-heading-anchor-permalink" href="#Private" title="Permalink"></a></h2><p>Private functions, types or constants from <code>PlantGraphs</code>. These are not exported, so you need to prefix the function name with <code>PlantGraphs.</code> to access them. Also bear in mind that these are not part of the public API, so they may change without notice.</p><article><details class="docstring" open="true"><summary id="Graphs.DiGraph-Tuple{PlantGraphs.Graph}"><a class="docstring-binding" href="#Graphs.DiGraph-Tuple{PlantGraphs.Graph}"><code>Graphs.DiGraph</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">GR.DiGraph(g::Graph)</code></pre><p>Translate a dynamic <code>Graph</code> object into a directed graph (DiGraph) structure for     visualization with GraphMakie. This method forwards the translation to the underlying     static graph contained in the <code>Graph</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The dynamic graph to be translated into a DiGraph.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(dg, labels, n)</code> where:</p><ul><li><code>dg</code>: The constructed DiGraph object.</li><li><code>labels</code>: An array of labels for each node.</li><li><code>n</code>: The number of nodes in the graph.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Draw.jl#L69-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Graphs.DiGraph-Tuple{PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#Graphs.DiGraph-Tuple{PlantGraphs.StaticGraph}"><code>Graphs.DiGraph</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">GR.DiGraph(g::StaticGraph)</code></pre><p>Translate a static graph into a directed graph (DiGraph) structure for visualization with     GraphMakie. Nodes are labelled using <code>node_label</code>, and edges represent parent-child     relationships.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code>: The static graph to be translated into a DiGraph.</li></ul><p><strong>Returns</strong></p><p>A tuple <code>(dg, labels, n)</code> where:</p><ul><li><code>dg</code>: The constructed DiGraph object.</li><li><code>labels</code>: An array of labels for each node.</li><li><code>n</code>: The number of nodes in the graph.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Draw.jl#L24-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.GraphNode"><a class="docstring-binding" href="#PlantGraphs.GraphNode"><code>PlantGraphs.GraphNode</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GraphNode</code></pre><p>Data structure that wraps the contents of a node and includes references to the ids of the parent and children node and the node itself. Users do not build <code>GraphNode</code> objects directly, this is always handled by VPL when creating or modifying a graph.</p><p>This type is mutable. All fields can be accessed through methods with the same name as the field.</p><p><strong>Fields</strong></p><ul><li><code>data</code>: Data stored in the node, which should inherit from <code>Node</code> (i.e., the object the           user creates).</li><li><code>children_id::OrderedSet{Int}</code>: Ids of the children nodes.</li><li><code>parent_id::Union{Int, Missing}</code>: Id of the parent node. If the node is a root node, this is <code>missing</code>.</li><li><code>self_id::Int</code>: Id of this node.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Types.jl#L27-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.StaticGraph-Tuple{PlantGraphs.GraphNode}"><a class="docstring-binding" href="#PlantGraphs.StaticGraph-Tuple{PlantGraphs.GraphNode}"><code>PlantGraphs.StaticGraph</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">StaticGraph(n::GraphNode)</code></pre><p>Create a <code>StaticGraph</code> from a single <code>GraphNode</code>. This is useful for initializing a graph with a root node.</p><p>Users will generally not use this method as they will normally deal with <code>Graph</code> objects rather than <code>StaticGraph</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The <code>GraphNode</code> to be used as the root of the graph.</li></ul><p><strong>Returns</strong></p><p>A <code>StaticGraph</code> object containing the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L88-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.StaticGraph-Tuple{PlantGraphs.Node}"><a class="docstring-binding" href="#PlantGraphs.StaticGraph-Tuple{PlantGraphs.Node}"><code>PlantGraphs.StaticGraph</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">StaticGraph(n::Node)</code></pre><p>Create a <code>StaticGraph</code> from a single object that inherits from <code>Node</code>.</p><p>Users will generally not use this method as they will normally deal with <code>Graph</code> objects rather than <code>StaticGraph</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::Node</code>: The object that inherits from <code>Node</code> to be used as the root of the graph.</li></ul><p><strong>Returns</strong></p><p>A <code>StaticGraph</code> object containing the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L112-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.StaticGraph-Tuple{}"><a class="docstring-binding" href="#PlantGraphs.StaticGraph-Tuple{}"><code>PlantGraphs.StaticGraph</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">StaticGraph()</code></pre><p>Generate an empty <code>StaticGraph</code> object.</p><p>Users will generally not use this method as they will normally deal with <code>Graph</code> objects rather than <code>StaticGraph</code> directly.</p><p><strong>Returns</strong></p><p>An empty <code>StaticGraph</code> object with no nodes, nodetypes, and both root and insertion IDs set to -1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L70-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractTrees.getdescendant"><a class="docstring-binding" href="#AbstractTrees.getdescendant"><code>AbstractTrees.getdescendant</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getdescendant(node::GraphNode, g::Graph, condition, maxlevel::Int; level::Int=1)</code></pre><p>Retrieve the descendant of a graph node that satisfies a given condition, with optional     recursive search up to a maximum depth.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>node::GraphNode</code>: The node from which to start the descendant search.</li><li><code>g::Graph</code>: The graph containing the node.</li><li><code>condition</code>: A function that takes a <code>Context</code> and returns <code>true</code> if the descendant</li></ul><p>matches the condition.</p><ul><li><code>maxlevel::Int</code>: The maximum depth to search for descendants.</li><li><code>level::Int=1</code>: (Optional) The current recursion level (default is 1).</li></ul><p><strong>Returns</strong></p><p>The descendant node that matches the condition, or <code>missing</code> if none is found or the node is a leaf node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L423-L442">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractTrees.getdescendant-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#AbstractTrees.getdescendant-Tuple{PlantGraphs.Context}"><code>AbstractTrees.getdescendant</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getdescendant(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Returns the first descendant of a node that matches the <code>condition</code>. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input and returns <code>true</code> or <code>false</code>.</li><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when traversing the graph.</li></ul><p><strong>Details</strong></p><p>This function traverses the graph from the node associated to <code>c</code> towards the leaves of the graph until a node is found for which <code>condition</code> returns <code>true</code>. If no node meets the condition, then it will return <code>missing</code>.</p><p><strong>Returns</strong></p><p>Return a <code>Context</code> object or <code>missing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L359-L377">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractTrees.getroot-Tuple{PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#AbstractTrees.getroot-Tuple{PlantGraphs.StaticGraph}"><code>AbstractTrees.getroot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getroot(g::StaticGraph)
getroot(g::Graph)</code></pre><p>Returns the root node of a <code>Graph</code> or <code>StaticGraph</code> object.</p><p><strong>Returns</strong></p><p>The <code>GraphNode</code> object that is the root of the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L195-L202">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractTrees.isroot-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#AbstractTrees.isroot-Tuple{PlantGraphs.Context}"><code>AbstractTrees.isroot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isroot(c::Context)</code></pre><p>Check if a node is the root of the graph (i.e., has no parent) and return <code>true</code> or <code>false</code>.     Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: The context associated to a node in a dynamic graph.</li></ul><p><strong>Returns</strong></p><p><code>true</code> if the node is the root of the graph, otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L73-L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="AbstractTrees.isroot-Tuple{PlantGraphs.GraphNode}"><a class="docstring-binding" href="#AbstractTrees.isroot-Tuple{PlantGraphs.GraphNode}"><code>AbstractTrees.isroot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">isroot(n::GraphNode)</code></pre><p>Check if a graph node is a root node (i.e., has no parent).</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node to check.</li></ul><p><strong>Returns</strong></p><p><code>true</code> if the node is a root node (has no parent), otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L179-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Tuple{PlantGraphs.GraphNode, PlantGraphs.GraphNode}"><a class="docstring-binding" href="#Base.:+-Tuple{PlantGraphs.GraphNode, PlantGraphs.GraphNode}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">+(n1::GraphNode, n2::GraphNode)</code></pre><p>Create a static graph with two nodes, where <code>n1</code> is the root and <code>n2</code> is appended as a  child at the insertion point.</p><p><strong>Arguments</strong></p><ul><li><code>n1::GraphNode</code>: The node to use as the root of the graph.</li><li><code>n2::GraphNode</code>: The node to append to the root node.</li></ul><p><strong>Returns</strong></p><p>A <code>StaticGraph</code> object with <code>n1</code> as the root and <code>n2</code> as the insertion point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphConstruction.jl#L78-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Tuple{PlantGraphs.GraphNode, Tuple}"><a class="docstring-binding" href="#Base.:+-Tuple{PlantGraphs.GraphNode, Tuple}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">+(n::GraphNode, T::Tuple)</code></pre><p>Creates a static graph as the result of appending a tuple of graphs or nodes <code>T</code> to the insertion point of the graph rooted at <code>n</code>. Each element in the tuple becomes a branch.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node to use as the root of the graph.</li><li><code>T::Tuple</code>: A tuple of graphs or nodes to append as branches.</li></ul><p><strong>Returns</strong></p><p>A <code>StaticGraph</code> with <code>n</code> as the root and all elements of the tuple appended as branches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphConstruction.jl#L222-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Tuple{PlantGraphs.Node, PlantGraphs.Node}"><a class="docstring-binding" href="#Base.:+-Tuple{PlantGraphs.Node, PlantGraphs.Node}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">+(n1::Node, n2::Node)</code></pre><p>Creates a graph with two nodes where <code>n1</code> is the root and <code>n2</code> is the insertion point.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + B1(1);

julia&gt; import CairoMakie; # or GLMakie, WGLMakie, etc.

julia&gt; draw(axiom);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphConstruction.jl#L98-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Tuple{PlantGraphs.Node, PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#Base.:+-Tuple{PlantGraphs.Node, PlantGraphs.StaticGraph}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">+(n::Node, g::StaticGraph)</code></pre><p>Creates a graph as the result of appending the static graph <code>g</code> to the node <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + B1(1);

julia&gt; axiom = A1(2) + axiom;

julia&gt; import CairoMakie; # or GLMakie, WGLMakie, etc.

julia&gt; draw(axiom);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphConstruction.jl#L146-L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Tuple{PlantGraphs.Node, Tuple}"><a class="docstring-binding" href="#Base.:+-Tuple{PlantGraphs.Node, Tuple}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">+(g::StaticGraph, T::Tuple)
+(n::Node, T::Tuple)</code></pre><p>Creates a graph as the result of appending a tuple of graphs/nodes <code>T</code> to the insertion point of the graph <code>g</code> or node <code>n</code>. Each graph/node in <code>L</code> becomes a branch.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + (B1(1) + A1(3), B1(4));

julia&gt; import CairoMakie; # or GLMakie, WGLMakie, etc.

julia&gt; draw(axiom);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphConstruction.jl#L236-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.Node}"><a class="docstring-binding" href="#Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.Node}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">+(g::StaticGraph, n::Node)</code></pre><p>Creates a graph as the result of appending the node <code>n</code> to the insertion point of graph <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(1) + B1(1);

julia&gt; axiom = axiom + A1(2);

julia&gt; import CairoMakie; # or GLMakie, WGLMakie, etc.

julia&gt; draw(axiom);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphConstruction.jl#L124-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.StaticGraph}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">+(g1::StaticGraph, g2::StaticGraph)</code></pre><p>Creates a graph as the result of appending <code>g2</code> to the insertion point of <code>g1</code>. The insertion point of the final graph corresponds to the insertion point of <code>g2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom1 = A1(1) + B1(1);

julia&gt; axiom2 = A1(2) + B1(2);

julia&gt; axiom = axiom1 + axiom2;

julia&gt; import CairoMakie; # or GLMakie, WGLMakie, etc.

julia&gt; draw(axiom);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphConstruction.jl#L169-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.append!-Tuple{PlantGraphs.StaticGraph, Any, PlantGraphs.GraphNode}"><a class="docstring-binding" href="#Base.append!-Tuple{PlantGraphs.StaticGraph, Any, PlantGraphs.GraphNode}"><code>Base.append!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">append!(g::StaticGraph, ID, n::GraphNode)</code></pre><p>Append a node to a specified node in a static graph.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code>: The static graph to which the node will be appended.</li><li><code>ID</code>: The ID of the node to which the new node will be appended as a child.</li><li><code>n::GraphNode</code>: The node to append to the graph.</li></ul><p><strong>Returns</strong></p><p>The unique ID assigned to the newly appended node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphConstruction.jl#L27-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.append!-Tuple{PlantGraphs.StaticGraph, Any, PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#Base.append!-Tuple{PlantGraphs.StaticGraph, Any, PlantGraphs.StaticGraph}"><code>Base.append!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">append!(g::StaticGraph, ID, gn::StaticGraph)</code></pre><p>Append a static graph to a specified node in another static graph. The insertion point of  the final graph is the insertion point of the appended graph.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code>: The static graph to which the other graph will be appended.</li><li><code>ID</code>: The ID of the node to which the root of the appended graph will be added as a child.</li><li><code>gn::StaticGraph</code>: The static graph to append.</li></ul><p><strong>Returns</strong></p><p>The ID of the insertion point of the appended graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphConstruction.jl#L48-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.empty!-Tuple{PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#Base.empty!-Tuple{PlantGraphs.StaticGraph}"><code>Base.empty!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">empty!(g::StaticGraph)</code></pre><p>Remove all nodes and nodetypes from a static graph, making it empty.</p><p>Users will generally not use this method as they will normally deal with <code>Graph</code> objects rather than <code>StaticGraph</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code>: The static graph to empty.</li></ul><p><strong>Returns</strong></p><p>Nothing. The graph is modified in place and all nodes and nodetypes are removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L320-L333">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.length-Tuple{PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#Base.length-Tuple{PlantGraphs.StaticGraph}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">length(g::StaticGraph)
length(g::Graph)</code></pre><p>Returns the number of nodes stored in a <code>StaticGraph</code> or <code>Graph</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code> or <code>g::Graph</code>: The static graph for which to count the nodes.</li></ul><p><strong>Returns</strong></p><p>An integer representing the number of nodes in the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L288-L299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.parent"><a class="docstring-binding" href="#Base.parent"><code>Base.parent</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">parent(n::GraphNode, g::Graph, nsteps::Int=1)</code></pre><p>Retrieve the parent or ancestor of a graph node in a graph, with optional recursion depth.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node for which to retrieve the parent or ancestor.</li><li><code>g::Graph</code>: The graph containing the node.</li><li><code>nsteps::Int=1</code>: (Optional) The number of steps to go up the ancestor chain (default is</li></ul><p>1 for direct parent).</p><p><strong>Returns</strong></p><p>The parent node if <code>nsteps == 1</code>, or the ancestor node <code>nsteps</code> away. Returns <code>missing</code> if     the node is a root node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L320-L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.parent-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#Base.parent-Tuple{PlantGraphs.Context}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parent(c::Context; nsteps::Int)</code></pre><p>Returns the parent of a node that is <code>nsteps</code> away towards the root of the graph. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>nsteps</code>: Number of steps to traverse the graph towards the root node.</li></ul><p><strong>Details</strong></p><p>If <code>has_parent()</code> returns <code>false</code> for the same node or the algorithm has reached the root node but <code>nsteps</code> have not been reached, then <code>parent()</code> will return <code>missing</code>, otherwise it returns the <code>Context</code> associated to the matching node.</p><p><strong>Return</strong></p><p>Return a <code>Context</code> object or <code>missing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A1 &lt;: Node val::Int end;

julia&gt; struct B1 &lt;: Node val::Int end;

julia&gt; axiom = A1(2) + (B1(1) + A1(3), B1(4));

julia&gt; g = Graph(axiom = axiom);

julia&gt; function qfun(n)
           np = parent(n, nsteps = 2)
           !ismissing(np) &amp;&amp; data(np).val == 2
       end;

julia&gt; Q1 = Query(A1, condition = qfun);

julia&gt; R1 = apply(g, Q1);

julia&gt; Q2 = Query(B1, condition = qfun);

julia&gt; R2 = apply(g, Q2);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L240-L283">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.parent-Tuple{PlantGraphs.GraphNode, PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#Base.parent-Tuple{PlantGraphs.GraphNode, PlantGraphs.StaticGraph}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parent(n::GraphNode, g::StaticGraph)</code></pre><p>Retrieve the parent node of a graph node from a static graph.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node for which to retrieve the parent.</li><li><code>g::StaticGraph</code>: The static graph containing the node.</li></ul><p><strong>Returns</strong></p><p>The parent node of <code>n</code> in the static graph, or <code>missing</code> if the node is a root node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L351-L365">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.Base.:+_unrolled_expansion_##232-Tuple{Any, Any}"><a class="docstring-binding" href="#PlantGraphs.Base.:+_unrolled_expansion_##232-Tuple{Any, Any}"><code>PlantGraphs.Base.:+_unrolled_expansion_##232</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">+(g::StaticGraph, T::Tuple)</code></pre><p>Creates a graph as the result of appending a tuple of graphs or nodes <code>T</code> to the insertion point of the static graph <code>g</code>. Each element in the tuple becomes a branch.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code>: The static graph to which the tuple will be appended.</li><li><code>T::Tuple</code>: A tuple of graphs or nodes to append as branches.</li></ul><p><strong>Returns</strong></p><p>The modified <code>StaticGraph</code> with all elements of the tuple appended as branches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphConstruction.jl#L199-L210">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.add!-Tuple{PlantGraphs.StaticGraph, PlantGraphs.GraphNode}"><a class="docstring-binding" href="#PlantGraphs.add!-Tuple{PlantGraphs.StaticGraph, PlantGraphs.GraphNode}"><code>PlantGraphs.add!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add!(g::StaticGraph, N::GraphNode)</code></pre><p>Add a new node to a static graph, automatically generating a unique ID for the node.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code>: The static graph to which the node will be added.</li><li><code>N::GraphNode</code>: The node to add to the graph.</li></ul><p><strong>Returns</strong></p><p>The unique ID assigned to the newly added node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphConstruction.jl#L8-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.add_child!-Tuple{PlantGraphs.GraphNode, Any}"><a class="docstring-binding" href="#PlantGraphs.add_child!-Tuple{PlantGraphs.GraphNode, Any}"><code>PlantGraphs.add_child!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">add_child!(n::GraphNode, id)</code></pre><p>Add a child ID to a graph node.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node to which to add the child.</li><li><code>id</code>: The ID of the child node to add.</li></ul><p><strong>Returns</strong></p><p>Nothing. The node is modified in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L114-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.change_id!-Tuple{PlantGraphs.GraphNode, Int64}"><a class="docstring-binding" href="#PlantGraphs.change_id!-Tuple{PlantGraphs.GraphNode, Int64}"><code>PlantGraphs.change_id!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">change_id!(n::GraphNode, id)</code></pre><p>Set the self ID of a graph node.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node for which to set the self ID.</li><li><code>id::Int</code>: The new ID to assign to the node.</li></ul><p><strong>Returns</strong></p><p>Nothing. The node is modified in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L133-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.children_id-Tuple{PlantGraphs.GraphNode}"><a class="docstring-binding" href="#PlantGraphs.children_id-Tuple{PlantGraphs.GraphNode}"><code>PlantGraphs.children_id</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">children_id(n::GraphNode)</code></pre><p>Returns the ids of the children nodes.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L34-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.has_node-Tuple{PlantGraphs.StaticGraph, Any}"><a class="docstring-binding" href="#PlantGraphs.has_node-Tuple{PlantGraphs.StaticGraph, Any}"><code>PlantGraphs.has_node</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_node(g::StaticGraph, ID)</code></pre><p>Check if a static graph contains a node with a given ID.</p><p>Users will generally not use this method as they will normally deal with <code>Graph</code> objects rather than <code>StaticGraph</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code>: The static graph to check.</li><li><code>ID</code>: The node ID to check for.</li></ul><p><strong>Returns</strong></p><p><code>true</code> if the graph contains a node with the given ID, otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L270-L284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.has_nodetype-Tuple{PlantGraphs.StaticGraph, Any}"><a class="docstring-binding" href="#PlantGraphs.has_nodetype-Tuple{PlantGraphs.StaticGraph, Any}"><code>PlantGraphs.has_nodetype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_nodetype(g::StaticGraph, T)</code></pre><p>Check if a static graph contains nodes of a given type.</p><p>Users will generally not use this method as they will normally deal with <code>Graph</code> objects rather than <code>StaticGraph</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code>: The static graph to check.</li><li><code>T</code>: The node type to check for (usually a <code>DataType</code>).</li></ul><p><strong>Returns</strong></p><p><code>true</code> if the graph contains nodes of type <code>T</code>, otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L153-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.id-Tuple{PlantGraphs.Context}"><a class="docstring-binding" href="#PlantGraphs.id-Tuple{PlantGraphs.Context}"><code>PlantGraphs.id</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">id(c::Context)</code></pre><p>Returns the unique identifier (ID) of the node stored in a <code>Context</code> object. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: The context associated to a node in a dynamic graph.</li></ul><p><strong>Returns</strong></p><p>The integer ID of the node contained in the context.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/Context.jl#L45-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.insertion-Tuple{PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#PlantGraphs.insertion-Tuple{PlantGraphs.StaticGraph}"><code>PlantGraphs.insertion</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">insertion(g::StaticGraph)
insertion(g::Graph)</code></pre><p>Returns the most recently inserted node in a <code>StaticGraph</code> or <code>Graph</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code> or <code>g::Graph</code>: The static graph from which to retrieve the node.</li></ul><p><strong>Returns</strong></p><p>The <code>GraphNode</code> object that is the most recently inserted node in the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L238-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.insertion_id-Tuple{PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#PlantGraphs.insertion_id-Tuple{PlantGraphs.StaticGraph}"><code>PlantGraphs.insertion_id</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">insertion_id(g::StaticGraph)
insertion_id(g::Graph)</code></pre><p>Returns the ID of the most recently inserted node in a <code>StaticGraph</code> or <code>Graph</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code> or <code>g::Graph</code>: The static graph from which to retrieve the insertion ID.</li></ul><p><strong>Returns</strong></p><p>The ID of the most recently inserted node in the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L222-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.nodes-Tuple{PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#PlantGraphs.nodes-Tuple{PlantGraphs.StaticGraph}"><code>PlantGraphs.nodes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nodes(g::StaticGraph)
nodes(g::Graph)</code></pre><p>Returns the nodes stored in a <code>StaticGraph</code> or <code>Graph</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code> or <code>g::Graph</code>: The static graph from which to retrieve the nodes.</li></ul><p><strong>Returns</strong></p><p>An <code>OrderedDict{Int, GraphNode}</code> containing all nodes in the graph, indexed by their IDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L255-L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.nodetypes-Tuple{PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#PlantGraphs.nodetypes-Tuple{PlantGraphs.StaticGraph}"><code>PlantGraphs.nodetypes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nodetypes(g::StaticGraph)
nodetypes(g::Graph)</code></pre><p>Returns the nodetypes stored in a static graph. This is a dictionary mapping each type of node stored in a graph to the ids of the nodes with that type.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code> or <code>g::Graph</code>: The <code>StaticGraph</code> or <code>Graph</code> from which to retrieve the nodetypes.</li></ul><p><strong>Returns</strong></p><p>An <code>OrderedDict</code> mapping types to <code>OrderedSet{Int}</code> containing the ids of the nodes of that type within the <code>Graph</code> or <code>StaticGraph</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L136-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.parent_id-Tuple{PlantGraphs.GraphNode}"><a class="docstring-binding" href="#PlantGraphs.parent_id-Tuple{PlantGraphs.GraphNode}"><code>PlantGraphs.parent_id</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">parent_id(n::GraphNode)</code></pre><p>Returns the id of the parent node.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L24-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.prune!-Tuple{PlantGraphs.StaticGraph, Any}"><a class="docstring-binding" href="#PlantGraphs.prune!-Tuple{PlantGraphs.StaticGraph, Any}"><code>PlantGraphs.prune!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prune!(g::StaticGraph, ID)</code></pre><p>Remove a node and all its descendants from a static graph. Updates the root or insertion point if required, and always updates edges from other nodes. The algorithm starts from the leaf nodes and works its way back to the pruning node.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code>: The static graph from which to prune nodes.</li><li><code>ID</code>: The ID of the node to prune (and all its descendants).</li></ul><p><strong>Returns</strong></p><p>Nothing. The graph is modified in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphRewriting.jl#L42-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.remove!-Tuple{PlantGraphs.StaticGraph, Any}"><a class="docstring-binding" href="#PlantGraphs.remove!-Tuple{PlantGraphs.StaticGraph, Any}"><code>PlantGraphs.remove!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">remove!(g::StaticGraph, ID)</code></pre><p>Remove a node from a static graph by its ID. Updates the root and insertion points if necessary. If the graph only contains one node, the graph is emptied.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code>: The static graph from which to remove the node.</li><li><code>ID</code>: The ID of the node to remove.</li></ul><p><strong>Returns</strong></p><p>Nothing. The graph is modified in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphRewriting.jl#L8-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.remove_child!-Tuple{PlantGraphs.GraphNode, Any}"><a class="docstring-binding" href="#PlantGraphs.remove_child!-Tuple{PlantGraphs.GraphNode, Any}"><code>PlantGraphs.remove_child!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">remove_child!(n::GraphNode, id)</code></pre><p>Remove the id of a child from a graph node (this does not actually remove the child node from the graph).</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node from which to remove the child.</li><li><code>id</code>: The ID of the child node to remove.</li></ul><p><strong>Returns</strong></p><p>Nothing. The node is modified in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L95-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.remove_parent!-Tuple{PlantGraphs.GraphNode}"><a class="docstring-binding" href="#PlantGraphs.remove_parent!-Tuple{PlantGraphs.GraphNode}"><code>PlantGraphs.remove_parent!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">remove_parent!(n::GraphNode)</code></pre><p>Remove the parent ID from a graph node, setting it to <code>missing</code>.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node for which to remove the parent.</li></ul><p><strong>Returns</strong></p><p>Nothing. The node is modified in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L78-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.replace!-Tuple{PlantGraphs.StaticGraph, Any, PlantGraphs.GraphNode}"><a class="docstring-binding" href="#PlantGraphs.replace!-Tuple{PlantGraphs.StaticGraph, Any, PlantGraphs.GraphNode}"><code>PlantGraphs.replace!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">replace!(g::StaticGraph, ID, n::GraphNode)</code></pre><p>Replace a node in a static graph by a new node. The new node inherits the parents and children of the old node. The old node is removed and the new node is added with the same ID.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code>: The static graph in which to perform the replacement.</li><li><code>ID</code>: The ID of the node to be replaced.</li><li><code>n::GraphNode</code>: The new node to insert in place of the old node.</li></ul><p><strong>Returns</strong></p><p>Nothing. The graph is modified in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphRewriting.jl#L77-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.replace!-Tuple{PlantGraphs.StaticGraph, Int64, PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#PlantGraphs.replace!-Tuple{PlantGraphs.StaticGraph, Int64, PlantGraphs.StaticGraph}"><code>PlantGraphs.replace!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">replace!(g::StaticGraph, ID::Int, gn::StaticGraph)</code></pre><p>Replace a node in a static graph by a whole new subgraph. The root node of the subgraph inherits the ID and parents of the old node. The insertion node of the subgraph inherits the children of the old node. The insertion node of the subgraph will change if the replaced node was the insertion point.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code>: The static graph in which to perform the replacement.</li><li><code>ID</code>: The ID of the node to be replaced.</li><li><code>gn::StaticGraph</code>: The subgraph to insert in place of the old node.</li></ul><p><strong>Returns</strong></p><p>Nothing. The graph is modified in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphRewriting.jl#L113-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.root_id-Tuple{PlantGraphs.StaticGraph}"><a class="docstring-binding" href="#PlantGraphs.root_id-Tuple{PlantGraphs.StaticGraph}"><code>PlantGraphs.root_id</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">root_id(g::StaticGraph)
root_id(g::Graph)</code></pre><p>Returns the ID of the root node in a <code>StaticGraph</code> or <code>Graph</code> object.</p><p><strong>Arguments</strong></p><ul><li><code>g::StaticGraph</code> or <code>g::Graph</code>: The <code>StaticGraph</code> or <code>Graph</code> from which to retrieve the root ID.</li></ul><p><strong>Returns</strong></p><p>The ID of the root node in the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/StaticGraph.jl#L180-L191">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.self_id-Tuple{PlantGraphs.GraphNode}"><a class="docstring-binding" href="#PlantGraphs.self_id-Tuple{PlantGraphs.GraphNode}"><code>PlantGraphs.self_id</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">self_id(n::GraphNode)</code></pre><p>Returns the id of this node.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L44-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PlantGraphs.set_parent!-Tuple{PlantGraphs.GraphNode, Any}"><a class="docstring-binding" href="#PlantGraphs.set_parent!-Tuple{PlantGraphs.GraphNode, Any}"><code>PlantGraphs.set_parent!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_parent!(n::GraphNode, id)</code></pre><p>Set the parent ID of a graph node.</p><p>Users will generally not use this method as they will normally deal with <code>Context</code> objects rather than <code>GraphNode</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>n::GraphNode</code>: The node for which to set the parent.</li><li><code>id</code>: The ID of the parent node (or <code>missing</code> for root nodes).</li></ul><p><strong>Returns</strong></p><p>Nothing. The node is modified in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/v0.1.2/src/GraphNode.jl#L60-L74">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../howto/Slicer/">« Using the slicer</a><a class="docs-footer-nextpage" href="../geometry/">Scenes and 3D meshes »</a><div class="flexbox-break"></div></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 30 January 2026 10:37">Friday 30 January 2026</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
